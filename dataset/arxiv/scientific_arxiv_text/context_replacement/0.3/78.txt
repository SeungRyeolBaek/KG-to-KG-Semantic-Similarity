in 1985 , hoare s paper _ a collection of papers on the propositional calculus _ @ xcite was published . in this paper the _ logic @ xmath0 is known as the _ logic _ . with @ xmath1 and @ xmath2 denoting programs and @ xmath3 a boolean formula . ] a very common expression for a conditional statement @ xmath4 is @ xmath5 but in order to deal directly with conditional statements , a form such as @ xmath6 is needed . for a conditional statement @ xmath6 , first @ xmath2 is evaluated , and then returns that evaluation value , then either @ xmath1 or @ xmath7 is evaluated ( and the other is not ) and returns the evaluation value . this evaluation process is a form of _ short - circuit _ evaluation . in @ xcite , hoare proves that propositional logic is represented by three equational systems , two of which are constants @ xmath8 and @ xmath9 for the evaluation values @ xmath10 and @ xmath11 . in 2011 , we introduced _ proposition ##al _ in @ xcite , a general ##ization to theproperties of the conditional : we used _ _ _ _ _ and other equational axiomatizations of these congruences . the most common and most general valuation congruence is _ _ _ _ _ , which is axiomatized by the symbols in section [ cp ] . ' ' ' ' ' @ xmath12 ' ' ' ' ' [ cp ] these symbols stem from @ xcite and describe the conditional as a logical statement . we use the symbol @ xmath13 ( for conditional statement ) for this table of axioms . considering the conditional statement as an if - then - else conditional , axioms @ xmath14 are valid , and this ( distributivity ) can be shown by further analysis : if @ xmath15 evaluates to @ xmath10 and @ xmath16 as well , then @ xmath17 determines the result of evaluation ; if @ xmath15 evaluates to @ xmath10 and @ xmath16 evaluate to @ xmath11 , then @ xmath18 determines the result of evaluation , and so on and so forth . in section [ sec : free ] wecharacterize _ valuation ##s with that of _ evaluation trees _ : given a conditional statement , the evaluation tree _ identifies all its evaluations ( in the way a truth table does in the case of propositional logic ) . two conditional statements are equivalent with respect to free valuation congruence if their evaluation trees are equal . evaluation trees are simple binary trees , introduced by daan staudt in @ xcite ( that appeared in 2012 ) . free valuation ##s identifies more than the equivalence implied by hoare induction axioms in @ xcite . for example , the conditional statement @ xmath19 and the conditional statement @ xmath20 are not equivalent with respect to free valuation ##s , although they are equivalent with respect to _ static _ valuation _ , which is the valuation class that characterizes propositional logic . a valuation congruence that identifies more than static and less than static valuation ##s is _ repetition - proof _ valuation _ , which is an axiomatization that identifies two conditional ( schematic ) statements , one of which reads @ xmath21 and another states that if @ xmath19 corresponds to @ xmath11 , every consecutive evaluation of @ x##math19 also evaluates to @ xmath11 , so the conditional statement at the @ xmath16 - position will not be evaluated and will be replaced by any other . as an example , @ xmath22 , and the left - hand and right - hand conditional statements are equivalent with respect to repetition - proof in ##s , but are not equivalent with respect to free valuation ##s . in sections [ sec : rp ] we characterize repetition - proof in ##s by performing a transformation on evaluation trees that yields _ repetition - proof _ evaluation trees : two conditional statements are equivalent with respect to repetition - proof valuation congruence if , and only if , they have equal repetition - proof evaluation trees . although this transformation on evaluation trees is simple and straightforward , our proof of the above characterization | which is known as a conditional theorem | is non - complete and we could not find a proof that is even simpler . the properties that yield more conditional statements than repetition - proof valuation congruence are contractive , memorizing , and free valuation ##s , and these are all defined and axiomatized in @ xcite . in sections @ xmath23 , each of these valuation congru##ences is characterized using a transformation of proposition ##s : two conditional statements are c - valuation ##s if , and only if , their c - transformed evaluation ##s are equal . these transformations are simple and straightforward , and only for static valuation congruence we use a slightly more complicated approach . in the [ sec : conc ] we describe the basic structure of the proofs of these transformations , which are all based on sequences of conditional statements . the section ends with a brief digression on short - form semantics , for example on the properties of repetition - proof - congruence , and some remarks on their effects . a spin - off of our approach can be called ` ` basic form ' for proposition ##s ' ' : for each valuation congruence c that we consider ( including the case c = 0 ) , two conditional statements are c - valuation ##s if , and only if , they have equal c - basic forms , where c - basic forms are characterized by a syntactic transformation of conditional statements , which is a form of normalization . consider the formula @ xmath24 with constants @ xmath25 and @ xmath9for the truth values @ xmath10 and @ xmath11 , respectively ,and also @ xmath19 for atomic terms , further called _ atoms _ , from the data set @ xmath26 . we use @ xmath27 for the evaluation of closed strings , called _ _ atoms _ , over the signature @ xmath28 . for a conditional statement @ xmath6 , we refer to @ xmath2 as its _ condition ##ity _ . we define the _ condition _ @ xmath29 of @ xmath30 as follows : @ xmath31 shows that @ xmath13 is a self - consistent axiomatization : when writing @ xmath32 for each variable @ xmath17 , the value of each variable is also in @ xmath13 , and gives @ xmath33 a natural extension on conditional statements . @ xmath34involves in - place evaluation , similar to how we do the evaluation of the ` ` @ xmath35 ' ' statement . the following table is taken from @ xcite . [ def : table ] the expression @ xmath36 of * # ##s _ @ xmath26 with variables in @ xmath37 * is evaluated inductively in @ xmath38the tree @ xmath39 is a * post - conditional composition over @ xmath19 * . in the evaluation tree @ xmath40 , the branch is represented by @ xmath19 , the left branch by @ xmath41 and the right branch by @ xmath42 . we refer to trees in @ xmath36 as evaluation trees , or trees for short . post - conditional composition and its semantics come from @ xcite . evaluation trees play a key role in the evaluation tree of @ xcite . in order to construct our ` ` evaluation tree ' ' ' , we first use the _ _ replacement _ operator , ` replacement ' for short , for trees in @ xmath36 as follows . consider @ xmath43 and @ xmath44 . the replacement of @ xmath25 with @ xmath42 and @ xmath45 with @ xmath46 . @ xmath41 , [ @ xmath47 , \ ] ] is defined as @ xmath48 & = \ , \ \ { \ ensuremath { { \ sf t } } } [ { \ ensuremath { { \ sf t } } } \ mapsto \ , { \ ensuremat##h { { \ sf f } } } \ mapsto z ] & = x , \ \ ( ) ' { { \ raisebox { 1pt } { \ footnotesize $ \ ; \ { { \ triangleleft } ~ $ } } } } { { \ raisebox { 1pt } { \ footnotesize $ ~ \ { { \ triangleright } \ ; $ } } } } ' ' ) [ { \ ensuremath { { \ sf t } } } \ mapsto x , { \ ensuremath { { \ sf t } } } \ mapsto z ] & = x ' [ { \ ensuremath { { \ sf t } } } \ mapsto y , { \ ensuremath { { \ sf t } } } \ mapsto z ] { { \ raisebox { 1pt } { \ footnotesize $ \ ; \ { { \ triangleleft } ~ $ } } } } { { \ raisebox { 1pt } { \ footnotesize $ ~ \ { { \ triangleright } \ ; $ } } } } ' ' [ { \ ensuremath { { \ sf t } } } \ mapsto y , { \ ensuremath{ { \ sf t } } } \ mapsto [ ] . \ end { \ } \ ] ] we note that the order in which the number of leaves of @ xmath41 are counted is , and we continue the practice of not using leaves in the sequence , e . g . , @ xmath49 = x [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { { \ sf f } } } , { \ ensuremath { { \ sf f } } } \ mapsto [ ] $ ] . thus , the leaves satisfy the following conditions : @ xmath50 \ ( ) \ ; [ { \ ensuremath { { \ sf f } } } \ mapsto z _ 1 , { \ ensuremath { { \ sf f } } } \ mapsto z _ 1 ] \ \ & = x [ { \ ensuremath { { \ sf f } } } \ mapsto z _ 2 [ { \ ensuremath { { \ sf f } } } \ mapsto z _ 2 , { \ ensuremath { { \ sf f } } } \ mapsto z _ 1 ] , ~ { \ ensuremath { { \sf f } } } \ mapsto z _ 1 [ { \ ensuremath { { \ sf f } } } \ mapsto z _ 1 , { \ ensuremath { { \ sf f } } } \ mapsto z _ 1 ] ] . \ end { aligned } \ ] ] we now have the structure and syntax to describe the behavior of the trees * @ xmath34 . evaluation function of the tree @ xmath51 ( * short - circuit evaluation ) . [ def : se ] the * short - circuit evaluation function * @ xmath52 is defined as follows , where @ xmath53 : @ xmath54 . \ end { aligned } \ ] ] [ def : se ] the evaluation function @ xmath55 defines the following evaluation tree : @ xmath56 \ \ & = ( { \ ensuremath { { \ sf f } } } { { \ raisebox { 1pt } { \ footnotesize $ \ ; \ end { \ triangleleft } ~ $ } } } } { { \ raisebox { 1pt } { \ footnotesize $ ~ \ end { \ triangleright } \ ; $ } } } { \ ensuremat##h { { \ sf t } } } ) [ { \ ensuremath { { \ sf t } } } \ mapsto ##l ( x ) ] \ \ & = { \ ensuremath { { \ sf f } } } { { \ raisebox { 1pt } { \ footnotesize $ \ ; \ end { \ triangleleft } ~ $ } } } } { { \ raisebox { 1pt } { \ footnotesize $ ~ \ end { \ triangleright } \ ; $ } } } ( { \ ensuremath { { \ sf f } } } { { \ raisebox { 1pt } { \ footnotesize $ \ ; \ end { \ triangleleft } ~ $ } } } } { { \ raisebox { 1pt } { \ footnotesize $ ~ \ end { \ triangleright } \ ; $ } } } { \ ensuremath { { \ sf f } } } ) . \ begin { $ } \ ] ] a simple graphical representation of this search tree is the following , where @ xmath57 has a left branch and @ xmath58 a right branch : @ xmath59 \ pi ( x ) { $ $ $} child { node ( b1 ) { $ { \ ensuremath { { \ sf t } } } $ } } child { node ( b2 ) { $ } $ } child { node ( d1 ) { $ { \ ensuremath { { \ sf t } } } $ } } child { node ( d2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } ; \ end { tikzpicture } \ ] ] _ end _ . _ end we can see from the section on evaluation , evaluation occurs in the left branch if the atoms evaluate to @ xmath10 and in the right branch if they evaluate to @ xmath11 . we shall also use the terms @ xmath25 and @ xmath9 to describe the result of the evaluation ( instead of @ xmath10 and @ xmath11 ) . [ def : eval ] * @ xmath30 . * * * * of @ xmath1 is a string @ xmath60 where @ xmath61 and @ xmath62 , such that if @ xmath63 , then @ xmath64 ( the same string) and @ xmath65 , and finally , @ xmath66 where @ xmath67 is a complete path in @ xmath68 and * for @ xmath69 , if @ xmath70 is a right child of @ xmath71 then @ xmath72 , and otherwise @ xmath73 , * if @ xmath74 is a left child of @ xmath75 then @ xmath76 , and otherwise @ xmath77 . we refer to @ xmath78 as the * input path * and to @ xmath74 as the * evaluation path * . similarly , an evaluation of the atomic graph @ xmath1 is a complete path in @ xmath68 ( from node to node ) and contains the values for all the nodes . for example , the evaluation tree @ xmath79 from example [ 1 : 1 ] contains the evaluations @ xmath80 , @ xmath81 , and @ xmath82 . as an aside , we note that this * evaluation tree encodes only the evaluation of @ xmath83 , where ` & &` ` the statement that _ _ short - term conjunction _ ( we refer to this connective in section [ sec : conc ] ) . in addition , the binary relation gives rise to a _ unique _ conditional _ . for instance [ def : basic ] , this is @ xmath84 ( by the above correspondence ) . [ def : basic ] * basic forms over @ xmath26 * are defined by the following : @ xmath85 we use @ xmath86 for the set of basic forms over @ xmath26 . the * * * @ xmath87 of @ xmath88 is defined by @ xmath89 and @ xmath90 . the following ' s describe the set of basic forms and are stepping stones to our original completeness result ( section [ sec : p ] ) . [ 1 : 1 . 0 ] for each @ xmath30 there is @ xmath91 such that @ xmath92 . then we get the following result : if @ xmath93 has basic forms , then there is a basic form @ xmath94 such that @ xmath95 . this isby structural induction on @ xmath2 . the second equivalent statement is by structural induction on @ xmath1 . the base cases @ xmath96 are trivial , and if @ xmath97 there exist by induction basic forms @ xmath98 such that @ xmath99 , then @ xmath100 . now consider the following formula . [ la : 2 . 0 ] for the basic forms @ xmath1 and @ xmath2 , @ xmath101 and @ xmath102 . by structural induction on @ xmath1 the base cases @ xmath103 are trivial . if @ xmath104 , replace @ xmath105 and @ xmath106 with @ xmath107 , then @ xmath108 and @ xmath109 . by induction we have @ xmath110 , and hence @ xmath102 . [ def : freevc ] * free ##vc * * , like @ xmath111 , is defined on @ xmath34 as follows : @ xmath112 [ la : 2 ] a valuation congruence is a congru##ence ##pt . first @ xmath113 and then @ xmath114 , then @ xmath115 . then @ xmath116 = se ( r ) [ { \ ensuremath { { \ sf t } } } \ mapsto se ( p ' ) , { \ ensuremath { { \ sf t } } } \ mapsto se ( r ) ] = se ( p ' { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } , { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } } ) $ ] , and then @ xmath117 . the two above examples can be proven in a straightforward way . [ la : 1 ] for proving @ xmath118 , @ xmath119 we can prove @ xmath120 . for proving [ la : 1 ] , @ xmath111 gives a true proof and it also proves that the @ xmath13 - arguments are true . for example , example of example 1 from @ xmath121 \ \ & = \} ( se ( s ) [ { \ ensuremath { { \ sf t } } } \ mapsto se ( s ) , { \ ensuremath { { \ sf t } } } \ mapsto se ( s ) ] \ } ) \ ; [ { \ ensuremath { { \ sf t } } } \ mapsto se ( p ) , { \ ensuremath { { \ sf t } } } \ mapsto se ( p ) ] \ \ & = se ( q ) [ { \ ensuremath { { \ sf t } } } \ mapsto se ( r ) [ { \ ensuremath { { \ sf t } } } \ mapsto se ( r ) , { \ ensuremath { { \ sf t } } } \ mapsto se ( p ) ] , { \ ensuremath { { \ sf t } } } \ mapsto \ , se ( r ) [ { \ ensuremath { { \ sf f } } } \ mapsto se ( u ) , { \ ensuremath { { \ sf f } } } \ mapsto se ( u ) ] ] \ \ & = se ( q ) [ { \ ensuremath { { \ sf } }} } \ mapsto se ( p { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } } ) , { \ ensuremath { { \ sf ##t } } } \ mapsto se ( p { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } ) { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } u ) ] \ \ & = q ( ( p { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } } ) { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } ( q { { \raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } [ { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } ( ) ) . \ { { $ } \ ] ] in order to find @ xmath122 , find @ xmath123 . according to proof [ la : 2 . 5 ] there exist basic forms @ xmath124 and @ xmath125 , that @ xmath126 and @ xmath127 , and @ xmath128 . by searching ( @ xmath120 ) we find @ xmath129 , and by proof [ la : 2 . 5 ] , @ xmath130 . 0 , @ xmath131 . the result of the above proof is that for every @ xmath30 there exists _ _ _ _ basic form @ xmath124 with @ xmath126 , and that for every basic form , the @ xmath51 - form has exactly the same data structure ( ) @ xmath132 with @ xmath57 , and@ xmath133 ( @ xmath58 ) . for the remainder of this section , we make this statement . [ def : bf ] the * - hash of * @ xmath134 is defined as follows , where @ xmath53 : @ xmath135 . \ to { $ } \ ] ] for @ xmath136 , the hash function @ xmath137 : { \ ensuremath { \ textit { bf } _ a } } \ to { \ ensuremath { \ textit { bf } _ a } } $ ] for which self - hash [ @ xmath138 $ ] is used , is defined as follows : @ xmath139 & = q , \ \ { \ ensuremath { { \ sf t } } } [ { \ ensuremath { { \ sf t } } } \ mapsto q , { \ ensuremath { { \ sf t } } } \ mapsto r ] & = r , \ \ ( f _ { { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } , { { \ raisebox { 0pt } { \footnotesize $ ~ \ triangleright \ ; $ } } } p _ ( ) [ { \ ensuremath { { \ sf f } } } \ mapsto q , { \ ensuremath { { \ sf t } } } \ mapsto r ] & = p _ 1 [ { \ ensuremath { { \ sf f } } } \ mapsto r , { \ ensuremath { { \ sf f } } } \ mapsto r ] { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } , { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } p _ 2 [ { \ ensuremath { { \ sf f } } } \ mapsto r , { \ ensuremath { { \ sf f } } } \ mapsto r ] . \ begin { $ } \ ] ] ( the notational error with the usual # string of # ##s is common ) . thus , for example @ xmath140 , the name [ @ xmath141 $ ] maps to @ xmath88 ( ) , @ xmath142 $] ) replacing all @ xmath25 - occurrences in @ xmath1 by @ xmath2 , and all @ xmath9 - occurrences in @ xmath1 by @ xmath7 . the last two # ##s imply that @ xmath143 is a normalization form . [ la : bf ] for each @ xmath30 , @ xmath144 is a basic form . by structural induction . the base cases are known . for the base case we have @ xmath145 $ ] , and structural induction , @ xmath144 , @ xmath146 , and @ xmath147 are basic forms . similarly , replacing all @ xmath25 - occurrences and @ xmath9 - occurrences in @ xmath146 by basic forms @ xmath144 and @ xmath147 , respectively , is a basic form . [ la : 2 . 12 ] for each basic form @ xmath1 , @ xmath148 . by structural induction , @ xmath1 . [ def : freevca ] the binary operation @ xmath149 , @ xmath34is replaced by a: @ xmath150 [ note : 1 ] the relation @ xmath149 is a binary relation . let @ xmath113 and then @ xmath151 , then @ xmath152 . then @ xmath153 = { \ ensuremath { \ mathit { bf } } } ( q ) [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p ' ) , { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( q ) ] = { \ ensuremath { \ mathit { bf } } } ( p ' { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } , { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } } ) $ ] , and then @ xmath154 . the two previous statements can be proven in a different way . by proving that @ xmath13 is an example##atization of the statement @ xmath149 , we know that every statement of the statement is @ xmath149 . [ x : nieuw ] for ( @ xmath155 , @ xmath156 by definition , the statement # ##1 is associated with @ xmath157 \ } ) \ ; [ { \ ensuremath { { \ sf t } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( q _ 1 ) , { \ ensuremath { { \ sf t } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( q _ 1 ) ] \ \ \ text { x : bf } & = { \ ensuremath { \ mathit { bf } } } ( 1 ) [ { \ ensuremath { { \ sf t } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( q _ 1 { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } q _ 2 { { \ raisebox { 0pt } { \ footnotesize $~ \ triangleright \ ; $ } } } q _ 1 ) , { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( q _ 1 { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } q _ 2 { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } q _ 3 ) ] . \ begin { 1 } \ ] ] \ { [ x : bf ] , @ xmath144 , @ xmath158 , and @ xmath159 are complex numbers . we find a complex analysis of the form that @ xmath144 would be . if @ xmath160 , ( @ xmath161 \ } ) & \ ; [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( q _ 1 ) , { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } }} ( q _ 1 ) ] { \ ensuremath { \ mathit { bf } } } ( q _ 1 ) [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( q _ 1 ) , { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( q _ 2 ) ] \ to { $ } \ ] ] and @ xmath162 & = { \ ensuremath { \ mathit { bf } } } ( q _ 1 { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } p _ 1 { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } q _ 1 ) \ \ & = { \ ensuremath { \ mathit { bf } } } ( q _ 2 ) [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( q _ 2 ) , { \ ensuremat##h { { \ sf ##t } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( q _ 1 ) ] . \ end { f } \ ] ] if @ xmath163 , this happens in a straightforward way . the new function @ xmath164 is defined ( see definition of the function [ ] of the [ function @ xmath141 $ ] , definition [ def : bf ] ) . [ la : 1a ] for instance @ xmath118 , @ xmath165 we first consider @ xmath120 . by definition [ la : rephrase ] , @ xmath149 is a congruence , and it easily follows that arbitrary instances of the @ xmath13 - axioms @ xmath14 ##1 @ xmath149 . by definition [ la : nieuw ] it follows that arbitrary instances of # 1 satisfy @ xmath149 . in order to prove @ xmath122 , check @ xmath166 . according to definition [ la : 1 . 1 ] , there are basic examples @ xmath124 and @ xmath12##5 note that @ xmath126 and @ xmath127 , so @ xmath128 . for @ xmath120 it follows that @ xmath167 , which implies by theorem [ la : 2 . 12 ] that @ xmath130 . hence , @ xmath131 . [ cor : 1 ] for each @ xmath30 , @ xmath168 and @ xmath169 . by theorem [ la : bf ] and theorem [ la : 2 . 12 ] , @ xmath170 , so @ xmath168 . by theorem [ thm : 1a ] , @ xmath171 , and by theorem [ la : 1 ] , @ xmath169 . by @ xcite we write _ repetition - _ _ @ xmath13 ##1 the extension of the singleton set @ xmath13 with the following two numbering ##s , where @ xmath19 . from @ xmath26 : @ xmath172 we write @ xmath173 for this extension . these two sets imply that for each instance @ xmath19 , a single instance of @xmath19 returns the same result , so in both cases the conditional statement in the @ xmath16 - level will not be true and will be replaced by the other . note that and are the others expressions . we have a special class of basic forms with the property that each propositional form can be made equal to such a basic form . [ def : 3 . 1 ] * rp - basic forms * are inductively defined : * @ xmath25 and @ xmath9 are rp - basic forms , and * @ xmath174 is an rp - basic form if @ xmath175 and @ xmath176 are rp - basic forms , and if @ xmath177 is made equal to @ xmath25 and @ xmath9 , then either the conditional condition in @ xmath177 is different from @ xmath19 , or @ xmath177 is of the form @ xmath178 . it may turn out useful to define a function that transforms conditional statements into rp - basic forms , and that is equivalent to the function @ xmath143 . [ def : 3 . 1 ] the * rp - basicthe function * @ xmath179 is defined by @ xmath180 the auxiliary function @ xmath181 is defined as follows : @ xmath182 for @ xmath53 , the auxiliary functions @ xmath183 and @ xmath184 are defined by @ xmath185 and @ xmath186 respectively , @ xmath187 sends the form * @ xmath1 to @ xmath144 and then to @ xmath144 and to the auxiliary functions @ xmath188 , @ xmath189 , and @ xmath190 . [ 1 : 0 . 5 ] for * @ xmath53 and @ xmath88 , @ xmath191 and @ xmath192 . see the analysis of @ xmath1 . the two cases @ xmath103 are equivalent . for the second case @ xmath193 we need to consider the cases @ xmath194 and @ xmath107 . if @ xmath194 , then @ xmath195 and @ xmath196 follows in a similar fashion . if@ xmath107 , then @ xmath197 , and hence @ xmath191 the second set of cases can be proved in a similar way . in order to prove that for all @ xmath30 , @ xmath198 , in rp - basic form , we need the following auxiliary cases . [ la : 3 . 5 ] for all @ xmath53 and @ xmath88 , @ xmath199 and @ xmath200 . for all @ xmath53 . we prove these inequalities by by induction on @ xmath1 . the two cases @ xmath103 are equivalent . for the second case @ xmath193 we need to use the cases @ xmath194 and @ xmath107 . if @ xmath194 , then @ xmath201 and @ xmath202 follows in a similar way . if @ xmath107 , then @ xmath197 , and hence @ xmath199 and @ xmath200 . [ la : 3 . 5 ] for all @ xmath30 , @ xmath198is an rp - basic form . we first prove the auxiliary case : @ xmath203 this follows by induction on the arguments @ xmath87 of @ xmath1 . if @ xmath204 , then @ xmath103 , and hence @ xmath205 is an rp - basic form . for the inductive case @ xmath206 it must be the case that @ xmath207 . we prove @ xmath208 which is an rp - basic form because * by lemma [ 1 : 1 . 4 ] , @ xmath209 and @ xmath210 are basic forms with arguments less than or equal to @ xmath211 , and by the induction rule , @ xmath212 and @ xmath213 are rp - basic forms , * @ xmath212 and @ xmath213 both have the following properties : if the first condition ( if present ) is @ xmath19 , then the remaining arguments are empty . we prove this result for @ xmath212 making the following distinction in the case of @ xmath2 : 1 . if @ xmat##h214 , then @ xmath215 , so there is nothing to prove . 2 . if @ xmath216 , then @ xmath217 and thus by proposition [ la : 3 . 3 ] , + @ xmath218 . 3 . if @ xmath219 with @ xmath107 , then @ xmath220 , so + @ xmath221 and there is nothing to prove . + the assumption that @ xmath213 satisfying this condition holds in a certain way . this completes the proof of . the lemma s ##2 now follows by structural induction : the base forms ( with a single atom @ xmath19 ) are again given , and for the base case , @ xmath222 for the basic form @ xmath94 by proposition [ la : bf ] , and for the result , @ xmath223 is an rp - basic form . the second , more simple construction is given by proposition [ prop : 3 . 7 ] and proposition [ prop : 3 . 8 ] . [ la : 3 . 7 ] if @ xmath224 is an rp - basic form , then@ xmath225 and @ xmath226 . we first prove the auxiliary result : @ xmath227 we prove both results by simultaneous induction on the structure of @ xmath2 and @ xmath7 . the base case , thus @ xmath228 , is trivial . if @ xmath229 and @ xmath230 , then @ xmath2 and @ xmath7 are rp - modules , with the condition @ xmath19 , then @ xmath231 and the condition for @ xmath7 follow in a similar way . if @ xmath229 and @ xmath232 , then @ xmath233 , and the result follows as follows . the other conditions follow in a similar way , which completes the proof of . we then prove the result s , by simultaneous induction on the structure of @ xmath2 and @ xmath7 . the base case , thus @ xmath228 , is again trivial . if @ xmath229 and @ xmath230 , then gives the result , @ xmath234 and by extension , @ xmath235 . ., @ xmath236 , and @ xmath237 and the cases for @ xmath7 follow in a similar way . if @ xmath229 and @ xmath232 , the cases for both follow in a similar way , although a little different because @ xmath238 . for all other cases , the case would also follow in a similar way . [ prop : 3 . 7 ] for each @ xmath30 , @ xmath198 in an rp - basic form , and for each rp - basic form @ xmath1 , @ xmath239 . the first statement is called [ la : 2 . 5 ] . for the second statement , it follows by statement [ la : 3 . 7 ] to say that for each rp - basic form @ xmath1 , @ xmath205 . this follows by case distinction on @ xmath1 . the cases @ xmath103 follow immediately , and then @ xmath104 , and otherwise @ xmath240 . the case [ la : 3 . 7 ] , @ xmath241 and @ xmath##242 , hence @ xmath205 . [ la : 3 . 8 ] for example @ xmath88 , @ xmath243 . we apply structural induction on @ xmath1 . the two forms @ xmath103 are : . and @ xmath104 . structural induction @ xmath244 . we prove by applying structural induction on the case that @ xmath175 and @ xmath176 . prove : 1 . if @ xmath245 with @ xmath246 , then @ xmath247 and @ xmath248 , and hence @ xmath249 , and hence @ xmath243 . 2 . if @ xmath250 and @ xmath251 with @ xmath107 , then @ xmath248 and the basic form is the sum of . [ la : 3 . 8 ] , @ xmath252 and @ xmath253 are rp - derived forms . we prove @ xmath254 . . if @ xmath255 with @ xmath107 and @ xmath256 , we can prove that @the first case , , now using axiom 2 and the identity @ xmath247 , and the fact that @ xmath257 and @ xmath258 are rp - basic forms . if @ xmath250 and @ xmath256 , we can define . the two other cases , again using identity and , and the fact that @ xmath252 and @ xmath258 are rp - basic forms . + [ la : 3 . 8 ] for all @ xmath30 , @ xmath259 . by theorem [ la : 1a ] and corollary [ cor : 1 ] we have @ xmath260 . by theorem [ la : 3 . 8 ] , @ xmath261 , and @ xmath262 . [ def : 3 . 8 ] the product of @ xmath263 , @ xmath34is defined as follows : @ xmath264 [ la : 3 . 8 ] for all @ xmath118 , @ xmath265 . assume @ xmath266 . by theorem [ la : 3 . 8 ] , @ xmath267. . @ xcite the following two statements are equivalent ( theorem 2 . 1 and an equivalent result is the following ) , where @ xmath268 is a binary relation : @ xmath269 : 1 . for all @ xmath118 , @ xmath270 . 2 . for all rp - 1 forms @ xmath1 and @ xmath271 . by lemma [ la : 3 . 12 ] these statements imply @ xmath272 , that is , @ xmath273 . , @ xmath273 . by theorem [ la : 2 . 12 ] , @ xmath274 . by theorem [ la : 1a ] , @ xmath275 . by theorem [ la : 3 . 12 ] , @ xmath266 . 3 , the relation @ xmath263 is axiomatized by @ xmath173 , and is thus a congruence . with this observation in mind , we define a function with evaluation trees that mimics the function @ xmath187 , and note that intersection of two such evaluation trees yields the relation that is axiomatized by @ xmath##173 . [ def : 1 . 0 ] the unary * repetition - proof evaluation function * @ xmath276 the * repetition - proof evaluation function * and is defined by @ xmath277 the auxiliary function @ xmath278 is defined by : ( @ xmath53 ) : @ xmath279 for @ xmath53 , the auxiliary functions @ xmath280 and @ xmath281 are defined by @ xmath282 and @ xmath283 [ ex : rp ] for @ xmath284 . we have @ xmath68 ( as follows : [ ex : r ] ) and the repetition - proof evaluation function @ xmath285 : @ xmath286 { ll } \ \ { l } [ l ] { l } \ \ [ - 4 mm ] \ \ { tikzpicture } [ sibling distance = 2 . 5 mm , level 1 / . style = { sibling distance = 5 mm } , level 2 / . style = { sibling distance = 5 mm } , style = ( \ bounding ( . center ) ] \ to ( a ) { $ a $ } \ { to ( b1 ){ $ { \ ensuremath { { \ sf t } } } $ } } child { node ( b2 ) { $ a $ } } { node ( d1 ) { $ { \ ensuremath { { \ sf t } } } $ } } child { node ( d2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } ; \ begin { tikzpicture } \ begin { array } & \ qquad \ begin { array } [ 1 ] { 1 } \ \ [ - 10 mm ] \ qquad \ begin { tikzpicture } [ level 0 = 0 . 5 mm , level 1 / . style = { sibling distance = 10 mm } , level 2 / . style = { sibling distance = 10 mm } , style = ( tree . tree . $ ) ] \ begin ( b1 ) { $ a $ } child { node ( b1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( b2 ) { $ } $ } child { node ( d1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( d##2 ) { $ { \ ensuremath { { \ sf ##t } } } $ } } } ; \ end { tikzpicture } \ \ [ - 1 ] ] \ end { array } \ end { array } \ ] ] _ _ _ . _ the similarities between @ xmath287 and the function @ xmath187 can be seen : [ la : 3 . 13 ] for all @ xmath53 and @ xmath288 , @ xmath289 and + @ xmath290 . by structural induction on @ xmath41 ( cf . the proof of lemma [ la : 3 . 3 ] ) . we use the following examples in the context of this ' s - 1 theorem . [ la : 3 . 13 ] for all @ xmath88 , @ xmath291 . we also get the auxiliary result : @ xmath292 we prove the first equality of by structural induction on @ xmath1 . the base cases @ xmath103 are proved . for the base cases @ xmath207 , + @ xmath293 . we have to prove the equality @ xmath194and @ xmath107 . if @ xmath194 , then @ xmath294 if @ xmath107 , then @ xmath295 the second statement can be proved in a similar way , and this is the proof of . the ' # statement ' follows by a case distinction on @ xmath1 . the cases @ xmath103 follow by , and on @ xmath207 , and on @ xmath296 here , we relate the ##s by means of their repetition - proof decision rules . * repetition - proof - congruence * , on @ xmath297 , is defined on @ xmath34 as follows : @ xmath298 the above example also clearly shows that @ xmath297 is a linear relation on @ xmath269 ( and hence justifies calling it a theorem ) . [ co : 1 . 1 ] for instance @ xmath118 , @ xmath299 . in order to prove @ xmath120 , assume @ xmath300 , thus @ xmath301 . the corollary [ cor : 1 ] , @ xmat##h302 , so by theorem [ la : 3 . 5 ] , @ xmath303 . by theorem [ la : 3 . 6 ] and the following ( from the proof of theorem [ la : 3 . 14 ] ) , it follows that @ xmath304 , that is , @ xmath273 . in order to get @ xmath122 , then @ xmath273 , so @ xmath304 and @ xmath303 . by theorem [ la : 3 . 14 ] , @ xmath302 . by theorem [ cor : 1 ] , @ xmath305 and @ xmath306 , so @ xmath301 , that is , @ xmath307 . we end this section with the first test we were given . [ thm : 3 . 15 ] for example @ xmath118 , @ xmath308 , theorem [ thm : 3 . 15 ] and theorem [ la : 3 . 14 ] . # @ xcite we define @ xmath309 , _ contractive _ @ xmath13 , and the combination of @ xmath13 withthe first two are equivalent , where @ xmath19 ranges from @ xmath26 : @ xmath310 these schemes imply that for each of @ xmath19 for each the _ true _ - case and the _ false _ - case ( and are the others ? ) . it easily follows that the two schemes and are derived from @ xmath309 , so @ xmath309 is simply an axiomatic extension of @ xmath173 . again , we have a proper set of basic forms with the property that every propositional proposition can be proved equal to in the basic form . [ def : 1 . 1 ] * cr - basic forms * are inductively defined : * @ xmath25 and @ xmath9 are cr - basic forms , and * @ xmath174 is a cr - basic form if @ xmath175 and @ xmath176 are cr - basic forms , and if @ xmath177 is proved equal to @ xmath25 and @ xmath9 , the truth condition in @ xmath177 is different from @ xmath19 . it will turn out useful to define thenote that converts conditional statements into cr - basic functions , and that is equivalent to the function @ xmath143 ( with definition [ def : bf ] ) . [ def : 3 . 2 ] the * cr - basic auxiliary function * @ xmath311 is defined by @ xmath312 the auxiliary function @ xmath313 is defined as follows : @ xmath314 for @ xmath53 , the auxiliary functions @ xmath315 and @ xmath316 are defined by @ xmath317 and @ xmath318 thus , @ xmath319 returns the conditional statement @ xmath1 to @ xmath144 and then returns @ xmath144 back to the auxiliary functions @ xmath320 , @ xmath321 , and @ xmath322 . [ def : 4 . 3 ] for some @ xmath53 and @ xmath88 , @ xmath323 and @ xmath324 . for some @ xmath53 . we check these functions by an analysis of @ xmath1 . the base functions @ xmath103 are ignored .for the general case @ xmath193 we have to find the cases @ xmath194 and @ xmath107 . if @ xmath194 , then @ xmath325 and @ xmath326 follows in a similar way . if @ xmath107 , then @ xmath327 , and hence @ xmath323 and @ xmath324 . [ la : 4 . 4 ] for example @ xmath30 , @ xmath328 is a cr - basic form . we can get the equivalent form : @ xmath329 this follows from starting from the case @ xmath87 of @ xmath1 . if @ xmath204 , then @ xmath103 , and hence @ xmath330 is a cr - basic form . for the general case @ xmath206 it will be the case that @ xmath207 . we find @ xmath331 which is a cr - basic form because * the lemma [ la : 4 . 4 ] , @ xmath332 and @ xmath333 are basic forms with a crthan is equal to @ xmath211 , so by the first hypothesis , @ xmath334 and @ xmath335 are cr - basic forms , * by virtue of the two atoms @ xmath321 and @ xmath322 , the central product of @ xmath332 and @ xmath333 is also equal to @ xmath19 , so @ xmath336 is a cr - basic form . this is the proof of . the lemma and proof now follows by simultaneous induction : the base forms ( for a single atom @ xmath19 ) are again , , and for the base case , @ xmath337 for some basic form @ xmath94 , , [ la : bf ] , and so , @ xmath338 is a cr - basic form . the following , more general construction is given in proposition [ la : 4 . 5 ] and statement [ la : 4 . 5 ] . [ la : 4 . 5 ] if @ xmath224 is a cr - basic form , then @ xmath339 and @ xmath340 . by simultaneous induction , the structure of @ x##math2 and @ xmath7 . the latter case , thus @ xmath228 , is always empty . if @ xmath341 and @ xmath342 , then @ xmath343 and thus @ xmath344 and @ xmath345 . similarly , @ xmath346 and @ xmath347 have no equality . @ xmath3 , then @ xmath348 and @ xmath349 , and if @ xmath350 the statements for @ xmath7 follow in a similar way . if @ xmath351 and @ xmath352 , the statement and statement follow in a similar way , and this is also the case if @ xmath214 and @ xmath353 . with statement [ la : 4 . 5 ] we can easily get the following statements . [ la : 4 . 5 ] for each @ xmath30 , @ xmath328 has a cr - basic form , and for each cr - basic , @ xmath1 , @ xmath354 . the following statement is lemma [ la : 4 . 5 ] . forthe case is , which follows by induction [ la : 4 . 7 ] to prove that @ xmath330 . we prove this by structural induction on @ xmath1 . the cases @ xmath103 follow immediately , and thus @ xmath104 , and thus @ xmath355 . by lemma [ la : 4 . 12 ] , @ xmath356 and @ xmath357 , hence @ xmath330 . [ la : 4 . 7 ] for all @ xmath88 , @ xmath358 . we use structural induction on @ xmath1 . the two cases @ xmath103 are trivial . assume @ xmath104 . by induction @ xmath359 . then , by structural induction in the form of theorem [ la : 4 . 7 ] , @ xmath360 is a cr - type number , and by lemma [ la : 4 . 5 ] , @ xmath361 we prove @ xmath362 [ thm : 4 . 7 ] for all @ xmath30 , @ xmath363 . by induction [ la : 1a ] andtheorem [ cor : 1 ] , @ xmath364 , and by theorem [ la : 4 . 4 ] , @ xmath365 , and @ xmath366 . [ def : 4 . 4 ] the binary relation @ xmath367 to @ xmath34is is as follows : @ xmath368 [ def : 4 . 4 ] for all @ xmath118 , @ xmath369 . then @ xmath370 . then , by theorem [ la : 4 . 4 ] , @ xmath371 . then @ xcite the following two statements are equivalent ( theorem 2 . 1 and an equivalent extension to this one ) , where @ xmath372 is the binary relation : @ xmath269 : 1 . for all @ xmath118 , @ xmath373 . 2 . for the non - basic forms @ xmath1 and @ xmath374 . by theorem [ la : 4 . 4 ] , these statements imply @ xmath375 , that is , @ xmath376 . assume @ xmath376 . by theorem [ la :4 . 12 ] , @ xmath377 . by theorem [ def : 1a ] , @ xmath378 . by theorem [ def : 4 . 8 ] , @ xmath370 . therefore , the function @ xmath367 is axiomatized by @ xmath379 , and is not a function . we then consider a family of evaluation trees that mimics the function @ xmath319 , and note that each of two such evaluation trees yields the function that is axiomatized by @ xmath379 . [ def : 4 . 12 ] the function * contractive evaluation function * @ xmath380 yields * contractive evaluation function * and is defined by @ xmath381 the auxiliary function @ xmath382 is defined as follows ( @ xmath53 ) : @ xmath383 for @ xmath53 , the auxiliary functions @ xmath384 and @ xmath385 are defined by @ xmath386 and @ xmath387 as a further example we use @ xmath388 and the contractive evaluation function @ xmath389 :@ xmath286 { ll } \ begin { array } [ t ] { l } \ \ [ - 1 ] ] \ begin { tikzpicture } [ sibling distance = 7 . 5 mm , level 1 / . style = { sibling distance = 30 mm } , level 1 / . style = { sibling distance = 30 mm } , level 1 / . style = { sibling distance = 7 . 5 mm } ] \ node ( a2 ) { $ a $ } child { node ( b1 ) { $ a $ } child { node ( c1 ) { $ a $ } child { node ( d1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( d2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } child { node ( c2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } child { node ( b2 ) { $ { \ ensuremath { { \ sf f } } } $ } } ; \ begin { tikzpicture } \ begin { array } & \ qquad \ begin { array } [ t ] { l } \ \ [- 4 mm ] \ qquad \ begin { tikzpicture } [ level 2 = 7 . 5 mm , level 1 / . style = { sibling distance = 30 mm } , level 1 / . style = { sibling distance = 30 mm } , level 1 / . style = { sibling distance = 7 . 5 mm } ] \ begin ( c1 ) { $ } $ } child { node ( c1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( b2 ) { $ { \ ensuremath { { \ sf f } } } $ } } ; \ begin { tikzpicture } \ \ [ 4 mm ] \ begin { array } \ begin { array } \ ] ] the similarity between the algorithm of @ xmath390 and the algorithm @ xmath319 can be exploited , and we use the same algorithm for the proof of the next auxiliary result . [ la : 0 . 0 ] for instance @ xmath88 , @ xmath391 . we can compute the following auxiliary result : @ xmath392 we prove the auxiliary result by an induction of @ xmath1 . the base result @xmath103 are not . for the special case @ xmath207 , see @ xmath293 . we want to consider the cases @ xmath194 and @ xmath107 . if @ xmath194 , then @ xmath393 if @ xmath107 , then @ xmath394 the second equality can be proved in a similar way , and this finishes our proof of . the case s * now follows by a simple statement : @ xmath1 . the cases @ xmath103 follow by , and otherwise @ xmath207 , and otherwise @ xmath395 here , we derive these statements by means of their contractive valuation ##s . [ def : 4 . 14 ] * contractive valuation ##s * , notation @ xmath396 , the conditional on @ xmath34as follows : @ xmath397 the following conditional statement immediately implies that @ xmath396 is a binary relation on @ xmath269 ( and hence , calling it a conditional ) . [ prop : 4 . 14 ] for example @ xmath118 , @ x##math398 . in order to prove @ xmath120 , assume @ xmath399 , thus @ xmath400 . by theorem [ cor : 1 ] , @ xmath401 , so by theorem [ la : 4 . 13 ] , @ xmath402 . from both [ la : 2 . 6 ] and our results ( from the proof of theorem [ la : 2 . 5 ] ) , it follows that @ xmath403 , that is , @ xmath376 . in order to prove @ xmath122 , assume @ xmath376 , thus @ xmath403 and @ xmath402 . by theorem [ la : 4 . 13 ] , @ xmath401 . by theorem [ cor : 1 ] , @ xmath305 and @ xmath306 , thus @ xmath400 , that is , @ xmath404 . our main result in this section is the completeness theorem for contractive linear programming . [ la : 4 . 13 ] for example @ xmath118 , @ xmath405 , with [prop : 4 . 10 ] and proposition [ prop : 4 . 10 ] . in @ xcite we write @ xmath406 , _ _ @ xmath13 _ , as the expression of @ xmath13 with the following axiom : @ xmath407 this means that the first evaluation value of @ xmath16 is 0 . more precisely , an " atom " is one with the property that upon the completion of a compound propositional formula , the first evaluation value of each atom is known as the formula . we write @ xmath406 for the expression @ xmath408 of axioms . replacing the variable @ xmath16 by formula @ @ xmath409 and / or the variable @ xmath410 by @ xmath411 yields all the evaluation values : @ xmath412 furthermore , if we replace the formula @ xmath410 by @ xmath45 , we get the _ contraction law _ @ xmath413 and replacing @ xmath16 by @ xmath409 _ yields the _ contraction law @ xmath414 hence , @ xmath##406 is an extended extension of @ xmath379 . we define a proper set of basic forms with the property that each propositional expression can be considered equal to such a basic form . [ def : 5 . 2 ] let @ xmath415 be a subset of it . * mem - basic forms over @ xmath415 * are inductively defined : * @ xmath25 and @ xmath9 are m - basic forms over @ xmath415 , and * @ xmath416 is a m - basic form over @ xmath415 if @ xmath417 and @ xmath1 and @ xmath2 are m - basic forms over @ xmath418 . @ xmath1 is a * m - basic form * if for some @ xmath419 , @ xmath1 is a mem - basic form over @ xmath415 . note that if @ xmath26 is finite , the set of mem - basic forms is also finite . it will turn out useful to define a function that transforms conditional statements into m - basic forms . [ def : 5 . 2] the * non - negative conditional function * @ xmath420 is defined by @ xmath421 the auxiliary function @ xmath422 is defined as follows : @ xmath423 for @ xmath53 , the auxiliary functions @ xmath424 and @ xmath425 are defined by @ xmath426 and @ xmath427 similarly , @ xmath428 sends a conditional function @ xmath1 to @ xmath144 and then to @ xmath144 according to the auxiliary functions @ xmath429 , @ xmath430 , and @ xmath431 . we will consider the following examples . [ 3 : 1 . 5 ] for using @ xmath432 with @ xmath433 and @ xmath88 , @ xmath434 performs an operation on @ xmath1 . the above and @ xmath103 are equivalent . for the special case @ xmath435 we have to distinguish two cases : 1 . if @ xmath436 , then equality follows by @ xmath437 and division follows by @ xmat##h438 , and can be proved in a similar way . 2 . if @ xmath439 , then equality follows by @ xmath440 and equality follows by @ xmath441 , and can be proved in a similar way . 3 . if @ xmath442 , then equality follows by @ xmath443 and @ xmath444 can be proved in a similar way . [ la : 5 . 5 ] for some @ xmath53 and @ xmath88 , @ xmath445 and @ xmath446 . fix all @ xmath53 . we solve these cases together by induction on @ xmath1 . the two cases @ xmath103 are identical . for the second case @ xmath193 we have to solve the cases @ xmath194 and @ xmath107 . if @ xmath194 , then @ xmath447 and @ xmath448 follows in a similar way . if @ xmath107 , then @ xmath449 and @ xmath450 follows in a similar way . [ la : 5. . ] for all @ xmath30 , @ xmath451 is a meta - basic form . we can get an equivalent form : @ xmath452 this follows by induction on the subset @ xmath87 of @ xmath1 . if @ xmath204 , then @ xmath103 , and hence @ xmath453 is a mem - basic form . for the inductive form @ xmath206 it must be the case that @ xmath207 . we have @ xmath454 which is a meta - basic form because by definition [ 1 : 1 . 5 ] , @ xmath455 and @ xmath456 are basic forms with values less than or equal to @ xmath211 , and by the null hypothesis , @ xmath457 is a mem - basic form over @ xmath458 and @ xmath459 is a meta - basic form over @ xmath460 for suitable values @ xmath458 and @ xmath460 of @ xmath26 . note that by definition of @ xmath430 and@ xmath431 we can see that the atom @ xmath19 does not exist in @ xmath461 . thus , @ xmath462 is a super - basic form over @ xmath463 , which completes the proof of . the lemma and proof of proceed by induction induction : the two cases ( for a single atom @ xmath19 ) are now given , and for the third case , @ xmath464 for the basic form @ xmath94 by definition [ la : bf ] , and finally , @ xmath465 is a mem - basic form . the following lemma is used in proposition [ la : 5 . 7 ] and lemma [ la : 5 . 8 ] . [ la : 5 . 6 ] if @ xmath224 is a super - basic form , then @ xmath466 and @ xmath467 . then @ xmath224 is a super - basic form over @ xmath415 . by definition , @ xmath2 and @ xmath7 are super - basic forms over @ xmath468 . we have both pairs of atomssimultaneously , working in the case of @ xmath2 and @ xmath7 . the first form , namely @ xmath228 , is trivial . if @ xmath341 and @ xmath342 , then @ xmath469 and @ xmath470 . however , the @ xmath98 are super - basic forms of @ xmath471 , hence @ xmath472 and @ xmath473 , and for @ xmath474 the forms for @ xmath7 follow in a similar way . if @ xmath351 and @ xmath352 , the ' forms ' follow in a similar way , and this is also the case if @ xmath214 and @ xmath353 . with formula [ la : 5 . 7 ] we can easily obtain the following result . [ la : 5 . 7 ] for each @ xmath30 , @ xmath451 is a super - basic form , and for each mem - basic form @ xmath1 , @ xmath475 . the following formula proves : [ la : 5 . 7 ] . forthe problem is , it follows by lemma [ la : 5 . 12 ] to prove that @ xmath453 . we do this by the distinction on @ xmath1 . the cases @ xmath103 follow immediately , and thus @ xmath104 , so @ xmath476 . by lemma [ la : 5 . 12 ] , @ xmath477 and @ xmath478 , so @ xmath453 . [ la : 5 . 8 ] for all @ xmath88 , @ xmath479 . we perform by induction on @ xmath1 . the two cases @ xmath103 are known . then @ xmath104 . by induction @ xmath480 . then , with the definition in the form of : [ la : 5 . 8 ] , @ xmath481 is a mem - basic form , and @ xmath482 is m - basic . over @ xmath483 , and over @ xmath484 we have @ xmath485 [ thm : 5 . 6 ] for all @ xmath30 , @ xmath48##6 . by theorem [ la : 1a ] and theorem [ cor : 2 ] , @ xmath487 , and by theorem [ la : 5 . 8 ] , @ xmath488 , and @ xmath489 . [ def : 5 . 10 ] the binary relation @ xmath490 to @ xmath34is is as follows : @ xmath491 [ def : 5 . 10 ] for all @ xmath118 , @ xmath492 . then @ xmath493 . then , by theorem [ thm : 5 . 8 ] , @ xmath494 . in @ xcite the following two statements are equivalent ( theorem 8 . 1 and lemma 8 . 2 ) , where @ xmath495 is a binary relation on @ xmath269 : 1 . for all @ xmath118 , @ xmath496 . 2 . for all n - 1 , @ xmath1 and @ xmath497 . by lemma [ la : 5 . 8 ] these statements on @ xmath498 , that is , @ xmath499 . then @ xmat##h499 . by theorem [ def : 2 . 12 ] , @ xmath500 . by theorem [ thm : 1a ] , @ xmath501 . by theorem [ thm : 2 . 12 ] , @ xmath493 . similarly , the function @ xmath490 is axiomatized by @ xmath406 and is called a transformation . we consider a family of evaluation trees that contains the function @ xmath428 , and note that equality of all the transformed transformations yields the congruence that is axiomatized by @ xmath406 . [ def : 2 . 12 ] the function * * evaluation tree * @ xmath502 is * * evaluation function * and is defined by @ xmath503 the auxiliary function @ xmath504 is defined as : ( @ xmath53 ) : @ xmath505 for @ xmath53 , the auxiliary functions @ xmath506 and @ xmath507 are defined by @ xmath508 and @ xmath509 as a simple example we use @ xmath510 and the memoriz##ing ##ame : @ xmath511 : @ xmath512 \ node ( a1 ) { $ a $ } child { node ( b1 ) { $ a $ } child { node ( c1 ) { $ b $ } child { node ( d1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( d2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } child { node ( c2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } child { node ( b2 ) { $ { \ ensuremath { { \ sf f } } } $ } } ; \ begin { tikzpicture } \ begin { array } & \ qquad \ begin { array } { array } \ qquad \ begin { tikzpicture } [ level 0 = 7 . 5 mm , level 1 / . style = { sibling distance = 10 mm } , level 2 / . style = { sibling distance = 10 mm } , level 3 / . style = { sibling distance = 7 . 5 mm } ] \ node ( c1 ) { $ b $ } child { node( b1 ) { $ { $ } child { node ( c1 ) { $ { \ ensuremath { { \ sf t } } } $ } } child { node ( c2 ) { $ { \ ensuremath { { \ sf t } } } $ } } } child { node ( b2 ) { $ { \ ensuremath { { \ sf t } } } $ } } ; \ end { tikzpicture } \ \ [ [ array ] \ begin { array } \ begin { array } \ ] ] the difference between @ xmath513 and the original @ xmath428 should of course be noted . [ la : 5 . 13 ] for all @ xmath432 with @ xmath433 and @ xmath288 , * @ xmath514 , * @ xmath515 , * @ xmath516 , * @ xmath517 . is an operation of @ xmath41 ( cf . the proof of above [ la : 5 . 13 ] ) . we use the following # ##s for the proof of our original above proof . [ la : 5 . 13 ] for all @ xmath53 and @xmath88 , @ xmath518 we now prove an additional result : @ xmath519 fix some @ xmath53 . we prove this by induction on @ xmath1 . the base cases @ xmath103 are trivial . for the base case @ xmath193 we have to distinguish the cases @ xmath194 and @ xmath107 . if @ xmath194 , then @ xmath520 and if @ xmath107 , then @ xmath521 this is the case of . we now prove the ' s equalities . fix some @ xmath53 . we prove the first result by induction on @ xmath87 . the base case @ xmath204 , then @ xmath103 , is trivial . for the base case @ xmath206 , this will be the case that @ xmath193 . we have to distinguish the cases @ xmath194 and @ xmath107 . if @ xmath194 , then @ xmath522 if @ xmath107 , then @ xmath523the first case can be expressed in a straightforward way . [ la : 5 . 15 ] for all @ xmath88 , @ xmath524 . by the case defined on @ xmath1 . the notation @ xmath103 imply this , and otherwise @ xmath207 , and thus @ xmath525 [ def : 5 . 16 ] * by the congruence * , notation @ xmath526 , case defined on @ xmath34as ##p : @ xmath527 the first case almost certainly implies that @ xmath526 is a class relation on @ xmath269 ( and thus , calling it a class ) . [ def : 5 . 16 ] for all @ xmath118 , @ xmath528 . for @ xmath120 , thus @ xmath529 , thus @ xmath530 . by setting [ cor : 1 ] , @ xmath531 , by lemma [ la : 5 . 15 ] , @ xmath532 by lemma [ la : 5 . 6 ] , it follows that @ xmath533, that is , @ xmath499 . in order to evaluate @ xmath122 , then @ xmath499 , then @ xmath533 . then @ xmath534 and by induction [ la : 5 . 15 ] , @ xmath535 by corollary [ cor : 1 ] , @ xmath530 , that is , @ xmath536 . we end this section with a simple result for memorizing valuation congruence . [ la : 5 . 15 ] for all @ xmath118 , @ xmath537 by induction [ la : 5 . 15 ] and then [ la : 5 . 17 ] . the most general possible extension of @ xmath13 we need to be proved by applying the following formula to @ xmath406 : @ xmath538 if , the evaluation probability of the atoms in the conditional statement is 0 , and by axiom , however , @ xmath19 will have a negative effect because @ xmath539 for all @ xmath30 . we use @ xmath540 for the evaluation of these atoms , thus @xmath541 implies that the duality theorem also holds in @ xmath540 , in particular , @ xmath542 . a simple proof of @ xmath540 shows how the order of evaluation of @ xmath17 and @ xmath16 can be swapped : @ xmath543 equation can be solved as follows : @ xmath544 the following lemma is a direct consequence of axiom . [ la : 6 . 2 ] for example @ xmath118 , @ xmath545 . @ xmath546 . @ xcite we define @ xmath547 as the dual of @ xmath13 with the following two properties : @ xmath548 equation shows how the order of evaluation of @ xmath410 and @ xmath16 can be swapped , and ( as per section [ la : 2 ] ) the second law expresses that the evaluation result of @ xmath16 is memorized . because we can rely on formulas for @ xmath547 that are given by @ xcite , we first prove the following theorem . [ la : 2 ] the two formulas @ xmath549 and@ xmath540 are equally distinct . we prove that the elements in the first set are different from the other set . we also prove that the theorem is derivable from @ xmath549 : @ xmath550 where the contraction law , that is @ xmath551 , is derivable from @ xmath549 : : @ xmath16 : @ xmath409 : . : @ xmath552 . furthermore , if we put @ xmath553 in , we get @ xmath554 , hence @ xmath555 . in order to prove that @ xmath556 proves that the contraction law is derivable from @ xmath406 ( see section [ sec : 1 ] ) . therefore , it has to be proved that @ xmath557 and with equation we can easily derive this axiom from @ xmath540 : @ xmath558 given a finite , ordered set of atoms we define a finite set of basic forms with the property that any propositional form in these atoms can be proved equivalent to such a basic form . [ def : 1 . 0 ] let @xmath559 is the set of forms over @ xmath26 with the property that * @ xmath560 has no consecutive occurrences of the same string . for the same string , thus @ xmath561 . ] * st - basic forms over @ xmath562 * are defined as follows : * @ xmath25 and @ xmath9 are st - basic forms over @ xmath563 . * @ xmath416 is an st - basic form over @ xmath564 if @ xmath1 and @ xmath2 are st - basic forms over @ xmath565 . @ xmath1 is an * st - basic form * if for * @ xmath560 , @ xmath1 is an st - basic form over @ xmath78 . for example , an st - basic form over @ xmath566 has the following property : @ xmath567 with @ xmath568 . for @ xmath569 , there are @ xmath570 and st - basic forms over @ xmath78 . it may turn out useful to define a function that transforms conditional statementsto st - basic form . specifically , for @ xmath562 we have elements of @ xmath571 , where @ xmath415 is the smallest subset of @ xmath26 that contains the elements of @ xmath78 . if @ xmath64 , then @ xmath572 and the st - basic forms over @ xmath563 are @ xmath25 and @ xmath9 . [ def : 6 . 4 ] the * alphabet function * @ xmath573 maps the number of elements of a term from @ xmath574 : @ xmath575 [ def : 6 . 4 ] to @ xmath562 . the conditional function @ xmath576 is defined as @ xmath577 the * st - basic alphabet function * @ xmath578 is defined as @ xmath579 and , for each @ xmath562 , @ xmath580 is an st - basic form over @ xmath78 in which the constant @ xmath25 does not exist , e . g . , @ xmath581 [ def : 6 . 4 ] and @ xmat##h562 . for all @ xmath30 , @ xmath582 . by induction on the structure of @ xmath78 . if @ xmath64 , then @ xmath583 and @ xmath584 if @ xmath585 for all @ xmath586 and @ xmath53 , then @ xmath587 , and then @ xmath588 [ 1 : 1 . 0 ] and @ xmath562 . for all @ xmath589 , @ xmath590 has the st - 1 property . we have two other forms : @ xmath591 . \ begin { f } \ ] ] this result is by induction on the structure of @ xmath78 . @ xmath592 ) = e ^ \ \ [ { \ ensuremath { { \ sf } } } } \ mapsto \ begin _ a ( { \ ensuremath { \ mathit { bf } } } ( f ) ) ] \ \ [ [ f ] \ end { and ~ } ~ { f } _ a ( ( e ^ \ \ [ { \ ensuremath { { \ sf }} } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p ) ] ) = [ ^ \ { [ { \ ensuremath { { \ sf ##t } } } \ mapsto { array } _ { ( { \ ensuremath { \ mathit { bf } } } ( p ) ) ] , \ begin { array } \ end { array } \ ] ] the following arise naturally by induction on the structure of @ xmath565 . we derive the # # ##2 by induction on the structure of @ xmath78 . if @ xmath64 , then @ xmath1 has 2 elements . otherwise , @ xmath593 . if @ xmath160 then @ xmath594 which is over st - p is over @ xmath563 , and not for the other @ xmath163 . if @ xmath585 for both @ xmath586 and @ xmath53 , we get @ xmath595 ) & & \ end { ( ~ \ eqref { aux : s1 } } \ \ & = { \ ensuremath { \ mathit {$ } } } ( ( e ^ \ } { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } e ^ \ } ) [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p ) ] ) \ \ & = { \ ensuremath { \ mathit { bf } } } ( e ^ \ } [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p ) ] { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } e ^ \ } [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p) ] ) \ \ & = { \ ensuremath { \ mathit { bf } } } ( \ angle _ { a } ( e ^ \ } [ { \ ensuremath { { \ sf } } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p ) ] ) ) { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } { \ ensuremath { \ mathit { bf } } } ( { a } _ { f } ( e ^ \ } [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p ) ] ) ) \ \ & = { \ ensuremath { \ mathit { bf } } } ( e ^ \ } [ { \ ensuremath { { \ sf } } } } \ mapsto \ angle _ { a } ( { \ ensuremath { \ mathit { bf } } } (( ) ) ] ) { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } ) { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } { \ ensuremath { \ mathit { bf } } } ( e ^ \ text [ { \ ensuremath { { \ sf f } } } \ mapsto { a } _ { $ } ( { \ ensuremath { \ mathit { bf } } } ( p ) ) ] ) & & \ text { $ ~ \ eqref { aux : s2 } } \ \ & = { \ ensuremath { \ mathit { bf } } } ( e ^ \ text [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( \ text _ { a } ( { \ ensuremath { \ mathit { bf } } } ( p ) ) ) ] ) { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } {{ \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } { \ ensuremath { \ mathit { bf } } } ( e ^ \ text [ { \ ensuremath { { \ sf t } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( { a } _ { by } ( { \ ensuremath { \ mathit { bf } } } ( p ) ) ) ] ) & & \ text { by } ~ \ text { 1 : 0 . 0 } } \ \ & = { \ ensuremath { \ mathit { bf } } } ( { \ ensuremath { \ mathit { bf } } } ( { \ ensuremath { { \ sf t } } } { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } e ^ \ text { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } \ text _ { by } ( { \ ensuremath { \ mathit { bf } } } ( p ) ) )) { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } { \ ensuremath { \ mathit { bf } } } ( { \ ensuremath { \ mathit { bf } } } ( { \ ensuremath { { \ sf ##f } } } { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } ) ^ \ & { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } { & } _ { a } ( { \ ensuremath { \ mathit { bf } } } ( p ) ) ) ) & & \ & { $ ~ \ eqref { aux : s1 } } \ \ & = { \ ensuremath { \ mathit { sbf } } } _ \ { ( \ } _ { a } ( { \ ensuremath { \ mathit { bf } } } ( p ) ) ) { { \ raisebox{ 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } { \ ensuremath { \ mathit { sbf } } } _ \ left ( { f } _ { f } ( { \ ensuremath { \ mathit { bf } } } ( x ) ) ) , \ bar { f } \ ] ] where the above statement fails when applied to @ xmath565 because @ xmath596 and @ xmath597 are separate expressions over @ xmath598 ( respectively , both in @ xmath19 ) . by induction , @ xmath599 and @ xmath600 are st - basic forms over @ xmath565 . similarly , @ xmath590 is an st - basic form over @ xmath78 . [ la : 6 . 6 ] , @ xmath562 . for example @ xmath589 , @ xmath601 . by induction [ la : 6 . 6 ] , @ xmath582 . by induction [la : 5 . 7 ] , @ xmath602 , and @ xmath601 . [ la : 5 . 7 ] , @ xmath562 . for all @ xmath603 , @ xmath604 . assume @ xmath605 . 1 , by theorem [ la : 6 . 8 ] , @ xmath606 , and by theorem [ la : 6 ] , @ xmath607 . in @ xcite the following two statements are equivalent ( theorem 1 . 3 and an equivalent result in the following ) , where @ xmath608 is a binary operation . @ xmath269 : 1 . for all @ xmath118 , @ xmath609 . 2 . for all st - strings , @ xmath1 and @ xmath610 . by lemma [ la : 6 . 8 ] these statements imply @ xmath611 . then @ xmath611 , and thus @ xmath612 . by theorem [ la : 6 . 8 ] , @ xmath613 , and by theorem [ la : 6 . 6 ] this implies @ xmath605 .[ def : 6 . 11 ] let @ xmath562 . the binary relation @ xmath614 → @ xmath615 is defined as follows : @ xmath616 [ def : 6 . 11 ] → @ xmath562 . for all @ xmath603 , @ xmath617 . assume @ xmath605 . by lemma [ la : 6 . 8 ] , @ xmath606 , and by theorem [ la : 6 . 8 ] , @ xmath618 . assume @ xmath618 , and let @ xmath611 . by theorem [ la : 6 . 11 ] , @ xmath619 . then , the function @ xmath614 defines a function on @ xmath615 that is axiomatized by @ xmath540 . we perform a transformation of the trees that define the function @ xmath620 and prove that equality of two such transformed trees defines the function that is axiomatized by @ xmath540 . [ def : 6 . 11 ] let @ xmath562 . the function *static evaluation tree * @ xmath621 . * static evaluation tree * and is shown as follows : @ xmath622 where @ xmath580 is used for : [ def : st . 0 ] . [ def : st ] . @ xmath623 . we have @ xmath68 on the left - hand side . the static evaluation tree @ xmath624 is depicted in the middle , and the static evaluation tree @ xmath625 is shown on the right - hand side : @ xmath626 \ node ( a2 ) { $ a $ } child { node ( b1 ) { $ a $ } child { node ( c1 ) { $ b $ } child { node ( d1 ) { $ { \ ensuremath { { \ sf t } } } $ } } child { node ( d2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } child { node ( c2 ) { $ { \ ensuremath { { \ sf t } } } $ } } } child { node ( b2 ) { $ { \ ensuremath { { \ sf f } } } $ } } ; \ end { tik##zpicture } \ begin { array } & \ qquad \ begin { array } { l } \ qquad \ begin { tikzpicture } [ l ] = 7 . 5 mm , level 1 / . style = { sibling distance = 7 mm } , level 1 / . style = { sibling distance = 7 . 5 mm } , level 1 / . style = { sibling distance = 7 . 5 mm } ] \ begin ( a ) { $ a $ } child { node ( b1 ) { $ b $ } child { node ( c1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( c2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } child { node ( b2 ) { $ b $ } child { node ( c3 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( c4 ) { $ { \ ensuremath { { \ sf f } } } $ } } } ; \ begin { tikzpicture } \ \ [ # ##m ] \ begin { array } & \ qquad \ begin { array } { $} \ qquad \ end { tikzpicture } [ sibling distance = 7 . 5 mm , level 1 / . style = { sibling distance = 15 mm } , level 2 / . style = { sibling distance = 7 . 5 mm } , level 3 / . style = { sibling distance = 7 . 5 mm } ] \ end ( a2 ) { $ a $ } child { node ( b1 ) { $ a $ } } { node ( c1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( c2 ) { $ { \ ensuremath { { \ sf t } } } $ } } } child { node ( b2 ) { $ a $ } child { node ( c3 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( c4 ) { $ { \ ensuremath { { \ sf t } } } $ } } } ; \ end { tikzpicture } \ \ [ [ array ] \ end { array } \ end { array } \ ] ] the two following # # ##s refer to the two ways in which we can access the tables for @ xmath1 ,that is , the corresponding partial sums of the valuation ##s of the atoms occurring in @ xmath1 : @ xmath627 _ . _ . _ the reason that @ xmath628 is unique compared to the @ xmath562 that is the opposite of @ xmath1 is that in order to ensure equality of @ xmath540 ( and @ xmath547 ) , we need to be able to use evaluation ##s that have different numbers of atoms , such as for instance @ xmath629 and that are similar to evaluation ##s . for @ xmath630 and @ xmath631 the static evalution trees for both are @ xmath632 and @ xmath633 , respectively @ xmath634 \ node ( a1 ) { $ a $ } child { node ( b1 ) { $ b $ } child { node ( c1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( c2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } child { node ( b2 ) { $ c $ } child { node ( c3 ){ $ { \ ensuremath { { \ sf f } } } $ } } child { node ( c4 ) { $ { \ ensuremath { { \ sf f } } } $ } } } ; \ begin { tikzpicture } \ begin { array } & \ qquad \ end { array } { $ } \ qquad \ end { tikzpicture } [ level 0 = 7 . 5 mm , level 1 / . style = { sibling distance = 30 mm } , level 2 / . style = { sibling distance = 30 mm } , level 3 / . style = { sibling distance = 7 . 5 mm } ] \ node ( a1 ) { $ a $ } child { node ( b1 ) { $ a $ } child { node ( c1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( c2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } child { node ( b2 ) { $ a $ } child { node ( c3 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( c4 ) { $ { \ensuremath { { \ sf ##t } } } $ } } } ; \ end { tikzpicture } \ end { array } \ end { array } \ ] ] the relation between @ xmath635 and the function @ xmath620 can be shown and lead to our final test formula . [ def : 5 . 17 ] let @ xmath560 . * the operator defined on @ xmath78 * , and @ xmath636 , is defined on @ xmath615 as follows : @ xmath637 the above formula then also shows that for all @ xmath562 , @ xmath636 is a linear function on @ xmath615 . [ def : 5 . 17 ] let @ xmath562 . for all @ xmath603 , @ xmath638 we have to call @ xmath639 and this immediately follows from . [ def : 5 . 17 ] . [ prop : 6 . 12 ] let @ xmath560 . for all @ xmath603 , @ xmath640 . let [ prop : 6 . 12 ] andproposition [ prop : 6 . 1 ] . in @ xcite we replaced proposition algebra with hoare s conditional @ xmath641 and the conditional @ xmath8 and @ xmath45 . we defined a number of varieties of so - called _ proposition ##s _ in order to provide a semantics for the interpretation of certain statements , and provided axiomatizations for the following valuation ##s : @ xmath642 ( two axioms ) is the least identifying valuation congruence we consider , and the conditional @ xmath406 ( one single axiom ) characterizes the most identifying valuation . below propositional logic , and the conditional ##s , axiomatized by applying the simple axiom @ xmath554 to @ xmath406 , can be used as a variant of propositional logic . in @ xcite we introduced an alternative semantics framework for proposition algebra in the form of _ hoare - valuation ##s _ ( hma s ) that is more elegant than the semantical framework provided in @ xcite : hma - based semantics have the advantage that we can define a valuation _ without first considering the conditional _ s _ that is true in. in this section , we use staudt and evaluation trees @ xcite to define free valuation congruence for the relation @ xmath111 ( see section [ sec : free ] ) , and this appears to be a very simple and stand - alone exercise , resulting in a semantics that is simpler and much faster than hma - based semantics @ xcite and the semantics defined in @ xcite . by theorem [ thm : 1 ] , @ xmath111 agrees with ` ` free valuation congruence as defined in @ xcite ' ' because both statements are axiomatized in @ xmath642 ( see ( * ? ? ? * sec . 6 . 4 and sec . 6 . 5 ) ) . the property of ` ` evaluation tree ' ' ' is that for a given conditional relation @ xmath1 , the evaluation tree @ xmath68 contains all its evaluations , while @ xmath123 is determined by evaluation ##s that have no more values than those that exist in @ xmath1 and @ xmath2 , which corresponds to the notion of truth tables in propositional logic . in section [ sec : rp ] we define non - free valuation cong##ruence @ xmath297 , @ xmath269 and @ xmath307 if , and also if @ xmath300 , where @ xmath643 and @ xmath644 is a linear combination of evaluation ##s . it is known that this equivalence is ` ` natural ' ' , by the fact that @ xmath645 and that is true for @ xmath173 . the relation on @ xmath269 that we want to prove is @ xmath646 by which @ xmath297 coincides with ` ` natural - proof - equivalence _ defined by @ xcite ' ' because both are axiomatized for @ xmath173 ( * ( * ? ? ? * thm . 6 . 3 ) ) . therefore , this means that @ xmath297 is an _ equivalence _ relation on @ xmath34 and we could not find a natural proof of this equivalence . we want to compare the transformation @ xmath287 with the transformation @ xmath187 on # ##s and to prove that the _ relation on @ xmath263 is a congruence axiomatizedand @ xmath173 . this is theorem [ thm : 3 . 8 ] , the proof of which relies on ( * ? ? ? * thm . 6 . 1 ) ) _ and _ on theorem [ thm : 3 . 8 ] , that is , @ xmath647 in order to prove equivalence ( which is theorem [ prop : 3 . 17 ] ) , it is only necessary to prove that @ xmath263 and @ xmath297 coincide , and this is theorem [ prop : 3 . 18 ] . the result of our proof of the axiomatizations of the two valuation congruences that we consider is very simple , although the case for the valuation congruence requires a slightly more complex proof ( if we get to this point ) . moreover , these axiomatizations are equivalent : the following systems @ xmath173 up to and including @ xmath540 all share the properties of @ xmath13 , and each such system is modified by the addition of either one or two axioms , in both cases making the stated axiom ( s ) irrelevant . for some @ xmath562 , this means that the@ xmath615 , @ xmath648 where all these properties are proper if @ xmath649 , and thus @ xmath650 , and thus @ xmath651 . we conclude that constraint - based evaluation trees and the valuation of @ xmath297 provide a full - fledged , simple and complete proof for @ xmath173 , and that this is also the case for contractive evaluation trees and the valuation of @ xmath396 , and for evaluation trees and the valuation congruence @ xmath526 . static valuation congruence over @ xmath615 for example @ xmath562 , coincides with the formal semantics of propositional logic in the following way : @ xmath652 where @ xmath653 and @ xmath654 refer to hoare . then @ xcite : @ xmath655 , @ xmath53 . the fact that @ xmath656 is more than @ xmath526 is immediately obvious : @ xmath657 while it is easy to see that @ xmath658 . our conclusion that @ xmath##540 , and so @ xmath547 is an axiomatization of static valuation . ##s slightly more complicated than those for the other axiomatizations because evaluation of a conditional statement @ xmath1 does not enforce a partial order for the evaluation of its arguments , and so such an order as implied by a given evaluation rule should be fixed indefinitely . to this end , we use some @ xmath562 . a spin - off of our approach can be called ` ` ' formal semantics for proposition algebra ' ' : for every valuation of c * , two conditional statements have c - form ##s if , and only if , they have equal c - basic forms , where c - basic forms are obtained by a linear transformation of conditional statements , which is a form of normalization . it is easy , but not difficult to prove that given some @ xmath562 , the function @ xmath620 is a normalization operator on @ xmath615 . in addition to lemma [ 1 : 6 . 7 ] this requires proving that for every st - basic statement @ xmath1 , @ xmath78 , @ xmath659 . weconclude with a short section on _ short - circuit evaluation _ , which we found in @ xcite ( see @ xcite for a brief description ) , and an example of the syntax of @ xmath173 . the binary variables that arise in the theory of logic , and that involve short - circuit evaluation , such as ` & & ` ( in c called ` ` ' and ' ' ) , are often defined in the following way : @ xmath660 independent of the precise syntax of @ xmath1 and @ xmath2 , hence , @ xmath661 . in a similarly way , negation can be defined by @ xmath662 . short - circuit evaluation focuses on the syntax @ xmath663 a first approach to this problem is to define the conditional as an independent variable , as was done in @ xcite , and to answer it with definitions of the same propositional connectives as above and the axiomatization for the # ##s of statements in proposition algebra ( or , if ` ` ' conditional and ' ' are at hand , axiomatizations for the appropriate conditional ##s ) . an alternative and more direct approach to question is toestablish axiomatizations for short - circuited binary connectives for which the operator is _ not _ used . for the valuation problem , an equational axiomatization of short - circuit ##ed propositional connectives was given by staudt in @ xcite , where @ xmath664 $ ] and @ xmath665 $ ] ( and @ xmath51 is also defined for short - circuit binary ) , and the above completeness theorem is based on the properties of such evaluation trees . for repetition - proof problems , it is an open question whether a complete , equational axiomatization of the short - circuited binary propositional connectives exists , and an example of repetition - proof evaluation trees generated by such problems may be of use in this respect . we conclude with an example on the properties of @ xmath173 that is based on ( * ? ? ? * ex . 4 ) . [ example : rp2 ] = @ xmath26 ##3 a pair of expressions of the form ` ( e = = e ' ) ` and ` ( n = n ) ` with @ xmath666 an initialized dependent variable and @ xmat##h667 provides examples for the expressions that may modify @ xmath666 . assume that ` ( e = = ' ' ) ` evaluate to @ xmath10 if @ xmath668 and @ xmath669 represent the same integer , and ` ( n = n ) ` ` evaluate to _ true _ with the assumption that @ xmath668 _ value is equal to @ xmath666 . all these expressions satisfy the properties of @ xmath173 . examples from @ xmath173 , e . g . , @ xmath670 . we note that a typical example of @ xmath173 in the setting of integrated - circuit logic is @ xmath671 ( cf . example [ ex : rp ] ) , and that example [ ex : rp2 ] is similar to the example of wortel @ xcite , where an instance of _ propositional _ programming _ @ xcite was investigated for which statements can be turned into tests ; the assumption that such tests always evaluate to _ true _ is natural because the assumption that they always succeed is natural . ] note that if @ xmath666 has the property of ;however , @ xmath672 and @ xmath673 refer to different cases , because the formula ` ( n = n + 1 ) ` does not satisfy the condition @ xmath674 , in which this case is substituted for the non - trivial case of @ xmath173 . _ _ _ . _ we also note that all the examples presented in this article can be used as a basis for the investigation of the types of _ _ _ _ that may depend upon the use of short - circuit circuits . see example [ 1 : rp ] , and we quote these examples of parnas @ xcite : _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ __ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ` ` most programming methods treat side effects with a bad programming technique . but , with well - designed , efficient algorithms , some algorithms do treat side effects ; side effects are also common in others . it is important to identify methods that deal with side effects in the worst cases . ' ' _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ __ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ __ _ _ _ _ _ _ _ _ _ _ _ _ bergstra , j . a . and ponse , m . ( 2012 ) . linear programming and free - form programming . in m . arbab and m . sirjani ( eds . ) , _ proceedings of the 6th international conference on foundations of electrical engineering _ ( fsen 2011 ) , springer . volume 7141 of lecture notes in computer science , pages 1 - 12 . springer - verlag .