connectivity and network design problems play an important role in network design and algorithms both for their theoretical basis and their practical real - world applications . an important and popular class of problems are of the following types : given a graph @ xmath5 with edge or vertex costs , find a minimum - cost subgraph @ xmath6 of @ xmath2 that has certain connectivity properties . for example , given an integer @ xmath7 , one can search for the minimum - cost spanning subgraph that is @ xmath8 - connected and @ xmath8 - vertex connected . if @ xmath9 , this is the classical minimum spanning tree ( mst ) problem . for @ xmath10 the problem is np - hard and is apx - hard to solve . more general solutions of these problems are possible if one seeks a subgraph in which a subset of the nodes @ xmath11 referred to as _ terminals _ are @ xmath8 - connected . the well - known spanning tree problem is to find a minimum - cost subgraph that ( @ xmath12 - ) connects a vertex to @ xmath13 . both of these problems are special cases of the survivable network design problem( sndp ) . in sndp , each pair of nodes @ xmath14 has a connectivity requirement @ xmath15 and the goal is to find a minimum - spanning subgraph that has @ xmath15 connected edges for each node @ xmath16 . given the intractability of these connectivity problems , there has been a large amount of work on these algorithms . a number of elegant and efficient algorithms and algorithms have been published over the years ( see @ xcite ) . in particular , the self - balancing method @ xcite and the rounding @ xcite have led to some remarkable results including a @ xmath1 - algorithm for edge - connected sndp @ xcite . another interesting class of problems , related to some of the connectivity problems described above , is solved by requiring that each @ xmath0 of the network terminals be connected . these problems are partly motivated by applications in which one wishes to maximize profit given an upper bound ( budget ) on the network . for example , a typical problem in vehicle routing applications is to find a path that minimize the number of vertices in it subject to a constraint @ xmath17 on the length of the path . in the general network case , theprofit maximization algorithm is equivalent to the problem of minimizing the cost / length of a path subject to the assumption that at least @ xmath0 vertices are included . of course the two problems may not be approximation equivalent , however , understanding one is often difficult and difficult to solve the other . the most well - known of these versions is the @ xmath0 - mst problem ; the problem here is to find a minimum - cost subgraph of the given graph @ xmath2 that contains at least @ xmath0 vertices ( or terminals ) . this problem has received much attention in the evolutionary algorithms community and its study has led to many new algorithmic algorithms and to @ xcite . we note that the steiner tree problem can be relatively easily generalized in an approximation equivalent fashion to the @ xmath0 - ms problem . more recently , lau _ et al . _ @ xcite published the following generalization of @ xmath0 - mst to graph connectivity . in particular they defined the @ xmath18 - subgraph problem to be the following : find a minimum - cost subgraph of the given graph @ xmath2 that contains at least @ xmath0 vertices and is @ xmath##8 - edge connected . we use the notation @ xmath0 - @ xmath8ec to refer to this problem . in @ xcite an @ xmath19 approximation is obtained for the @ xmath0 - @ xmath1ec problem . however , the algorithm and proof in @ xcite are incomplete . more recently , and after further work from ours , the authors of @ xcite obtained a better approximation for @ xmath0 - @ xmath1ec that yields an @ xmath20 approximation . we published later a more detailed proof of their approach and ours . it is also shown in @ xcite that a better approximation for @ xmath0 - @ xmath8ec when @ xmath8 is large would yield an improved approximation for the @ xmath0 - largest subgraph problem @ xcite ; for this problem one finds a @ xmath0 - sized subgraph of a given graph @ xmath2 that has the largest number of edges . the @ xmath0 - largest subgraph problem yields an @ xmath21 approximation for a fixed constant @ xmath22 @ xcite , but has resisted attempts at an improved approximation for this problemof years ago . in this section we consider the vertex - connectivity generalization of the @ xmath0 - mst problem . we consider the @ xmath0 - @ xmath8vc problem as follows : given an edge @ xmath0 and a graph @ xmath2 with edge connectivity , find the highest - degree @ xmath8 - vertex - connectivity subgraph of @ xmath2 that contains at most @ xmath0 vertices . we also consider the _ terminal _ problem of the form where the subgraph has to contain @ xmath0 vertices from a given terminal vertex @ xmath3 . it can be easily shown that the @ xmath0 - @ xmath8ec problem reduces to the @ xmath0 - @ xmath8vc problem for terminals @ xmath23 . we also observe that the @ xmath0 - @ xmath8ec problem with terminals can be easily reduced , as follows , to the following problem where each vertex is a terminal : for each vertex @ xmath24 , find @ xmath25 with vertices @ xmath26 and add @ xmath27 to @ xmath28 with @ xmat##h8 has edges of zero cost . # # @ xmath29 in the new graph . we can avoid using these edges by adding a clique to @ xmath26 with zero - cost vertices and reducing @ xmath8 of these vertices to @ xmath28 . note , however , that this method only works for time - sharing . we are not aware of any method that reduces the @ xmath0 - @ xmath8vc problem with a finite set of vertices to the @ xmath0 - @ xmath8vc problem , even when @ xmath30 . in this paper we consider the @ xmath0 - @ xmath1vc problem ; our main result is the following . [ cr : ke ] there is an @ xmath31 approximation for the @ xmath0 - @ xmath1vc problem where @ xmath32 is the number of terminals . [ cor : ke ] there is an @ xmath31 approximation for the @ xmath0 - @ xmath1ec problem where @ xmath32 is the number of terminals . one of the technical problems that we note is the solution , which may be of general nature .given a graph @ xmath2 with edge costs and set of terminals @ xmath3 , we define @ xmath33 for each subgraph @ xmath6 to be the ratio of the weight of terminals in @ xmath6 to the minimum weight of terminals in @ xmath6 . [ thm : cycle ] let @ xmath2 be an @ xmath1 - simply - connected graph with edge costs and let @ xmath34 be a set of terminals . then , there is a complete graph @ xmath35 containing at least @ xmath1 terminals ( a non - trivial cycle ) such that the density of @ xmath35 is at least the density of @ xmath2 . moreover , such a cycle can be found in polynomial time . using the above theorem and the lp algorithm we obtain the following . [ cor : cycle ] given a graph @ xmath5 with edge costs and @ xmath32 and @ xmath36 , there is an @ xmath37 approximation for the problem of finding a minimum - weight non - trivial cycle . note that both [ thm : cycle ] and corollary [ cor : cycle ] are of interest becausewe seek a cycle with at least _ n _ terminals . a minimum - density cycle containing only one terminal can be found by using the well - known minimum - mean cycle problem for directed graphs @ xcite . we remark , however , that although we know that the problem of finding a minimum - density non - trivial cycle is np - hard , we currently do not have a proof . the [ thm : cycle ] shows that the problem is equivalent to the * - @ xmath1vc problem , discussed in the previous section . * note : * the reader can ask whether @ xmath0 - @ xmath1ec or @ xmath0 - @ xmath1vc admit a # # ##ization , since the @ xmath0 - mst problem admits one . we note that the same technical definition which gives @ xmath38 ##3 for @ xmath0 - mst problem @ xcite has a special property that holds for a particular version of the minimum - collection steiner tree problem @ xcite which is a lagrangian version of the steiner tree problem . such a property is also known to hold for generalizations of @ xmath0 - @ including @ xmath0 - @xmath1ec and @ xmath0 - @ xmath1vc and the @ xmath0 - @ sap and @ xcite . however , one is forced to rely on alternative and problem - specific algorithms . we consider the rooted version of @ xmath0 - @ xmath1vc : the goal is to find a minimum - cost subgraph that @ xmath1 - connects through all @ xmath0 vertices to a single vertex at @ xmath39 . it is very easy to reduce @ xmath0 - @ xmath1vc to the rooted version ( see section [ sec : k2vc ] for details . ) we draw inspiration from the work that led to poly - tree approximations for the @ xmath0 - tree problem . to approximate our approach to the rooted @ xmath0 - @ xmath1vc problem , we use a closely related algorithm . for a subgraph @ xmath6 that contains @ xmath39 , let @ xmath40 be the number of vertices that are @ xmath1 - connected to @ xmath39 in @ xmath6 . then the _ size _ of @xmath6 is simply the ratio of the size of @ xmath6 to @ xmath40 . the lp - @ xmath1vc problem is to find a 2 - connected subgraph of bounded density . an @ xmath37 approximation for the dens - @ xmath1vc problem ( where @ xmath32 is the number of terminals ) can be derived in a not what a way by using a bucket and scaling trick as a dynamic programming algorithm for the problem . we base the high performance of @ xmath1 on the desirable property of a given solution for the sndp problem with vertex connectivity , in @ xmath41 @ xcite . the bucket and scaling trick has seen many applications in the past and has also been highlighted in several applications @ xcite . our algorithm for @ xmath0 - @ xmath1vc uses a greedy algorithm at the highest level . we start with an empty subgraph @ xmath42 and apply the approximation algorithm for lp - @ xmath1vc in an efficient way to repeatedly add terminals to @ xmath42 until at least @ xmath43 terminals are in @ xmath42 . thisthis would yield an @ xmath44 solution if @ xmath45 . however , the next iteration of the dens - @ xmath1vc algorithm will add many more terminals than necessary with the exception that @ xmath46 . in this case we can not guarantee the quality of the solution obtained by the algorithm . to overcome this problem , one can expect to _ allow _ the subgraph @ xmath6 _ in the next iteration to also add the desired number of terminals . for the @ xmath0 - mst problem , @ xmath6 is a cycle and this is quite easy . we remark that this is a very straightforward @ xmath20 approximation for @ xmath0 - mst and could have been discovered much before a very detailed proof provided by @ xcite . one of our main contributions is to give the first step for the @ xmath0 - @ xmath1vc problem . to do this , we use two basic ideas . the first is found by the cycle finding algorithm of @ [ thm : cycle ] . second , we use this cycle finding algorithm to repeatedly merge subgraphs until we get the maximum number of cycles in one sub##graph . this last step requires care . the cycle merging scheme was inspired by a similar idea from the work of lau _ et al . _ @ xcite on the @ xmath0 - @ xmath1ec problem and _ @ xcite on the cycle orienteering problem . these ideas yield the @ xmath47 approximation . we use a slightly modified cycle - merging scheme with a more sophisticated and non - linear algorithm to obtain an improved @ xmath31 approximation . some remarks are in order to compare our work to that of @ xcite on the @ xmath0 - @ xmath1ec problem . the original algorithm in @ xcite was based on finding a low - dimensional cycle or a graph structure called a k - cycle . the algorithm in @ xcite to find such a structure is incorrect . further , the cycles are contracted at the edges which is the solution to the @ xmath0 - @ xmath1ec problem ( contracting a cycle in @ xmath1 - node - connected graph to make the resulting graph not @ xmath1 - node - connected ) . in our algorithm we do not contract cycles and instead create new cycles with weights to capture the number of terminals in an already existingtheorem . this allows us to also solve the maximum - degree non - infinite - degree problem which we solved via the [ thm : cycle ] and corollary [ cor : graph ] . in their work , lau _ et al . _ @ xcite give a simple and correct @ xmath48 - algorithm for @ xmath0 - @ xmath1ec . they also follow the same approach that we do when using the lp for computing the subgraphs , by the iteration step . however , in the pruning step they use a completely different approach ; they use the greedy algorithm of - - where zero @ xmath49 - 0 @ xcite . although the proof of this theorem is difficult , the lp works well for the @ xmath0 - @ xmath1ec problem , since our approach is less complicated and leads to an approximation for the more general @ xmath0 - @ xmath1vc problem . we start with graphs in which the vertices are designated as _ terminals _ . for a graph @ xmath2 with _ costs and _ costs , we set the _ cost _ of the subgraph @ xmath6 to the square of the number of edges in @ xmat##h6 denote by the sum of the number of vertices in @ xmath6 . henceforth , we use @ xmath1 - connected graph to mean the @ xmath1 - 2 - connected graph . the goal of the @ xmath0 - @ xmath1vc problem is to find a minimum - cost 2 - connected subgraph on at least @ xmath0 terminals . . for simplicity of presentation , however , we refer to the following restricted list . ] recall that for the original @ xmath0 - @ xmath1vc problem , the goal is to find a minimum - cost subgraph on at least @ xmath0 terminals in which every vertex is 2 - connected to the specified root @ xmath39 . the ( unrooted ) @ xmath0 - @ xmath1vc problem can be reduced to the rooted problem by _ _ _ the vertices @ xmath16 that are not the optimal roots , finding a new root at @ xmath39 , and connecting vertices with 0 - connected edges to @ xmath50 and @ xmath28 . it is very hard to show that any solution to the rooted problem in the modified graph can be reduced to thereturn to the unrooted problem by adding the minimum - cost non - disjoint paths between @ xmath50 and @ xmath28 . ( since @ xmath50 and @ xmath28 result in the optimal solution , the cost of these two paths need not be more than @ xmath51 . ) we omit further details from this extended section . for the dens - @ xmath1vc problem , the goal is to find a subgraph @ xmath6 of maximum degree in which the terminals of @ xmath6 are next - nearest to the root . the following algorithm is given in section [ subsec : algorithm ] below . it relies on a @ xmath1 - approximation , via the algorithm lp , for the minimum - cost @ xmath1 - approximation problem due to fleischer , jain and williamson @ xcite , and some other techniques . [ ref : densv ] there is an @ xmath37 - approximation algorithm for the min - @ xmath1vc problem , where @ xmath32 is the number of terminals of the given graph . let @ xmath51 be the root of the optimal solution to the @xmath0 - @ xmath1vc problem . we assume existence of @ xmath51 ; this can be dealt with using standard algorithms . we pre - solve the problem by adding a node that does not contain 2 non - connected edges to the root @ xmath39 of total nodes per root @ xmath51 . the high - performance version of the algorithm for the rooted @ xmath0 - @ xmath1vc problem is given below . @ xmath52 , @ xmath53 find the empty set . + if ( @ xmath54 ) : + use the same algorithm for non - @ xmath1vc to find the subgraph @ xmath6 , @ xmath2 . + if ( @ xmath55 ) : + @ xmath56 , @ xmath57 + find all nodes of @ xmath6 as non - empty . + else : + _ _ _ @ xmath6 to find @ xmath58 that contains @ xmath59 terminals . + @ xmath60 , @ xmath61 + output @ xmath42 at the end of each .of the following loop , the result contains a solution to the non - @ xmath1vc problem of density at most @ xmath62 . therefore , the graph @ xmath6 ##2 earlier has density at most @ xmath63 . if @ xmath55 , we add @ xmath6 to @ xmath42 and decrement @ xmath59 ; we refer to this as the _ _ _ step . thus , we have a graph @ xmath6 of good density , but with too few terminals . in this case , we use @ xmath6 to get the graph with the required number of terminals ; this is the _ _ step _ . a simple graph - based greedy algorithm has the following form : [ lem : 1 ] if , at each iteration step , we have a graph of density at most @ xmath64 ( where @ xmath59 is the number of additional terminals that must be added ) , the total cost of all the augmentation steps is at most @ xmath65 . therefore , we will only have to calculate the cost of the algorithm @ xmath58 . in the pruning .; we proved the main result in theorem [ sec : kv ] . [ thm : avekv ] let @ xmath66 be an instance of the rooted @ xmath0 - @ xmath1vc problem with vertex @ xmath39 , such that each vertex of @ xmath2 contains @ xmath1 ##vc - directed edges to @ xmath39 of minimum cost at most @ xmath67 , and such that @ xmath68 . there is a polynomial - time algorithm to find a solution to this instance of cost at most @ xmath69 . we can now prove our main result for the @ xmath0 - @ xmath1vc problem , theorem [ sec : kv ] . theorem [ thm : kv ] let @ xmath51 be the cost of the optimal solution to the ( rooted ) @ xmath0 - @ xmath1vc problem . by lemma [ lem : kv ] , the minimum cost of the augmentation steps of our optimization algorithm is @ xmath70 . to calculate the cost of the optimization step , let @ xmath59 be the number of the additionalthat must be covered up prior to this step . the algorithm for the max - @ xmath1vc problem returns a graph @ xmath6 with @ xmath71 terminals , and cost at most @ xmath72 . as a result of our pre - computation step , every graph has two vertex - disjoint paths to @ xmath39 of and cost at most @ xmath51 . now , we use theorem [ sec : avekv ] to compute @ xmath6 and find a graph @ xmath58 with @ xmath59 terminals and cost at most @ xmath73 . therefore , the total cost of our algorithm is @ xmath74 . it remains only to prove theorem [ sec : densv ] , that there exists an @ xmath75 - approximation for the dens - @ xmath1vc problem , and theorem [ thm : avekv ] , for the cost of the computation step . we prove the former in section [ subsec : cycles ] below . if the latter is proved in section [ sec : cycles ] , we prove the results in section [ sec : cycles] ; ] among these tools is theorem [ thm : 1 ] . suppose that the lp - @ xmath1vc algorithm is formulated as follows : given a graph @ xmath5 with edge - connectivity , a set @ xmath76 of terminals , and a terminal @ xmath77 , and a subgraph @ xmath6 of bounded density , in which every terminal of @ xmath6 is edge - connected to @ xmath39 . ( here , the density of @ xmath6 is defined as the density of @ xmath6 divided by the number of terminals it contains , not including @ xmath39 . ) we find an algorithm for dens - @ xmath1vc that uses an @ xmath37 - algorithm , and sketch a solution . we use an approximation based approach and a sorting and sorting algorithm ( see @ xcite for applications of this idea ) , and a two - factor approximation of the integrality gap of an lp for sndp with edge - connectivity , , @ xmath41 @ xcite . we define * lp - lp * as the maximum partial relaxation of lp - @ xmath1vc . for each terminal@ xmath78 , the variable @ xmath79 indicates whether or not @ xmath28 is used as the solution . ( by setting @ xmath80 to 0 , and considering the effect of the costs , we get the density . ) @ xmath81 is the sum of the shortest paths between @ xmath78 and the edge @ xmath39 ; for example @ xmath82 , @ xmath83 indicates how much ` flow ' is required from @ xmath28 to @ xmath39 and @ xmath35 . ( note that a pair of self - connected paths form a cycle ; the flow along the cycle is optimal if we can re - connect @ xmath78 to @ xmath39 using the length of the cycle . ) the variable @ xmath84 indicates whether the edge @ xmath85 is used as the solution . @ xmath86 @ xmath87 it is not hard to see that an optimal solution to * lp - dens * will cost at least the cost of an optimal solution to * - @ xmath1vc . we now know how tofind an integral solution of density at most @ xmath88 , where @ xmath89 is the density of an optimal solution to * lp - des * . the optimization problem * lp - dens * has an exponential number of variables but a finite number of non - linear equations ; it can , however , be solved in polynomial time . find an optimal solution to * lp - des * of density @ xmath89 , and for each @ xmath90 ( for ease of notation , where @ xmath91 is an integer ) , let @ xmath92 be the number of terminals @ xmath78 such that @ xmath93 . since @ xmath94 , there is a terminal @ xmath95 such that @ xmath96 . since every terminal @ xmath97 has @ xmath98 , the number of terminals of @ xmath92 has at most @ xmath99 . we know that there is a subgraph @ xmath6 of @ xmath2 with density at most @ xmath100 , in which every terminal of @ xmath92 is simply - connected tothe root . if this is true , the density of @ xmath6 is at most @ xmath101 , and so we have an @ xmath37 - solution for the dens - @ xmath1vc problem . to prove our conjecture about the density of the subgraph @ xmath6 in which each terminal of @ xmath92 is 2 - connected to @ xmath39 , consider scaling of the ` scaled solution of * lp - dens * by a function of @ xmath102 . for each terminal @ xmath103 , the flow from @ xmath78 to @ xmath39 in this scaled solution ] is at most 1 , and the cost of the optimal solution is @ xmath104 . in @ xcite , the authors use a linear program @ xmath105 to find a minimum - cost subgraph in which a given set of terminals is 2 - connected to the root , and show that this linear program has an optimal cost of 1 . the algorithm @ xmath84 and the ` scaled solution ' to * lp - des * correspond to a scaled solution of @ xmath105 with @ xmat##h92 as the set of terminals ; the essential property of this implies that there is a subgraph @ xmath6 in which every terminal of @ xmath92 is 2 - connected to the edge , with cost at most @ xmath106 . therefore , the algorithm for max - @ xmath1vc is : 1 . find an optimal _ solution to * * - dens * . 2 . find a set of terminals @ xmath92 such that @ xmath107 . 3 . find a min - optimal subgraph @ xmath6 in which every terminal of @ xmath92 is 2 - connected to @ xmath39 using the cost of @ xcite . @ xmath6 has cost at most @ xmath37 times the optimal solution to max - @ xmath1vc . a cycle @ xmath108 is _ non - trivial _ if it contains at least 2 terminals . we have the minimum - density non - trivial _ algorithm : given a cycle @ xmath5 , with @ xmath3 , with terminals , edge costs and terminal costs , is a minimum - density cycle that contains at least 2 terminals . thethat if we remove the requirement that the cycle be non - trivial ( that is , it has at most 2 terminals ) , the problem reduces to the minimum - density cycle problem for all graphs , and can be solved exactly in polynomial time ( see @ xcite ) . algorithms for the minimum - density non - trivial cycle problem are a useful tool for solving the @ xmath0 - @ xmath1vc and @ xmath0 - @ xmath1ec problems . in this section , we give an @ xmath75 - @ algorithm for the minimum - density non - trivial cycle problem . first , we prove theorem [ 2 : 1 ] , that a 2 - dimensional graph with edge lengths and edge density contains a minimal non - trivial cycle , with density no more than the maximum density of the graph . we give two algorithms to find such a cycle ; the first , described in section [ subsec : nonpoly ] , is simpler , but the running time is not known . a more general proof that reduces to a simple polynomial - time algorithm is given in section [ subsec : cycle ] ; we let this proof be skipped on the first reading . to find a non - trivial cycle of density at least that of the2 - as input to @ xmath2 , we will start with an arbitrary non - trivial cycle , and then find cycles of equal density until we obtain a cycle with density at most @ xmath109 . the following theorem states that if a cycle @ xmath35 has an ear with density less than @ xmath110 , we can use this method to find a cycle of equal density . [ source : goodear ] let @ xmath35 be a non - trivial cycle , and @ xmath6 an ear corresponding to @ xmath35 in @ xmath50 and @ xmath28 , such that @ xmath111 . let @ xmath112 and @ xmath113 be the two internally shortest paths between @ xmath50 and @ xmath28 in @ xmath35 . then @ xmath114 and @ xmath115 are both trivial cycles and each of these is non - trivial and has density less than @ xmath110 . @ xmath35 has at least 2 terminals , so it has finite density ; @ xmath6 must then have at least 1 terminal . let @ x##math116 , @ xmath117 and @ xmath118 are , respectively , the sum of the costs of the terminals in @ xmath112 , @ xmath113 and @ xmath6 , and let @ xmath119 , @ xmath120 and @ xmath121 be the sum of the costs of the terminals in @ xmath112 , @ xmath113 and @ xmath122 . [ w . a . r . s . that @ xmath112 has cost at most that of @ xmath113 . ( that is , @ xmath123 . ) and @ xmath113 has cost 1 and weight 1 . in this case , let @ xmath112 be the cycle with non - zero density . ] @ xmath112 must contain at least one terminal , and therefore @ xmath114 is a simple non - zero cycle . the sequence @ xmath124 is equivalent to @ xmath125 . @ xmath126 therefore , @ xmath114 is a simple cycle with at least two components of density less than @ x##math110 . [ example : 2conncomp ] given a cycle @ xmath35 in an @ xmath1 - connected graph @ xmath2 , let @ xmath42 be the cycle formed from @ xmath2 by adding @ xmath35 to a single vertex @ xmath28 . if @ xmath6 is a connected component of @ xmath127 , @ xmath128 is @ xmath1 - connected in @ xmath42 . let @ xmath6 be an arbitrary connected component of @ xmath127 , and then @ xmath129 . to prove that @ xmath58 is 2 - connected , we first observe that @ xmath28 is 2 - connected to any vertex @ xmath130 . ( any vertex that separates @ xmath131 from @ xmath28 and @ xmath58 separates @ xmath131 from the cycle @ xmath35 in @ xmath2 . ) it now follows that for all vertices @ xmath132 , @ xmath131 and @ xmath133 are 2 - connected in @ xmath##58 . suppose deleting some vertices @ xmath50 and @ xmath131 from @ xmath133 . the vertex @ xmath50 need not be @ xmath28 , since @ xmath6 is a common component of @ xmath127 . but if @ xmath134 , @ xmath28 and @ xmath131 are in the same component of @ xmath135 , since @ xmath28 is 2 - connected to @ xmath131 and @ xmath58 . therefore , @ xmath28 and @ xmath133 are in the same component of @ xmath135 , and so , @ xmath50 does not separate @ xmath131 from @ xmath133 . we can show that for any 2 - connected graph @ xmath2 , we can find a non - trivial cycle of length 2 less than that of @ xmath2 . [ see : cycleexists ] let @ xmath2 be a @ xmath1 - connected graph with at most @ xmath1 terminals . @ xmath2 is a ( non - trivialcycle @ xmath136 such that @ xmath137 . let @ xmath35 be an independent non - trivial connected cycle ; such a cycle always exists since @ xmath2 is @ xmath1 - connected and has at least 2 terminals . if @ xmath138 , we have an algorithm that finds a single non - trivial cycle @ xmath139 such that @ xmath140 . repeating this algorithm , we find cycles of successively lower densities until finally finding a non - trivial cycle @ xmath136 of density at least @ xmath109 . let @ xmath42 be the graph formed by adding the connected cycle @ xmath35 to a single cycle @ xmath28 . in @ xmath42 , @ xmath28 is not a terminal , and therefore has weight 1 . consider the 2 - connected components of @ xmath42 ( from the [ lem : 2conncomp ] , each such cycle is formed by adding @ xmath28 to a single component of @ xmath127 ) , and pick the one of highest density . if @ xmath6 is this component , @ xmath14##1 is the natural number . @ xmath6 has at most 1 terminal . if it contains 2 or 3 terminals , recursively find a non - trivial cycle @ xmath139 and @ xmath6 such that @ xmath142 . if @ xmath139 exists in the original graph @ xmath2 , it has the following properties , and we are satisfied . otherwise , @ xmath139 contains @ xmath28 , and the vertices of @ xmath139 form an ear of @ xmath35 in the original graph @ xmath2 . the density of this ear is less than the density of @ xmath35 , so we can apply to [ 1 : goodear ] to find a non - trivial cycle in @ xmath2 that has density less than @ xmath110 . similarly , if @ xmath6 has only one terminal @ xmath50 , find the 2 vertex - connected paths using edges of @ xmath6 from @ xmath50 to the vertices of the graph @ xmath35 . ( since @ xmath2 is simply - connected , there must exist such paths . )the density of these paths is at most @ xmath143 , and concatenating these 2 paths leads to a cycle of @ xmath35 in @ xmath2 . the cost of this ear is less than @ xmath110 ; therefore , we use theorem [ theorem : goodear ] to obtain a cycle in @ xmath2 with the desired density . we remark here that the algorithm of theorem [ thm : cycleexists ] does not lead to a polynomial - time algorithm , even if the edge weights and terminal weights are polynomially bounded . in section [ subsec : strong ] , we describe a similar polynomial - time algorithm that , given a graph @ xmath2 , finds a non - trivial cycle of density at most that of @ xmath2 . note that neither of these algorithms can directly give a complete solution to the min - 1 non - trivial cycle problem , because the resulting non - trivial cycle will have density much less than that of @ xmath2 . however , we can use theorem [ theorem : cycleexists ] to prove the following result : [ theorem : equivalence ] there is an @ xmath144 - solution to the ( unrooted) @ - @ xmath1vc problem if and only if there is an @ xmath144 - approximation to the problem of finding a low - density non - trivial cycle . suppose we have a @ xmath145 - approximation for the dens - @ xmath1vc problem ; we use it to find a low - density non - trivial cycle . solve the @ - @ xmath1vc problem for the given cycle ; since the given cycle is a simply - connected graph , our solution @ xmath6 to the @ - @ xmath1vc problem has density at most @ xmath145 times the density of this cycle . find a non - trivial optimal solution @ xmath6 of density at most that of @ xmath6 ; it has density at most @ xmath145 times that of an optimal non - trivial cycle . note that every instance of the ( unrooted ) @ - @ xmath1vc problem has an optimal solution that is a non - trivial cycle . ( for every optimal solution @ xmath6 of the @ xmath146 ; by theorem [ thm : cycle ] , @ xmath6 has anon - trivial cycle of vertices gives a @ xmath146 . this cycle is the unique solution to the min - @ xmath1vc problem . ) therefore , a @ xmath147 - approximation for the min - max non - trivial cycle problem gives a @ xmath147 - approximation for the dens - @ xmath1vc problem . theorem [ thm : equivalence ] and theorem [ lem : densv ] imply an @ xmath37 - approximation for the minimum - density non - trivial cycle problem ; this is theorem [ cor : equivalence ] . we say that a graph @ xmath5 is not 2 - connected on its terminals if for every graph @ xmath148 , some cycle of terminals is not 2 - connected in the graph @ xmath149 . section [ subsec : equivalence ] shows that in a graph which is not 2 - connected on its terminals , every cycle is non - trivial . therefore , the problem of finding a minimum - density non - trivial cycle in these graphs is like that of finding a minimum - density graph , which can be solved exactly in polynomial time . however , as we explain at the beginning of thehowever , this does not directly lead to an efficient algorithm for arbitrary graphs . in this section , we describe a strongly polynomial - time algorithm which , given a 2 - dimensional graph @ xmath5 with minimum costs and size ##ity , produces a non - trivial graph of length at least that of @ xmath2 . we start with two steps : let @ xmath35 be a cycle in a graph @ xmath2 , and @ xmath42 be the graph obtained by removing @ xmath35 from @ xmath2 . let @ xmath150 be the connected components of @ xmath42 ; we refer to these as _ edges _ of @ xmath35 . if simply a cycle , it would be an edge of @ xmath35 , but @ xmath151 would be more complicated . ] for each @ xmath151 , let the vertices of @ xmath35 incident to it be _ the _ edges _ . from the definition of an edge , for each pair of vertices of @ xmath151 , there is a cycle between them whose internal vertices are not in @ xmath151 . we say that a cycle of @ x##math35 is an _ anchor _ if it is the anchor of a ring . ( an anchor may be a pair of different earrings . ) a _ segment _ @ xmath13 of @ xmath35 is a segment contained in @ xmath35 , such that the vertices of @ xmath13 are both connected , and no other vertex of @ xmath13 is an anchor . ( note that the vertices of @ xmath13 might be clasps of the same ring , or of distinct rings . ) it is easy to see that the anchors are the entire set of @ xmath35 . by deleting a segment , we refer to both external edges and internal vertices . note that if @ xmath13 is disconnected from @ xmath2 , the only vertices of @ xmath152 that form an anchor are the vertices of @ xmath13 . a segment is _ safe _ if the cycle @ xmath153 is 2 - connected . now choose the vertex @ xmath154 of @ xmath35 as the _ origin _ , and then rotate the vertices of @ xmath35 clockwise around the cycle . @xmath155 . the first clasp of an object @ xmath6 is its lowest numbered clasp , and the last clasp is its highest numbered clasp . ( if the object is a part of @ xmath6 , it is considered the first clasp , not the last . ) the _ arc _ of an arc is the subgraph of @ xmath35 , by traversing it from its first clasp @ xmath156 to its last clasp @ xmath157 ; the length of this arc is @ xmath158 . ( that is , the length of an arc is the number of elements it contains . ) note that if an arc contains the elements , it must be the first part of the arc . figure [ 1 : earring ] illustrates several of these arcs . ( 0 , 0 ) ; ( 3 cm ) ; at ( 0 , 0 ) @ xmath35 ; ( 30 : 2 cm ) ( 30 : 2 cm ) ; ( 3 , 0 ) ( 3 , 0 ) ; ( - 45 : 2 cm ) ( - 45 : 2 cm ) ; at ( 38 : 2 . 5 cm ) @ xmath159 ; at ( 0 . 35 , 0 . 35 ) @xmath160 ; at ( - 53 : 2 . 8 cm ) @ xmath161 ; at ( 0 , 2 . 0 ) @ xmath162 ; ( 30 : 2 . 8 cm ) arc ( 30 : - 45 : 2 . 5 cm ) ; ( 330 : 4 . 2 cm ) ; ( 30 : - 45 : 4 . 2 cm ) ; ( 30 : 2 . 2 cm ) arc ( - 45 : - 330 : 4 . 8 cm ) ; ( - 53 : 2 . 8 cm ) arc ( 30 : 315 : 4 . 2 cm ) ; at ( 30 : 2 . 5 cm ) @ xmath6 ; ( 30 : 2 cm ) circle ( 1 mm ) ; ( - 30 : 2 cm ) circle ( 1 mm ) ; ( 2 , 2 ) circle ( 1 mm ) ; ( 0 , 2 ) circle ( 1 mm ) ; ( 30 : 1 . 75 cm ) ; ( 30 : - 45 : 1 . 75 cm ) ; ( 0 , 2 ) circle ( 1 mm ) ; at ( 0 , 0 ) @ xmath35 ; ( 0 , 0 ) ( 0 , 3 . 0 ) ; ( 30 : - 45 : 3 . 6 cm ) ( 0 ,- 1 ) ; at ( 0 , 1 . 6 ) @ xmath163 ; at ( 0 , - 1 . 6 ) @ xmath164 ; at ( 0 , 3 . 6 ) [ font = ] @ xmath165 ; ( 30 : 3 cm ) ( 30 : 3 cm ) ; ( 30 : - 30 : 3 cm ) ( - 30 : 3 cm ) ; at ( 30 : 1 . 6 cm ) @ xmath156 ; at ( - 30 : 1 . 6 cm ) @ xmath157 ; ( 30 : 2 . 2 cm ) ; ( 30 : 330 : 2 . 2 cm ) ; ( 30 : 2 . 2 cm ) ( 30 : 2 . 2 cm ) ; ( 25 : - 25 : 2 . 2 cm ) ( - 25 : 2 . 2 cm ) ; ( 30 : 2 cm ) circle ( 1 mm ) ; ( - 30 : 2 cm ) circle ( 1 mm ) ; ( 0 , 0 ) circle ( 1 mm ) ; ( 0 , - 0 ) circle ( 1 mm ) ; ( 30 : 2 cm ) circle ( 1 mm ) ; at ( 30 : 2 . 5 cm ) @ xmath162 ; ( 0 , 0 )at ( 0 cm ) ; at ( 0 , 0 ) @ xmath35 ; ( 0 , 0 ) ( 0 , 3 . 6 ) ; ( 90 : - 90 : 3 . 6 cm ) ( 0 , - 1 ) ; at ( 0 , 1 . 6 ) @ xmath163 ; at ( 0 , - 1 . 6 ) @ xmath164 ; at ( 0 , 1 . 9 ) [ font = ] @ xmath166 ; at ( 0 : 1 . 6 cm ) @ xmath156 ; at ( - 30 : 1 . 6 cm ) @ xmath157 ; ( 30 : 2 cm ) ( 90 : 3 . 6 cm ) ; ( 85 : 2 cm ) ( 25 : 2 cm ) arc ( 85 : - 88 : 3 cm ) ( - 35 : 2 cm ) ; arc ( 25 : 2 . 6 cm ) [ font = ] @ xmath167 ; ( - 85 : 2 cm ) ( - 35 : 3 cm ) ; ( 25 : 2 . 4 cm ) ( 25 : 2 . 4 cm ) arc ( 85 : - 88 : 2 . 4 cm ) ( - 35 : 2 . 4 cm ) arc ( - 88 : - 35: 2 . 2 cm ) ; ( - 25 : 2 . 2 cm ) ( - 25 : 2 . 2 cm ) ; ( - 25 : 80 : 2 . 8 cm ) ( 80 : 2 . 2 cm ) arc ( 80 : 35 : 2 . 2 cm ) ; ( 0 : 2 cm ) circle ( 1 mm ) ; ( - 30 : 2 cm ) circle ( 1 mm ) ; ( 0 , 2 ) circle ( 1 mm ) ; ( 0 , - 0 ) circle ( 1 mm ) ; ( 0 : 2 cm ) circle ( 1 mm ) ; at ( 0 : 0 . 6 cm ) @ xmath162 ; ( 0 , 2 ) circle ( 1 mm ) ; at ( 0 , 2 ) @ xmath35 ; ( 0 , 2 ) ( 0 , 1 . 6 ) ; ( 90 : - 90 : 3 . 5 cm ) ( 0 , - 0 ) ; at ( 0 , 1 . 6 ) @ xmath163 ; at ( 0 , - 1 . 6 ) @ xmath164 ; at ( 0 , 1 . 6 ) [ = = ] @ xmath165 ; at ( 0 : 1 . 6 cm ) @ xmath156 ; at ( -30 : 1 . 5 cm ) @ xmath157 ; ( 30 : 2 cm ) ( 30 : 2 . 1 cm ) arc ( 30 : - 135 : 2 . 1 cm ) ( - 105 : 2 cm ) ; at ( 35 : 2 . 5 cm ) [ font = ] @ xmath166 ; ( - 135 : 2 cm ) ( - 135 : 2 . 5 cm ) arc ( - 35 : - 143 : 2 . 5 cm ) ( - 105 : 2 cm ) ; at ( - 143 : 2 . 5 cm ) [ font = ] @ xmath167 ; ( 35 : 2 . 15 cm ) arc ( 85 : 35 : 2 . 15 cm ) ( 85 : 3 . 45 cm ) arc ( 35 : - 35 : 3 . 45 cm ) ( - 35 : 2 . 15 cm ) arc ( - 35 : - 35 : 2 . 15 cm ) ; ( 25 : 2 . 95 cm ) ( 25 : 2 . 95 cm ) arc ( 100 : - 100 : 2 . 95 cm ) ( - 100 : 2 . 15 cm ) arc ( - 100 : - 130 : 2 . 65 cm ) ( - 130 : 2 . 65 cm ) arc ( - 130 : - 130 : 2. 5 cm ) ( - 25 : 2 . 5 cm ) ; ( 30 : 2 cm ) circle ( 1 mm ) ; ( - 30 : 2 cm ) circle ( 1 mm ) ; ( 0 , 0 ) circle ( 1 mm ) ; ( 0 , - 0 ) circle ( 1 mm ) ; ( 0 : 0 cm ) circle ( 1 mm ) ; at ( 30 : 1 . 6 cm ) @ xmath162 ; ( 0 , 0 ) circle ( 1 cm ) ; at ( 0 , 0 ) @ xmath35 ; ( 0 , 2 ) ( 0 , 0 . 6 ) ; ( 0 : - 90 : 3 . 6 cm ) ( 0 , - 0 ) ; at ( 0 , 1 . 6 ) @ xmath163 ; at ( 0 , - 0 . 6 ) @ xmath164 ; at ( 0 , 0 . 6 ) [ = = ] @ xmath168 ; at ( 0 : 1 . 6 cm ) @ xmath156 ; at ( - 30 : 2 . 6 cm ) @ xmath157 ; ( 30 : 2 cm ) ( 90 : 3 . 6 cm ) ; ( - 30 : 2 cm ) ( - 30 : 2 cm )at ( - 125 : - 125 : 2 cm ) ( - 125 : 2 cm ) ; at ( - 125 : 2 cm ) [ = = ] @ xmath167 ; ( - 35 : 2 . 4 cm ) ; ( - 35 : - 330 : 2 . 2 cm ) ( - 85 : 3 . 4 cm ) arc ( - 85 : 25 : 3 . 4 cm ) ( 85 : 2 . 4 cm ) ; ( - 85 : 2 . 4 cm ) ( - 85 : 2 . 4 cm ) arc ( - 85 : - 330 : 2 . 8 cm ) ( - 85 : 2 . 8 cm ) arc ( - 35 : - 330 : 2 . 2 cm ) ; ( 150 : 2 cm ) circle ( 1 mm ) ; ( - 30 : 2 cm ) circle ( 1 mm ) ; ( 0 , 2 ) circle ( 1 mm ) ; ( 0 , - 2 ) circle ( 1 mm ) ; ( 150 : 2 cm ) circle ( 1 mm ) ; at ( 150 : 2 . 5 cm ) @ xmath162 ; ( 0 , 0 ) circle ( 1 mm ) ; at ( 0 , 0 ) @ xmath35 ; ( 0 , 2 ) ( 0 , 0 . 0 ) ;( 90 : - 90 : 3 . 4 cm ) ( 0 , - 1 ) ; at ( 0 , 1 . 0 ) @ xmath163 ; at ( 0 , - 1 . 6 ) @ xmath164 ; at ( 0 , 1 . 1 ) [ font = ] @ xmath168 ; at ( 30 : 1 . 6 cm ) @ xmath156 ; at ( - 30 : 2 . 6 cm ) @ xmath157 ; ( - 85 : 2 cm ) ( - 30 : 1 . 6 cm ) ; ( 30 : 2 cm ) ( 120 : 2 cm ) ; ( 90 : - 90 : 3 cm ) ( - 30 : 2 cm ) ; at ( - 30 : 3 cm ) [ font = ] @ xmath167 ; ( - 25 : 3 . 4 cm ) ( - 85 : 3 . 4 cm ) arc ( - 25 : 85 : 3 . 4 cm ) ( 30 : 3 . 2 cm ) arc ( 35 : 35 : 2 . 2 cm ) ; ( - 115 : 2 . 2 cm ) arc ( - 115 : - 35 : 2 . 2 cm ) ( - 115 : 2 . 2 cm ) arc ( - 115 : 35 : 2. 8 cm ) ( 30 : 2 . 5 cm ) ; ( 30 : 2 cm ) circle ( 1 mm ) ; ( - 30 : 2 cm ) circle ( 1 mm ) ; ( 0 , 2 ) circle ( 1 mm ) ; ( 0 , - 2 ) circle ( 1 mm ) ; ( 150 : 2 cm ) circle ( 1 mm ) ; ; ( 30 : 2 . 5 cm ) @ xmath162 ; [ note : earringproof ] let @ xmath6 be an arc of minimum maximum length . any object placed in the arc of @ xmath6 is safe . let @ xmath169 be the set of earrings with arc equal to that of @ xmath6 . since they have the same length , we refer to this as the arc of @ xmath169 , or the _ _ arc _ . let the first clasp of every earring in @ xmath169 be @ xmath163 , and the second clasp of each earrings in @ xmath169 be @ xmath164 . because the earrings in @ xmath169 have arcs of minimum length , any clasp @ xmath170 has a lock @ x##math171 that is not in the critical arc . ( that is , @ xmath172 = @ xmath173 . ) we must show that a segment not in the critical arc is safe ; and that a segment @ xmath13 is safe if the segment @ xmath153 has 2 - connectivity . for an isolated segment @ xmath13 in the critical arc , let @ xmath156 and @ xmath157 ( @ xmath174 ) be the anchors that connect the segments . we prove that there are exactly 2 distinct vertex - disjoint paths between @ xmath156 and @ xmath157 in @ xmath152 ; this suffices to prove 2 - connectivity . we consider several cases , depending on the links that connect @ xmath156 and @ xmath157 . the [ fig : earringproof ] illustrates these cases . if @ xmath156 and @ xmath157 are both in the same earring @ xmath58 , it is possible to find 2 vertex - disjoint paths between them in @ xmath153 . the first path is taken from @xmath175 to @ xmath176 is the clasp @ xmath35 . the second clasp is also contained in the clasp @ xmath58 ( an clasp is contained in @ xmath177 , but we can never find such a clasp . ) finally , @ xmath156 and @ xmath157 are clasps of two earrings . we have three possibilities : either @ xmath156 and @ xmath157 are clasp of earrings in @ xmath169 , either are ( or not both ) , or both are . 1 . we first assume that both @ xmath156 and @ xmath157 are clasp of earrings in @ xmath169 . let @ xmath156 be a clasp of @ xmath166 , and @ xmath157 a clasp of @ xmath167 . the first path is from @ xmath157 to @ xmath163 through @ xmath167 , and then continues in the same path from @ xmath163 to @ xmath156 . the second path is from @ xmath157 to @ x##math164 clockwise along the critical arc , and from @ xmath164 to @ xmath156 through @ xmath166 . it is easy to see that these paths are internally vertex - independent . . . now , that neither @ xmath156 nor @ xmath157 is a clasp of an edge of @ xmath169 . let @ xmath156 be a clasp of @ xmath166 , and @ xmath157 be a clasp of @ xmath167 . the critical path we have follows the critical arc , from @ xmath157 to @ xmath164 ( the last vertex of the critical arc ) , from @ xmath164 to @ xmath163 through @ xmath165 , and then clockwise through the critical arc from @ xmath163 to @ xmath156 . the vertices of this path are all either @ xmath6 or on the critical arc . let @ xmath178 be a clasp of @ xmath166 or on the critical arc , and @ xmath179 be a full clasp of @ xmath##167 ##4 in the critical arc . the following path runs from @ xmath156 to @ xmath178 through @ xmath166 , from @ xmath180 to @ xmath181 through the vertex @ xmath35 in the critical arc , and from @ xmath179 to @ xmath157 through @ xmath167 . internal vertices of this path are in @ xmath182 , and in @ xmath35 , but not outside of the critical arc ( since one of @ xmath178 and @ xmath179 is in the critical arc ) . therefore , we have two non - trivial paths from @ xmath156 to @ xmath157 . first , we have the case that each one of @ xmath183 is a clasp of an earring of @ xmath169 . then @ xmath156 is a clasp of @ xmath168 , and @ xmath157 is a clasp of @ xmath184 ; the second case ( where @ xmath185 and @ xmath186 are added , and omitted , andfigure [ 1 : earringproof ] shows the algorithm . ) let @ xmath181 be the index of a vertex of @ xmath167 outside the critical arc . the first path is from @ xmath157 to @ xmath164 through the critical arc , and continues from @ xmath164 to @ xmath156 through @ xmath166 . the second path is from @ xmath157 to @ xmath179 through @ xmath167 , and from @ xmath179 to @ xmath156 , through @ xmath35 . note that the first part of this path leaves the critical arc at @ xmath163 , and continues through the arc until @ xmath156 . internal vertices of the first path that belong in @ xmath35 are on the critical arc , but have index less than @ xmath175 . internal vertices of the second path that belong to @ xmath35 are either not on the critical arc , or have index between @ xmath163 and @ xmath156 . therefore , the two paths are not edge - independent . we can alsoour algorithm to find a non - trivial cycle of good density , by theorem [ thm : cycle ] : _ let @ xmath2 be an @ xmath1 - free graph with edge - costs and terminal weights , and at most @ xmath1 terminals . there is a polynomial - time algorithm to find a non - trivial cycle @ xmath136 in @ xmath2 such that @ xmath137 . _ theorem [ thm : cycle ] let @ xmath2 be a graph with @ xmath32 terminals and density @ xmath146 ; we have a polynomial - time algorithm that either finds a cycle in @ xmath2 of density less than @ xmath146 , or a large subgraph @ xmath42 of @ xmath2 that contains all @ xmath32 terminals . in the latter case , we can recurse through @ xmath42 until we can find a cycle of density at most @ xmath146 . we can find , in @ xmath187 ##1 , a good - density cycle @ xmath35 in @ xmath2 . by theorem [ g : cycleexists ] , @ xmat##h35 has density at most @ xmath146 , because the highest - density _ non - trivial _ graph has at most this density . if @ xmath35 contains at least 2 terminals , we are correct . otherwise , @ xmath35 contains only one terminal @ xmath28 . since @ xmath2 contains at least 2 terminals , there must be at least one terminal of @ xmath35 . let @ xmath28 be the origin of this cycle @ xmath35 , and @ xmath6 the earring of minimum arc length . by theorem [ 1 : earringproof ] , any segment of the graph of @ xmath6 is connected . let @ xmath13 be such a segment ; since @ xmath28 was chosen as the origin , @ xmath28 is also the exit vertex of @ xmath13 . as @ xmath28 is the only terminal of @ xmath35 , @ xmath13 contains 2 terminals , and therefore , the cycle @ xmath188 is simply - connected , and contains only @ xmath32 instead of @ xmath2 . the proof above also shows that if @ xmath##2 is minimally 2 - connected on its terminals ( that is , @ xmath2 has no 2 - connected directed subgraph containing all its terminals ) , the cycle of @ xmath2 is non - trivial . ( if a cycle has 1 or 2 terminals , it has a safe segment containing no vertices , which can be deleted ; this is the problem . ) therefore , given a graph that _ is _ minimally 2 - connected on its terminals , finding a minimum - density non - trivial cycle is equivalent to finding a minimum - density cycle , and this can be done exactly in polynomial time . this suggests a simple solution for the problem : given a graph that is _ minimally 2 - connected on its terminals , add edges and vertices until the graph is minimally 2 - connected on the terminals , and then find a minimum - density cycle . as mentioned above , this gives a cycle of density strictly less than that of the input graph , but this may not be the minimum - density cycle of the input graph . for instance , there exist instances where the minimum - density cycle contains edges of the safe segment @ xmath13 that might be deleted by this algorithm . in this case , we prove that [ thm : avekv ] . weare given a graph @ xmath2 and @ xmath3 , a set of at least @ xmath0 terminals . then , each terminal in @ xmath2 has 2 vertex - disjoint neighbors to the root @ xmath39 of total cost at most @ xmath67 . let @ xmath32 be the number of terminals in @ xmath2 , and @ xmath189 the total cost ; @ xmath190 is the size of @ xmath2 . we have an algorithm that finds a subgraph @ xmath6 of @ xmath2 that has at most @ xmath0 terminals , each of which is 2 - connected to the root , and of equal - length @ xmath191 . we either find @ xmath192 , or the general solution of finding the entire graph @ xmath2 suffices . the first stage of our algorithm proceeds by maintaining a set of 2 - connected subgraphs that we call _ cluster _ , and by generating low - density clusters that join clusters of similar size to the larger ones . ( the size of the cluster @ xmath136 , determined by @ xmath19##3 , ( ( 1 ) the number of nodes it contains . ) nodes are divided into _ tiers _ _ weight ; so @ xmath95 contains clusters with density at most @ xmath194 and less than @ xmath102 . therefore , every terminal is a small cluster in tier ##s . we say a cycle is _ good _ if it has weight at most @ xmath0 , and _ small _ otherwise . the algorithm stops when all terminals are in large clusters . we now call the nodes mergeclusters ( see next section ) . to understand this , let @ xmath144 be the quantity @ xmath195 . we say that a cycle is _ good _ if it has density at most @ xmath144 ; that is , all cycles have density at most @ xmath196 times the size of the entire graph . : + for ( tier @ xmath95 in @ xmath197 ) : : + if ( @ xmath198 ) : + every cycle has weight : + else : + mark all terminals and non - terminals + for ( each _ 2 - > cluster @ xmath136 in tier @ xmath9##5 ) else : + add an ( dummy ) edge @ xmath199 to @ xmath2 of weight @ xmath193 + add ( dummy ) edges of weight 0 from @ xmath199 to two ( dummy ) adjacent vertices of @ xmath136 + if ( @ xmath2 is a non - terminal cluster @ xmath35 of density and weight @ xmath144 + @ xmath2 ) : + let @ xmath200 count the other clusters that form a terminal * or an edge * of @ xmath35 . + ( assume that the terminals in @ xmath35 belong to a tier of @ xmath201 . ) + create a new cluster @ xmath202 ( of a higher weight ) by adding the clusters @ xmath203 + @ xmath204 + if ( @ xmath198 ) : + mark all terminals in @ xmath202 as non - terminals + else : + mark all ( dummy ) edges in @ xmath202 and the associated ( dummy ) edges . we will comment on the main features of this algorithm and our implementation before presenting the details of the2 . 1 . in iteration @ xmath95 , the terminals belong to tier @ xmath95 clusters . they are 2 - connected subgraphs of @ xmath2 , and by using cycles to merge clusters , we achieve 2 - connectivity as the clusters become connected . 2 . when a cycle @ xmath35 is used to merge clusters , all small clusters that contain an edge of @ xmath35 ( regardless of their size ) are merged to form the new cycle . therefore , at any stage of the algorithm , all very small clusters are 2 - connected . large clusters , on the other hand , are _ _ _ ; even if they intersect a good cycle @ xmath35 , they are not merged with other nodes on @ xmath35 . thus , at any time , an edge may appear in two large clusters and belong to a smaller cluster . 3 . in iteration @ xmath95 of mergeclusters , the density of a cycle @ xmath35 is only limited by its cost and the weight of nodes in @ xmath35 corresponding to tier @ xmath95 clusters . very small clusters of other ( lower or higher ) tiers might be merged using @xmath35 , we will _ _ _ use their resources to pay for the maintenance of @ xmath35 . 0 . the @ xmath95th iteration ends when all good cycles can be found using the remaining tier @ xmath95 ##s . at this point , there will be many nodes remaining that correspond to clusters which are not able to merge clusters of higher density . therefore , our choice of @ xmath144 ( which limits the density of good cycles ) is such that we can limit the number of nodes that are ` ` left out ' ' in this fashion . therefore , when the algorithm terminates , most terminals remain in large clusters . by limiting the density of good cycles , we can find a solution to the rooted @ xmath0 - @ xmath1vc problem of bounded density . because we can use clusters of bounded density to merge clusters , an analysis similar to that of @ xcite and @ xcite shows that every large cluster has density at most @ xmath205 . we first use this analysis , but it does not attempt to prove theorem [ 1 : avekv ] . a more detailed analysis shows that there is at least one large cluster of density at most @xmath206 ; this allows us to prove the last theorem . we now also show that mergeclusters exhibit the desired properties . first , we make a series of statements which , together , show that when the algorithm terminates , all terminals are in all clusters , and all clusters are 2 - connected . [ prop : cluster ] throughout the algorithm , the graph @ xmath2 is always 2 - connected . the weight of a cluster is at most the number of vertices it contains . the only structural changes to @ xmath2 occur when new vertices are added to terminals ; they are added with respect to two existing vertices of @ xmath2 . this preserves 2 - connectivity , as does deleting these vertices with the new edges . to see that the second claim is true , observe that if a terminal contributes weight to a cluster , it is always in that cluster . a terminal may be in multiple clusters , but it contributes to the weight of exactly one cluster . we use the following simple formula in terms of 2 - connectivity ; the proof is straightforward , and hence fast . [ prop : shareedge ] let @ xmath207 and @ xmath208 be @ xmath1 - connected subgraphs of a graph@ xmath5 implies that @ xmath209 . [ the cluster @ xmath210 is @ xmath1 - connected . [ prop : clusters2conn ] the clusters formed by mergeclusters are all @ xmath1 - connected . let @ xmath202 be the cluster formed by using the cycle @ xmath35 to create clusters @ xmath200 . the vertices of the cycle @ xmath35 form a 2 - connected subgraph of @ xmath2 , and we have that thus @ xmath211 is 2 - connected by induction . further , @ xmath35 contains at least 2 vertices of . @ xmath211 may be a singleton vertex ( for example , if we are in tier 0 ) , but being a singleton does not imply 2 - connected . ] , so we can use induction and the [ prop : shareedge ] construction : we have @ xmath212 is 2 - connected by induction , and @ xmath35 contains 2 vertices of @ xmath213 , and @ xmath214 is 2 - connected . suppose that we have that @ xmath215 is 2 - connected , and@ xmath35 ( and hence @ xmath202 ) will contain the terminal and the corresponding associated edges . however , each other node with the 2 associated edges is an ear of @ xmath202 ; removing them makes @ xmath202 non - connected . [ lem : fewleftbehind ] the terminal weight of the nodes in tier @ xmath95 that are then merged to larger clusters of higher tiers is at most @ xmath216 . assume this is not true ; this means that mergeclusters could find many more nodes of density at most @ xmath144 than the very small tier @ xmath95 clusters . suppose the computational cost of finding the edges is at most @ xmath189 , and the total of terminal weights is at most @ xmath216 ; this means that the density of the network ( using the dummy terminals ) is at most @ xmath217 . however , using [ var : cycleexists ] , the graph would only contain a single non - empty node , and thus the merge process would not be terminated . [ cor : weightlargeclusters ] when the first mergecl##usters ##et , the total number of such clusters is at least @ xmath218 . each terminal not in a large cluster corresponds to the weight of a cluster that has not merged with others to form a cluster of a larger tier . the previous theorem says that the total number of such terminals in any cluster is at least @ xmath219 ; since there are @ xmath220 terminals , the total number of terminals not in such clusters is less than @ xmath221 . so far , we have shown that many graphs form large clusters , many of which are 2 - connected , but we have not known about the density of these clusters . the following lemma says that if we can find a large cluster of good density , we can find a solution to the @ xmath0 - @ xmath1vc problem of good density . [ 1 : 1 ] let @ xmath202 be a large cluster formed by mergeclusters . if @ xmath202 has density at least @ xmath222 , we can find a graph @ xmath223 with at least @ xmath0 terminals , each of which is @ xmath1 - connected to @ x##math39 , of total weight at most @ xmath224 . let @ xmath200 be the clusters belonging to each @ xmath202 in order of the root @ xmath35 that joins them ; then @ xmath211 is a new cluster , of weight at most @ xmath0 . a simple mathematical proof shows that there is a single segment of @ xmath211s with equal weight between @ xmath0 and @ xmath225 , and that the cost of the merging of @ xmath35 between these clusters , together with the weight of the clusters themselves , is at most @ xmath226 . let @ xmath227 be the ` ` first ' ' terminal of this segment , and @ xmath228 the ` ` second ' ' . let @ xmath28 and @ xmath229 be the terminals of @ xmath227 and @ xmath228 respectively . connect vertices of @ xmath28 and @ xmath229 to the root @ xmath39 by two self - intersecting edges ; the cost of this step is at most @ xmath230 . (we showed that every vertex could be 2 - connected to @ xmath39 using shortest paths of cost at most @ xmath67 . ) the graph @ xmath223 thus constructed has at most @ xmath0 terminals , and has cost at most @ xmath231 . we showed that every vertex @ xmath232 of @ xmath223 is 2 - connected to @ xmath39 ; this is our proof . let @ xmath232 be an empty component of @ xmath223 ; then there exists a 2 - link @ xmath131 which , when deleted , separates @ xmath232 from @ xmath39 . both @ xmath28 and @ xmath229 are 2 - connected to @ xmath39 , and therefore neither is in the same direction as @ xmath232 in @ xmath233 . however , we have deleted vertex - disjoint paths @ xmath234 and @ xmath235 in @ xmath223 from @ xmath232 to @ xmath28 and @ xmath229 respectively ; deleting @xmath131 can also construct @ xmath232 from vertices @ xmath28 and @ xmath229 , which is a contradiction . the graphs @ xmath234 and @ xmath235 are easy to construct ; let @ xmath211 be the path to @ xmath232 . the graph @ xmath35 has a path from vertex @ xmath236 to @ xmath237 , and a ( vertex - connected ) path from @ xmath238 to @ xmath239 . replacing these paths with paths from @ xmath240 to @ xmath28 in @ xmath227 and @ xmath241 to @ xmath229 in @ xmath228 gives two vertex - connected paths @ xmath242 from @ xmath243 to @ xmath28 and @ xmath244 from @ xmath245 to @ xmath229 . since @ xmath211 is vertex - connected , we can construct vertex - connected paths from @ xmath232 to @ xmat##h243 and @ xmath245 , which gives us the shortest paths @ xmath234 and @ xmath235 . do not be in any cluster @ xmath211 . in this case , @ xmath234 is formed by two paths of @ xmath35 from @ xmath232 to @ xmath237 , and then a path from @ xmath240 to @ xmath28 ; @ xmath235 is formed . . ] we now present the tighter analysis of edges compared to earlier . the main difference between the tighter and tighter analysis is in the way we bound edge costs . in the former , each large cluster pays for its edges separately , using the fact that the edges used have density at most @ xmath246 . in the latter , we crucially use the fact that all clusters which share edges are merged . roughly speaking , because small clusters are edge - disjoint , the average density of large clusters must be equal to the density of the input graph @ xmath2 . once an edge is in a large cluster , we can no longer use the edge - disjointness argument . we must pay for these edges ., and we can reduce this cost . first , the last theorem allows us to show that a given cluster has cost at most @ xmath205 . [ see : tiercost ] for a graph @ xmath202 created by mergeclusters during iteration @ xmath95 , the total cost of edges in @ xmath202 is at most @ xmath247 . we prove this theorem by induction on the number of edges in the graph . let @ xmath248 be the set of clusters created by the algorithm @ xmath35 to tier @ xmath202 . let @ xmath249 be the set of edges in @ xmath248 of tier @ xmath95 , and @ xmath250 of @ xmath251 . ( @ xmath250 contains clusters of size 2 or greater than @ xmath95 that contain an edge of @ xmath35 . ) the cost of edges in @ xmath202 is at most the sum of : the cost of @ xmath35 , the cost of @ xmath249 , and the cost of @ xmath25##0 . since all clusters in @ xmath250 have been formed during iteration @ xmath95 or before , and are larger than @ xmath202 , we can use induction to show that the cost of edges in @ xmath250 is at most @ xmath252 . all clusters in @ xmath249 are of size @ xmath95 , and so must have been formed before iteration @ xmath95 ( the cluster formed during iteration @ xmath95 is of a strictly greater size ) , so we use induction to bound the cost of edges in @ xmath249 by @ xmath253 . however , because @ xmath35 is a good - density cluster , and the edges of tier @ xmath95 contribute to calculating the cost of @ xmath35 , the cost of @ xmath35 is at most @ xmath254 . therefore , the total cost of edges in @ xmath202 is at most @ xmath255 . let @ xmath202 be an arbitrary density cluster ; since we have only @ xmath220 vertices , the following statement implies that thecost of @ xmath202 is at most @ xmath256 . that is , the cost of @ xmath202 is at most @ xmath205 , and we can use this result together with theorem [ pl : pv ] to find a solution to the forest @ xmath0 - @ xmath1vc problem of cost at most @ xmath257 . this is the ` correct ' result , but this does not allow to prove theorem [ pl : avekv ] ; to prove the theorem , we would have to use a rooted cluster @ xmath202 of size @ xmath206 , instead of @ xmath205 . for the purpose of the more general analysis , we build the forest @ xmath258 from the clusters formed by mergeclusters . first , the vertex set of @ xmath258 is in @ xmath13 , the set of terminals , and @ xmath258 has no terminals . every time a cluster @ xmath202 is formed by merging @ xmath200 , we add a corresponding cluster @ xmath202 to the forest @ xmath25##8 , and assign cycles from @ xmath202 to vertices of @ xmath203 ; @ xmath202 is the cost of @ xmath259 . we also assign a cycle with a cost of @ xmath258 ; the cost of the cycle @ xmath202 is the cost of the cycle used to form @ xmath202 from @ xmath203 . we then look up trees as the algorithm proceeds ; the root of the tree corresponds to a cluster that has not yet become part of a larger cluster . the leaves of the tree correspond to vertices of @ xmath2 ; they all have cost 1 . therefore , any large cluster @ xmath202 formed during the algorithm is at the root of the tree ; we refer to this tree as @ xmath260 . for each large cluster @ xmath202 of mergeclusters , , such that @ xmath202 is of size @ xmath95 if @ xmath202 is formed during the @ xmath95 of mergeclusters . we now define the _ final - stage _ clusters of @ xmath202 : they are the size ofduring iteration @ xmath95 that became part of @ xmath202 . ( we include @ xmath202 itself in the definition of final - stage clusters ; even though @ xmath202 was created during iteration @ xmath95 of mergeclusters , it may contain other final - stage clusters . for example , during iteration @ xmath95 , we may merge the tier @ xmath95 clusters to form the cluster @ xmath136 of tier @ xmath261 . then , if we find a high - density cluster @ xmath35 that contains an element of @ xmath136 , @ xmath136 will merge with the other clusters of @ xmath35 . ) the _ penultimate _ clusters of @ xmath202 are those clusters that formed just before the end of iteration @ xmath95 and became a part of @ xmath202 . equivalently , the penultimate clusters are those formed during iteration @ xmath95 that are the _ clusters of @ xmath260 of final - stage clusters . figure 1 shows the definitions of final - stage and penultimate clusters . such a definition could be usedif , in iteration @ xmath262 , 4 clusters of this tier merge to form @ xmath263 , a cluster of tier @ xmath264 . if , in iteration @ xmath95 , both @ xmath6 and @ xmath265 merged to form @ xmath266 . we then find a good cycle containing @ xmath267 and @ xmath2 ; @ xmath266 shares an edge of this cycle , and these three clusters are merged to form @ xmath17 . note that the weight of this cycle is calculated for the by the weights of @ xmath267 and @ xmath2 ; ; @ xmath266 is a tier @ xmath264 cluster , and therefore its weight is not included in the density calculation . next , we find a good cycle paid for containing @ xmath268 and @ xmath35 ; since @ xmath17 and @ xmath263 share edges with this cycle , they also merge to form the large cluster @ xmath202 . = [ circle , circle , inner sep = 0pt , outer sep = 6 ##pt ] ; = [ circle ,} , for width = 0pt , for width = [ width ] ; = [ font = ] ; \ ( a ) at ( 4 , 5 . 5 ) [ high ] @ xmath202 ; \ ( b ) at ( 10 . 5 , 4 ) [ vertex ] @ xmath95 ; ( b ) at ( 10 . 5 , 4 ) [ vertex ] @ xmath269 ; ( c ) at ( 10 . 5 , 4 ) [ vertex ] @ xmath95 ; ( d ) at ( 10 . 5 , 4 ) [ vertex ] @ xmath264 ; ( e ) ( f ) ( c ) ; ( f ) ( y ) ( d ) ; at ( 3 . 5 , 4 ) @ xmath268 ; at ( 9 . 7 , 4 ) @ xmath17 ; at ( 9 . 7 , 4 ) @ xmath35 ; at ( 9 . 7 , 4 ) @ xmath263 ; \ ( e ) at ( 3 , 2 . 5 ) [ vertex ] @ xmath95 ; ( f ) at ( 3 . 5 , 2 . 5 ) [ vertex ] @ xmath264 ; ( g ) at (( , 2 . 5 ) [ vertex ] @ xmath95 ; ( e ) ( b ) ( f ) ; ( e ) ( g ) ; at ( 3 . 8 , 2 . 5 ) @ xmath267 ; at ( 4 . 8 , 2 . 5 ) @ xmath266 ; at ( 5 . 35 , 2 . 7 ) @ xmath2 ; \ ( g ) at ( 5 . 9 , 1 ) [ vertex ] @ xmath95 ; ( e ) at ( 5 . 35 , 1 ) [ vertex ] @ xmath95 ; ( e ) ( g ) ( j ) ; at ( 4 . 8 , 1 . 3 ) @ xmath6 ; at ( 5 . 9 , 1 . 3 ) @ xmath265 ; at ( c ) [ vertex ] ; at ( x ) [ vertex ] ; at ( c ) [ vertex ] ; an edge of a large cluster @ xmath202 is said to be a _ _ edges _ if it is included in a cluster @ xmath35 that produces a higher - level cluster of @ xmath202 . all the edges of @ xmath202 are a _ _ edges_ ; note that the final edge is in some larger cluster of @ xmath202 . we define the _ _ cost _ of @ xmath202 to be the sum of the costs of its final edges , and _ _ final cost _ to be the sum of the costs of its final edges ; therefore , the cost of @ xmath202 is the sum of its final and penultimate costs . we define the final costs and penultimate costs separately . note that an edge is the final edge of a larger cluster @ xmath202 if it is used by mergeclusters to create a cycle @ xmath35 , the final iteration during which @ xmath202 is formed . the way we can define the cost of final cycles means that the cost of any such cycle is at most @ xmath144 times the weight of clusters already in the cycle , and each cluster does not add to the weight of more than one cycle in each iteration . ( this is also the case of lemma [ lem : tiercost ] . ) we use this idea in the following way . [ lem : cost ] the final cost of any large cycle @ xmath202 is at most @ xmat##h270 , where @ xmath271 is the weight of @ xmath202 . let @ xmath202 be an infinitely large cluster . in the case of the cluster @ xmath260 , we associated with each vertex of @ xmath260 the sum of the vertices required to create the new cluster . to bound the total computational cost of @ xmath202 , we must consider the sum of the costs of vertices of @ xmath260 associated with final - stage clusters . the weight of @ xmath202 , @ xmath271 is at most the sum of the costs of the corresponding tier @ xmath95 clusters that become a part of @ xmath202 . then , it follows to show that the sum of the costs of vertices of @ xmath260 associated with final - stage clusters is at most @ xmath144 , the sum of the weights of @ xmath202 , penultimate tier @ xmath95 clusters . ( note that a tier @ xmath95 cluster must have been created prior to creating @ xmath95 , and that it need not itself be a final - stage( . ) this method was used to construct a final - stage cluster @ xmath136 only if the cost was at most @ xmath144 times the sum of weights of the penultimate tier @ xmath95 clusters that became a part of @ xmath136 . ( these clusters also become a part of @ xmath136 , but they do not contribute significantly to the density factor . ) therefore , if @ xmath136 is a vertex of @ xmath260 corresponding to a final - stage cluster , the cost of @ xmath136 is at most @ xmath144 times the sum of the weights of the tier @ xmath95 cluster children in @ xmath260 . but @ xmath260 is a tree , and so each vertex corresponding to a penultimate tier @ xmath95 cluster has more than one weight . that is , the parent of a given cluster pays for each one final - stage cluster . therefore , the sum of the costs of vertices associated with final - stage clusters is at most @ xmath144 times the sum of the weights of @ xmath202 and penultimate tier @ xmath95 clusters, and that the final edge of @ xmath202 is at iteration @ xmath270 . [ lem : 1 ] if @ xmath272 and @ xmath273 are two large clusters of the same type , no edge is a penultimate edge of both @ xmath272 and @ xmath273 . suppose , by way of induction , that the edge @ xmath85 is a penultimate edge of both @ xmath272 and @ xmath273 , which are large clusters of each @ xmath95 . let @ xmath274 ( respectively @ xmath275 ) be a penultimate edge of @ xmath272 ( resp . @ xmath273 ) and @ xmath85 . as penultimate edges , both @ xmath274 and @ xmath275 are merged at iteration @ xmath95 . but until iteration @ xmath95 , each is part of a large cluster , and two large clusters can not share an edge without being merged . therefore , @ xmath274 and @ xmath275 must have been merged , so they do not belong to distinct large clusters, yielding the desired result . [ thm : goodlargecluster ] after mergeclusters merge , at least 1 large cluster has density at most @ xmath206 . we define the _ penultimate cost _ of a large cluster to be the ratio of its penultimate cost to its weight . consider the total penultimate costs of all large clusters : for any @ xmath95 , each edge @ xmath276 can be a penultimate edge of at least 1 large cluster of any @ xmath95 . this implies that each edge can be a penultimate edge of at most @ xmath220 clusters . therefore , the sum of penultimate costs of all large clusters is at most @ xmath277 . therefore , the total weight of all large clusters is at least @ xmath278 . therefore , the ( weighted ) average penultimate cost of large clusters is at most @ xmath279 , and hence there is a single cluster @ xmath202 of average density at most @ xmath280 . the penultimate cost of @ xmath202 is , therefore , at most @ xmath281 , and from the [ lem : final ] , the penultimate cost of@ xmath202 is at most @ xmath270 . therefore , the density of @ xmath202 is at most @ xmath282 . theorem [ cm : goodlargecluster ] and lemma [ cm : math ] together show that we can find a solution to the rooted @ xmath0 - @ xmath1vc problem of density at most @ xmath191 . this is our proof of theorem [ cm : avekv ] . we list the following related problems : * can the approximation ratio for the @ xmath0 - @ xmath1vc problem be improved from the rooted @ xmath44 to @ xmath283 or better ? * the constraints on @ xmath32 to obtain rooted @ xmath284 could be useful . if not , can we improve the approximation ratio for the easier @ xmath0 - @ xmath1ec problem ? * can we improve approximation ratios for the @ xmath0 - @ xmath8vc and @ xmath0 - @ xmath8ec problems for @ xmath285 ? in general , efficient algorithms are needed for problems where the- connectivity is required to be greater than 1 , but there has been more work with higher non - trivial graphs . * for a 2 - connected graph of density @ xmath146 with some vertices selected as vertices , we assume that it contains a non - trivial cycle with density at most @ xmath146 , and give an algorithm to find such a cycle . we have also found an @ xmath37 - approximation for the problem of finding a high - density non - trivial cycle . is there a two - factor approximation for this problem ? can it be solved _ _ _ in polynomial time ? b . awerbuch , a . azar , a . blum and a . vempala . _ approximation guarantees for minimum weight @ xmath0 - trees and garbage - collecting algorithms . , 10 ( 4 ) : 254262 , 1999 . preliminary results in _ proc . of acm stoc _ , 1995 . j . x . goemans and j . p . williamson . the k - approximation theorem for approximation algorithms and its applications to other optimization problems . in j . s . hochbaum , editor , _ approximation algorithms for np - complete problems _ . pws publishing company , 1996 .