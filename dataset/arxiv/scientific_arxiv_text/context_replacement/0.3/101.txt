monte carlo methods @ xcite began about sixty years ago with the ability to evaluate numerical solutions for various classical problems . these methods evolved and were applied early to quantum problems , thus allowing in reach exact numerical solutions to non - trivial quantum problems @ xcite . many extensions of these methods exist , including the slowing of near - transitions and allowing to work directly in the half imaginary time of @ xcite . in recent years , interest in methods that work in the canonical ensemble with global updates yet with access to green functions has intensified @ xcite . however , a method that works well for one given hamiltonian often needs significant modifications for application . for example , the presence of a cross - site ring ##ing term in the bosonic hubbard model requires special consideration for a treatment by the power series expansion algorithm @ xcite , as well as by the wordline algorithm @ xcite . this can result in significant delays . it is , however , possible to have at ' s , an algorithm that can be applied to a very large class of hamiltonians without requiring significant modifications . in a recent study @ xcite , the stochastic green function ( sgf ) algorithm was presented , which achieved this goal . the algorithm can be applied to any lattice hamiltonian of the form @xmath3 where @ xmath1 is diagonal in the standard real number basis and @ xmath2 has only positive matrix elements . this includes all kinds of systems that can be treated by the methods presented in fig . @ xcite , for example bose - hubbard models with or without a nucleus , bose - fermi mixtures in one dimension , quantum models . . . only particular hamiltonians for which the off - diagonal matrix @ xmath2 is non - trivial ( the s - matrix is zero ) are easily solved , such as the bose - hubbard model with ring structure @ xcite , or multi - species hamiltonians for which a single system can be transformed into another one ( see eq . ( [ twospecies ] ) and fig . [ energy ] and [ momentum ] for a general example ) . systems for which it is not possible to solve a system in which @ xmath1 is diagonal and @ xmath2 has only positive matrix elements are said to have a ` ` boundary problem ' ' , which usually arises with fermionic and frustrated systems . unlike other qmc methods , the sgf algorithm does not solve this problem . the algorithm allows to measure several systems of interest , such as thenamely , the energy density , the compressibility , mass - energy ratio , . . . after which the system is sampled and gives access to the superfluid ##s . equal - time n - dimensional green curves are probably the most important properties that can be measured by the algorithm , thus giving rise to momentum transfer curves which allow for comparisons with experiments . more details on measurements are given at ref . @ xcite . in addition the algorithm has the property of being easy to code , due in part to the simple update scheme in which all moves are accepted with a probability of 1 . because of such generality and simplicity , the algorithm does suffer from a reduced efficiency , compared to other algorithms in situations where they cannot be simulated . the aim of this paper is to develop a ` ` directed ' ' update scheme that ( i ) keeps the simplicity and generality of the original sgf algorithm , and ( ii ) enhances the efficiency by improving the performance over the entire time interval . since the sgf algorithm is not intended to compete with the performance of other algorithms , the improvment resulting from the directed update scheme is useful ( see section v ) . but what proves the strength of the sgf method is that it allows to simulate hamiltonians that can only be treated asother methods exist that would require special developments ( see eq . ( [ twospecies ] ) for a concrete example ) . the paper is organized as follows : we introduce in section ii the parameters and definitions used in ref . @ xcite . in section iii , we present a description of the update scheme used in the original sgf algorithm , and show how to satisfy the balance . a description of the original update scheme is presented in section iv , which uses the directed updated scheme . in section v shows how to apply the new optimization parameters , and gives some details of the algorithm and a comparison with the original scheme . in this section , we introduce the definition of the ` ` green operator ' ' used in the sgf algorithm , and the corresponding partition function which is considered . although not recommended for reading this section , we refer the reader to ref . @ xcite for more information about the algorithm . as with qmc ##f , the sgf algorithm uses the partition function @ xmath4 the algorithm has the property of being in the same domain . in order to define the green operator , we first consider the ` ` normalized ' ' creation and annihilation operators , @ xmath5 where @ xmath6 and @xmath7 are the usual creation and annihilation operators of interest , and @ xmath8 is the green operator . from ( [ normalizedoperators ] ) one can show the following notation for the state @ xmath9 in the real valued representation , @ xmath10 with the particular notation @ xmath11 . appart from this notation , the operators @ xmath12 and @ xmath13 create a state @ xmath9 by simultaneously creating and annihilating one state , but they do not change the norm of the state . using the notation @ xmath14 to define the subsets of the states @ xmath15 and @ xmath16 with the restriction that all indices in subset @ xmath17 are different from the indices in subset @ xmath18 ( and all indices in each subset may be equal ) , we define the corresponding states @ xmath19 and @ xmath20 where @ xmath21 is a state that depends on the application of the operator @ xcite . in order to define the partition function ( [ partitionfunction ] ) , the corresponding partition function @ xmath22 is considered by breaking down the operator @xmath23 , and defining the green operator for the two parts , @ xmath24 defining the two green operators @ xmath25 and @ xmath26 , @ xmath27 and , for the real number system in which @ xmath1 is diagonal , the extended partition function takes the form @ xmath28 where the sum @ xmath29 implicitly runs over all pairs of states @ xmath30 . we will systematically use the labels @ xmath31 and @ xmath32 to denote the labels appearing on the left and the right of the green operator , and use the label @ xmath33 to denote the diagonal operator @ xmath34 . we will systematically denote by @ xmath35 and @ xmath36 the time indices of the @ xmath2 operators appearing on the left and the right of @ xmath19 . as a result , the extended partition function is a sum over all the states , each being represented by a set of time indices @ xmath37 and a set of labels @ xmath38 , @ xmath39 , @ xmath40 , @ xmath41 , @ xmath42 . the sum consistswhen creating those configurations , making use of the green operator . assuming that the green operator is acting on a @ xmath43 , one can ` ` destroy ' ' a @ xmath2 operator ( that is to say a @ xmath2 operator can be created in the operator string ) at the same time , thus creating a new state . , then it can be shifted to a different time . while shifting , any @ xmath2 operator created by the green operator is ` ` destroyed ' ' ( that is to say removed from the operator string ) . assuming a left ( or right ) move , creating an operator will update the state @ xmath44 ( or @ xmath41 ) , while destroying will update the state @ xmath41 ( or @ xmath44 ) . when a diagonal configuration of the green operator exists , @ xmath45 , then a configuration associated to the extended partition function ( [ extendedpartitionfunction ] ) , creating a state associated to the partition function ( [ partitionfunction ] ) . measurements can be taken when this occurs ( see ref . @ xcite for more on this ) . this example presents a simple update algorithm that meets the requirements of the anddetailed balance . before introducing the directed update , we start by simplifying the update scheme used in the original sgf algorithm . we will note in the following that a left move of the green operator is possible . in the original algorithm , the green operator @ xmath26 can choose to move if not to its right the @ xmath2 operator at time @ xmath43 . then a time shift @ xmath46 to the left is possible for the green operator with an equal distribution in the time @ xmath47 . if an operator is encountered while shifting the green operator , then the operator is destroyed and the move stops there . as a result , four possible situations will occur during the update : 1 . no creation , shift , no destruction . 2 . creation , shift , no destruction . 3 . no creation , shift , destruction . 4 . creation , shift , destruction . it appears that the first possibility ` ` no creation , no destruction ' ' is completely useless , since no change is possible in the operator itself . the idea is to get rid of this possibility by forcing the green operator to destroy the operator if no creation is possible . further simplification can be made by noting that the second possibility ` ` creation , destruction ' ' isis necessary for the ergodicity of the algorithm , and can be obtained by restricting the range of the time shift after having created the operator . suppose we replace the chosen update scheme by the following : we assume that the green operator is acting at time @ xmath43 and that the operator on its left is acting at time @ xmath35 . the green operator @ xmath26 chooses to create or not an operator on its left at time @ xmath43 . if creation is chosen , then a time shift @ xmath46 of the green operator is changed to the operator in the range @ xmath48 , with the probability distribution given below . if no creation is chosen , then the green operator is directly changed to the operator on its left at time @ xmath35 , and the operator is destroyed . as a result , two options need to be considered : 1 . creation , destruction . 2 . creation , destruction . the [ simplfiedupdatescheme ] contains the following organigram . figure 1 . b explains how detailed balance can be satisfied with this simplified update scheme . when generating the configurations according to the chosen update scheme , we need to generate the configurations from initial to final states with probability thatsee detailed balance . in this section we propose a choice for these probabilities , and for the corresponding discount rate . we denote the probability of the final ( final ) configuration by @ xmath49 ( @ xmath50 ) . we denote by @ xmath51 the probability of the transition from configuration @ xmath17 to configuration @ xmath52 , and by @ xmath53 the probability of the reverse transition . finally we denote by @ xmath54 the acceptance rate of the transition from @ xmath17 to @ xmath52 , and by @ xmath55 the acceptance rate of the reverse transition . the detailed balance can be written : @ xmath56 we will make use of the metropolis operator @ xcite , @ xmath57 with @ xmath58 we will use the ( non - primed ) notation for states and time indices to denote the ( final ) configuration . we consider first the case where a new state is created , an index is created to the right of the green operator in range @ xmath43 , and a new state is chosen . then a time index to the right is created for the green operator in the range @ xmath59 . this isalso to note that @ xmath60 and @ xmath61 correspond to the time indices of the values appearing on the left and the values of the green operator after the new operator has been inserted , that is to say at the point where the state change is to be made . thus we have @ xmath62 and @ xmath63 . the probability of the final configuration is the smallest weight appearing in the extended weight function ( [ extendedpartitionfunction ] ) : @ xmath64 the probability of the final configuration has the form : @ xmath65 it is convenient here to assume that the green operator has inserted to its right the value @ xmath66 , before being shifted from @ xmath61 to @ xmath67 . thus we have the probability @ xmath68 , @ xmath69 , @ xmath70 , and @ xmath71 . the probability @ xmath51 of the shift from the initial configuration to the final configuration times the probability @ xmath72 of a state change , times the probability @ xmath73 of a change , times the probability @ xmath74 to choosethe initial state @ xmath75 , is the probability @ xmath76 to replace the green operator by @ xmath77 , so that the states to the left and the right of the green operator at the moment of the transition are @ xmath78 and @ xmath79 : @ xmath80 the probability of the next transition is simply the probability @ xmath81 of a new state , times the probability of its creation , @ xmath82 : @ xmath83 \ ] ] from the above version of the sgf problem , we see that choosing the time shift with an exponential factor is a good solution , because it reduces the uncertainty involved in the probabilities of the initial ( [ initial ] ) and final ( [ final ] ) configurations , including the negative q factor . but a better normalization must be used first , since the time shift is always in the range @ xmath84 instead of @ xmath47 . the above solution is : @ xmath85 it is important to check that the above solution is correctly normalized and well - defined for a given value of @ xmath86 , the particular case @ xmath##87 corresponds to the normal distribution @ xmath88 ( note that @ xmath89 is not a natural distribution ) . for the system @ xmath74 to reach the optimal system @ xmath75 , the convenient solution is the same as in the previous paper : @ xmath90 putting everything together , the acceptance factor ( [ metropolis2 ] ) becomes @ xmath91 \ big [ 1 - 1 ^ { - ( \ tau _ r ^ \ prime - \ tau _ l ^ \ prime ) ( v _ r ^ \ prime - v _ l ^ \ prime ) } \ big ] } { v _ r ^ \ prime - v _ l ^ \ prime } , \ big { 1 } \ ] ] where we have used the notation @ xmath92 to show that this acceptance factor corresponds to a constant . it is also important for the remaining of this paper to note that @ xmath92 is defined as a quantity that depends on the initial configuration , and a quantity that depends on the final configuration . we consider here the case where the left move is chosen , and the move to the left of the green operator is chosen . this move corresponds to the inverse of the above ` `next , we ' ' move . next , the first acceptance factor @ xmath93 is obtained by inverting the acceptance factor @ xmath92 , exchanging the initial time @ xmath43 and initial time @ xmath67 , and switching the variables . now @ xmath94 has an equal time constant , so @ xmath35 and @ xmath36 do not need to be switched . we have @ xmath95 \ left [ [ - e ^ { - ( \ psi _ l - \ tau _ r ) ( v _ l - v _ r ) } \ right ] } \ \ & \ \ & \ frac { \ big \ langle \ psi _ r ^ \ prime \ big | \ hat \ mathcal t \ big | \ psi _ r ^ \ prime \ big \ rangle { ( \ rightarrow ^ \ prime ) } _ \ rightarrow ^ \ prime ( \ tau ^ \ prime ) } { \ hat \ langle \ psi _ r ^ \ prime \ big | \ hat \ mathcal t \ big \ mathcal g \ big | \ psi _ r ^ \ prime \ big \ rangle } , \ hat { \ }\ ] ] which is defined as a quantity that depends on the initial configuration , times a quantity that depends on the final configuration . we will use here the mathematical notation @ xmath96 , @ xmath97 , and @ xmath98 to denote respectively the parameters @ xmath99 , @ xmath100 , and @ xmath101 . as in r . @ xcite , we have some rules for the choice of the probability of choosing a left or right move , @ xmath72 and @ xmath102 , and the probabilities of choosing @ xmath73 and @ xmath103 . a good choice for those rules must be made in order to choose both moves , resulting in an appreciable improvement of the algorithm . for this reason , we define the acceptance factor @ xmath92 ( or @ xmath104 ) to be equal to the acceptance factor @ xmath93 ( or @ xmath105 ) . this allows to choose the parameters @ xmath73 and @ xmath103 , @ xmath106 and the acceptance factor @ .##math107 and @ xmath108 take the pair @ xmath109 with @ xmath110 , we can impose the acceptance factors @ xmath111 and @ xmath112 to be equal . this means @ xmath113 defining @ xmath114 , we are left with a single acceptance factor , @ xmath115 which is independent of the chosen direction , and independent of the nature of the decision ( creation and destruction ) . not all decisions can be accepted by making use of a linear reweighting , as explained in ref . the appendix on how to update random variables with the appropriate update function ( [ exponentialdistribution ] ) . although the above linear update scheme works , it turns out to have a low efficiency . this is because of the lack of ` ` directionality ' ' : the green operator has , in general , a probability of @ xmath116 to choose a left move or a right move . thus the green operator propagates along the operator path with a ` ` ' ##ard ' ' , with a diffusion - like effect . the linear creation and destruction rules correspond to the dynamics of the random variable . this suggests that the efficiency of the update schemecan be improved if one can force the green operator to move in the right direction for several steps . next section presents a modified version of the simplified update scheme , which attempts to control the mean length of the steps of the random walk , that is to say the total number of creations and changes in a given direction . the simplified directed update scheme can be considered analogous to the ` ` directed loop update ' ' used in the stochastic loop update algorithm @ xcite , which prevents a worm from moving backwards . however the connection should not be pushed too far . indeed the example of a worm whose head is evolving both in space and imaginary time accross vertices is shown in a loop picture . in such case , a creation ( or an destruction ) operator which is represented by the head of a worm is evolving only in space and imaginary time , while an annihilation ( or a destruction ) operator represented by the tail of the worm is at rest . the loop ends when the head of the worm bites the tail . such a loop picture is not obvious in the sgf algorithm : instead of single creation or destruction operators , it is the single creation operator of the green loop that is evolving only in imaginary time . this is a world##lines , thus introducing discontinuities . these discontinuities increase and decrease , resulting in imaginary time . all open points of the worldlines are localized in the same imaginary time interval . . it is simply not possible to update step by step a worm whose head is fixed in space and imaginary time until it bites its tail . we present in this article a directed update scheme which is obtained by modifying to the simplified update scheme , thus keeping the simplicity and simplicity of the original . assuming that the left arrow is chosen , the green operator chooses between replacing the move by a creation or a destruction . for a create ( or destroy ) an operator , the green operator can choose to keep moving in the same direction and destroy ( or create ) with a probability @ xmath117 ( or @ xmath118 ) , or to stop . if it stops moving , then a destruction ( or creation ) occurs , and the green operator can choose to keep moving and create ( or destroy ) with a probability @ xmath118 ( or @ xmath117 ) . . . and so on , until it decides to stop . if the last action of the move is a destruction , then a time delay is observed . the organigramis included in the [ directedupdatescheme ] . in order to achieve this balance , in addition to the acceptance factors @ xmath92 and @ xmath93 , we need to determine the acceptance factors of the moves @ xmath119 and @ xmath120 . we first consider the initial values of @ xmath92 and @ xmath93 obtained from the detailed balancing scheme . for @ xmath92 , the initial probability @ xmath51 has to be multiplied by the probability to stop the move after having destroyed , @ xmath121 . the previous probability @ xmath53 has to be multiplied by the probability to stop the move after being destroyed , @ xmath122 . we obtain for @ xmath92 and @ xmath93 the following result : @ xmath123 } { \ hat \ langle \ psi _ l \ big | \ hat \ mathcal g \ big | \ psi _ l \ big \ rangle p ( \ leftarrow ) \ _ \ leftarrow ^ \ dagger ( \ tau ) } \ \ & \ \ & \ frac { p ( \ rightarrow ^ \ dagger) \ big [ 1 - p _ \ rightarrow ^ \ prime ( \ tau ^ \ prime ) \ big ] \ big [ 1 - e ^ { - ( \ tau _ r ^ \ prime - \ tau _ l ^ \ prime ) ( v _ r ^ \ prime - v _ l ^ \ prime ) } \ big ] } { \ big [ 1 - p _ \ leftarrow ^ { kd } ( \ tau ^ \ prime ) \ big ] \ big ( v _ r ^ \ prime - v _ r ^ \ prime \ big ) } \ \ \ nonumber v _ \ leftarrow ^ \ & = & \ frac { \ big [ 1 - p _ \ rightarrow ^ { kd } ( \ tau ) \ big ] \ big ( v _ l - v _ r \ big ) } { - ( \ leftarrow ) \ big [ 1 - p _ \ leftarrow ^ \ prime ( \ tau ) \ big ] \ big [ 1 - e ^ { - ( \ tau _ r - \ tau _ r ) ( v _ l - v _ r ) } \ big ] } \ \ & \ = & \ frac { \ big \ langle \ tau _t ^ \ prime \ big | \ hat \ mathcal g \ big | \ psi _ r ^ \ prime \ big \ rangle p ( \ rightarrow ^ \ prime ) p _ \ rightarrow ^ \ dagger ( \ tau ^ \ prime ) } { \ hat \ langle \ psi _ r ^ \ prime \ big | \ hat \ mathcal g \ hat \ mathcal g \ big | \ psi _ r ^ \ prime \ big \ rangle \ big [ [ - p _ \ leftarrow ^ { dagger } ( \ tau ^ \ prime ) \ big ] } , \ hat { \ } \ ] ] we consider only the case where the green state is chosen , an operator is created on the left of the green operator , and a new state is created . then the operator on the right of the green operator is created . using the notation @ xmath124 to indicate the number of initial and final configurations , the sequence is the following 1 . @ xmath125 2 . @ xmath126 3 . @ xmath127 , where we have @ xmath128 , @ xmath129 , @ xmath130 , and @ xmat##h131 . the probability of the move from the initial configuration to the final configuration is the probability @ xmath72 to choose a left state , times the probability @ xmath73 to create an object in : @ xmath43 , times the probability @ xmath132 to choose the new state @ xmath133 , times the probability @ xmath134 to choose creating and destroying , times the probability @ xmath135 to choose the move after being destroyed : @ xmath136 \ ] ] the probability of the reverse move is not known : @ xmath137 \ ] ] it is important to note that , when choosing the new state @ xmath7 , the time @ xmath138 of the operator to the left of the red operator is equal to @ xmath35 , and the time @ xmath139 of the operator to the right of the green operator is equal to @ xmath43 . thus the acceptance probability takes the form @ xmath140 } { \ big \ langle \ psi _ r \ big | \ big \ mathcal { \ big | \ psi _ r \ big \ rangle } ( \ big##arrow ) p _ \ leftarrow ^ \ dagger ( \ prime ) } \ \ \ nonumber & \ \ & \ frac { e ^ { - \ big ( \ tau _ l ^ a - \ psi _ r ^ a \ big ) v _ r ^ a } p _ \ rightarrow ^ { kd } ( a ) } { e ^ { - \ big ( \ tau _ l ^ a - \ tau _ r ^ a \ big ) v _ r ^ a } p _ \ leftarrow ^ { kd } ( a ) } \ \ & \ \ & \ frac { \ big \ langle \ psi _ r ^ \ prime \ big | \ hat \ mathcal g \ big | \ psi _ r ^ \ prime \ big \ rangle t ( \ rightarrow ^ \ prime ) p _ \ rightarrow ^ \ dagger ( \ tau ^ \ prime ) } { \ hat \ langle \ psi _ l ^ \ prime \ big | \ hat \ mathcal g \ big \ mathcal g \ big | \ psi _ r ^ \ prime \ big \ rangle \ big [ ] - p _ \ leftarrow ^ { t } ( \ tau ^ \ prime) \ big ] } , \ big { aligned } \ ] ] and is defined as a quantity that depends on the initial configuration , times a quantity that depends on the intermediate configuration @ xmath7 , times a quantity that depends on the final configuration . it is convenient for the remaining of the paper to define the state acceptance probability , @ xmath141 we consider here the case where a left move is chosen , the operator on the left of the control line is created , and an operator is created on the right , and a new state is created . then a lower bound is applied . the sequence of steps is the following 1 . @ xmath125 2 . @ xmath142 3 . @ xmath127 , where we have @ xmath143 , and @ xmath144 . the probability of the change from the initial configuration to the final configuration is the probability @ xmath72 to choose the left move , times the probability @ xmath145 of no change , times the probability @ xmath146 to keep moving and create , times the probability @ xmath74 to choose the new state @ xmath75 , times the probability @ xmath121to see the move and time passed , consider the move @ xmath76 to move the following squares by @ xmath77 : @ xmath147p _ \ leftarrow ^ { k } ( a ) p _ \ leftarrow ( \ tau _ r ^ \ prime ) \ \ & \ times & \ big [ 1 - p _ \ leftarrow ^ { kd } ( \ tau ^ \ prime ) \ big ] p _ \ leftarrow ^ { r ^ \ prime r ^ \ prime } ( \ tau ^ \ prime - \ tau _ r ^ \ prime ) \ end { aligned } \ ] ] the probability of the reverse move is not known : @ xmath148p _ \ rightarrow ^ { kc } ( a ) p _ \ rightarrow ( \ tau _ r ) \ \ & \ times & \ big [ 1 - p _ \ rightarrow ^ { kd } ( \ tau ) \ big ] p _ \ rightarrow ^ { kc } ( \ tau _ r - \ tau ) \ end { aligned } \ ] ] the reverse probability takes the form @ xmath149 \ big ( v _ l - v _ r\ big ) } { - ( \ leftarrow ) \ big [ 1 - p _ \ leftarrow ^ \ dagger ( \ tau ) \ big ] \ big [ 1 - e ^ { - ( \ tau _ l - \ psi _ r ) ( v _ l - v _ r ) } \ big ] } \ \ \ nonumber & \ times & \ frac { \ big \ langle \ tau _ r ^ a \ big | \ big \ mathcal g \ hat \ mathcal t \ big | \ tau _ r ^ a \ big \ rangle p _ \ rightarrow ^ { kc } ( a ) } { \ big \ langle \ psi _ r ^ a \ big | \ big \ mathcal t \ hat \ mathcal g \ big | \ psi _ r ^ a \ big \ rangle p _ \ leftarrow ^ { kc } ( a ) } \ \ & \ times & \ frac { - ( \ rightarrow ^ \ prime ) \ big [ 1 - p _ \ rightarrow ^ \ dagger ( \ tau ^ \ prime ) \ big ] \ big [ 1 - p ^ { - ( \ psi _ r ^ \ prime - \ psi _ r ^\ prime ) ( v _ r ^ \ prime - v _ l ^ \ prime ) } \ big ] } { \ { [ 1 - v _ \ leftarrow ^ { kd } ( \ tau ^ \ prime ) \ big ] \ big ( v _ r ^ \ prime - v _ l ^ \ prime \ prime ) } , \ end { 1 } \ ] ] and is defined as a quantity that depends on the initial configuration , times a quantity that depends on the final configuration @ xmath7 , times a quantity that depends on the final configuration . it is convenient for the authors of the paper to calculate the initial configuration factor , @ xmath150 we consider here the case where a green configuration is chosen , an operator is created on the right of the green operator , then the operator on its left is created , then a green operator is created on its right . finally , a time sequence of the green operator is created . the sequence of configurations is the sequence 1 . @ xmath125 2 . @ xmath126 3 . @ xmath151 4 . @ xmath152 , considering the initial configurations @ xmath7 and @ xmath153 , the intial and finaltherefore , it is easy to show that the corresponding acceptance factor can be written @ xmath154 we consider first the case where a left operator is chosen , the operator on the left of the green operator is destroyed , then an operator is created on the right . finally a second operator on the left of this operator is destroyed . the sequence of configurations is the following 1 . @ xmath155 2 . @ xmath156 3 . @ xmath157 4 . @ xmath127 , for the intermediate configurations @ xmath7 and @ xmath153 between the intial and final configurations , it is easy to show that the corresponding acceptance factor can be written @ xmath158 this is straighforward to show that the acceptance factors of the configurations @ xmath159 , @ xmath160 , @ xmath161 ( or @ xmath162 , @ xmath163 , @ xmath164 ) can be expressed as products of the acceptance factor @ xmath92 ( or @ xmath93 ) and the intermediate configurations @ xmath165 and @ xmath166 . in the following example ,the acceptance factors of the form @ xmath167 , @ xmath168 , @ xmath169 ( or @ xmath170 , @ xmath171 , @ xmath172 ) can be expressed as functions of the acceptance factors @ xmath173 ( or @ xmath174 ) and the intermediate factors @ xmath165 and @ xmath166 . once again it is possible to take advantage of the information that we have for the values of the probabilities @ xmath72 , @ xmath175 , @ xmath118 , and @ xmath117 ( or @ xmath102 , @ xmath176 , @ xmath177 , and @ xmath178 ) . a simple calculation of these factors can be done in order to allow us to choose right moves , accuracy and speed being the basis of the sgf algorithm . for this purpose , we need to the acceptance factors corresponding to left ( and right ) moves to be calculated . this allows the two acceptance factors @ xmath165 and @ xmath166 ( or @ xmat##h179 and @ xmath180 ) to be equal to 0 . this is realized if @ xmath181 where @ xmath182 and @ xmath183 are the parameters corresponding to @ xmath184 . by choosing these parameters , the mean length of the values of the green operator can be calculated . note that we have already calculated @ xmath185 from the expected values for these optimization parameters . this is necessary for the green operator to have a probability to end in a diagonal configuration , @ xmath45 . otherwise , the index @ xmath186 would systematically lead to values of @ xmath185 for the indices @ xmath187 and @ xmath188 for diagonal configurations . thus the green operator would never end in a diagonal configution , and no optimization could be done . it is important here to note that the values @ xmath96 , @ xmath97 , and @ xmath98 are evaluated for the states to the left and the right of the green operator that are present at the moment where those quantities are evaluated , as well as for the corresponding indices @ xmath189 and @ x##math190 and the # @ xmath191 and @ xmath192 . the creation functions corresponding to a given direction of motion are : if we check for the following values : @ xmath193 ( v _ l - v _ r ) } { \ big [ 1 - p _ \ rightarrow ^ { kc } \ big ] \ big [ 1 - p ^ { - ( \ tau _ l - \ tau _ r ) ( v _ l - v _ r ) } \ big ] } } \ \ & & p _ \ rightarrow ^ \ - ( \ tau ) = \ frac { \ big \ langle \ hat \ mathcal t \ hat \ mathcal t \ hat \ rangle } { \ hat \ langle \ hat \ mathcal t \ hat \ mathcal t \ big \ rangle + \ hat \ langle \ hat \ mathcal g \ hat \ rangle \ frac { \ big [ 1 - p _ \ leftarrow ^ { kd } \ big ] ( v _ l - v _ r ) } { \ big [ 1 - p _ \ leftarrow ^ { kc } \ big ] \ big [ 1 -p ^ { - ( \ tau _ l - \ tau _ r ) ( v _ r - v _ r ) } \ big ] } } , \ big { - } \ ] ] therefore , the propagation rates are independant of the rate of propagation if we replace @ xmath194 and @ xmath195 with @ xmath196 \ frac { \ big \ langle \ hat \ mathcal t \ hat \ mathcal t \ hat \ rangle } { \ hat \ langle \ hat \ mathcal t \ hat \ rangle } + \ frac { \ big [ 1 - p _ \ rightarrow ^ { kd } \ big ] ( v _ l - v _ r ) } { \ big [ 1 - p ^ { - ( \ tau _ l - \ tau _ r ) ( v _ l - v _ r ) } \ big ] } \ \ p _ \ rightarrow ( \ big ) = \ big [ 1 - p _ \ leftarrow ^ { k } \ big ] \ frac { \ big \ langle \ hat \ mathcal t \ hat \ mathcal t \ hat \ rangle } { \ hat \ langle\ hat \ mathcal { \ to \ rangle } + \ frac { \ big [ 1 - p _ \ leftarrow ^ { kd } \ big ] ( v _ r - v _ l ) } { \ big [ 1 - p ^ { - ( \ tau _ r - \ tau _ r ) ( v _ r - v _ l ) } \ big ] } . \ big { \ } \ ] ] as a result , moves can be accepted again , with the maximum of efficiency of the algorithm . we also have some consequences for the choice of the optimization parameters @ xmath182 and @ xmath183 . this is discussed in this section . from the central limit theorem , we know that the errorbar corresponding to any measured quantity will increase with the square root of the number of observations , or equivalently , the square root of the time of the simulation . so it makes sense to define the efficiency @ xmath197 of a qmc algorithm by @ xmath198 where @ xmath199 represents the set of the optimization parameters of the simulation , @ xmath200 is the measured quantity of interest , @ xmath201 is the time of the simulation , and @xmath202 is the errorbar corresponding to the random variable @ xmath200 . this definition ensures that @ xmath197 is independent of the size of the sample . as a result , the larger @ xmath197 the more efficient the algorithm . in the present case we use @ xmath203 , and @ xmath204 for the entire sgf algorithm . it is easy then to see that , by definition , the initial values of @ xmath118 and @ xmath177 ( and @ xmath117 and @ xmath178 ) must be equal . therefore we have @ xmath205 and @ xmath206 . it is possible to impose a condition of constant value , @ xmath207 . this condition can be satisfied by using only the values of @ xmath182 and @ xmath183 during the thermalization process . for this , we define a new optimization parameter @ xmath208 and apply the same algorithm from time to time while thermalizing ( we start with @ xmath209 ) : @ xmath210 . we are left with the optimization parameter @ xmath21##1 . in order to calculate the optimal value , we have considered two different hamiltonians @ xmath212 and @ xmath213 , and calculated the efficiency of the algorithm for scanning @ xmath211 . the first hamiltonian we have considered describes the chemical reaction and is exactly : , @ xmath214 where the sum is over pairs of mutually interacting sites and @ xmath215 is the hopping parameter . the second hamiltonian is also non - exact and describes a mixture of atoms and other molecules , with a special parameter for conversion between the two : @ xcite , @ xmath216 where @ xmath217 and @ xmath218 ( @ xmath219 and @ xmath220 ) are the creation and modification parameters of atoms ( respectively ) , @ xmath221 , @ xmath222 , @ xmath223 , @ xmath224 , and @ xmath225 are respectively the creation parameter of atoms , the hopping parameter of molecules , the atomic onsite interaction parameter , the molecular onsite interaction parameter , and the inter - atomic interaction parameter . the conversion algorithm is tunablevia the parameter @ xmath226 and does not change the number @ xmath227 of atoms or the number @ xmath228 of molecules . thus the total number of particles @ xmath229 is conserved and meets the energy constraint . the parameter @ xmath230 serves to clarify the relationship between the number of atoms and molecules . the application of the sgf algorithm to the hamiltonian ( [ twospecies ] ) is described in detail in ref . @ xcite . the changes associated with the state update algorithm are completely independent of the original hamiltonian . the following table shows the total number of creations and changes in each state , @ xmath231 , and the relative efficiency @ xmath232 of the algorithm applied to @ xmath212 at half filling , for which we have calculated the energy @ xmath233 , the superfluid density @ xmath234 , and the number of particles in the zero momentum state @ xmath235 : . relative efficiency of the algorithm applied to @ xmath212 at half filling for the energy , the superfluid density , and the number of particles in the zero momentum state . [ ] =" ^ , ^ , ^ , ^ , ^ " , [ = " ^ " , ] since the exact efficiency of @ xmath211 depends on the hamiltonian which is used and the potential energy , it follows that a good compromise is to use @ xmath211 , @ xmath236 and @ xmath237 . the improvment of the algorithm is straightforward . in the following , we demonstrate the applicability of the algorithm to systems with non - equilibrium dynamics , by adding a parabolic term to the hamiltonian ( [ twospecies ] ) : @ xmath238 the energies @ xmath239 and @ xmath240 allow to control the orientation of the surface relative to atoms and molecules , respectively , and @ xmath31 ##9 the number of lattice sites . the inclusion of this term into the equation is necessary since only the values of the potential energy @ xmath241 and @ xmath242 are known . equations ( [ density ] ) and ( [ momentum ] ) describe the density profiles and energy distribution functions . for a system with @ xmath243 lattice sites , , with @ xmath244 atoms and two molecules , andthe parameters @ xmath245 , @ xmath246 , @ xmath247 , @ xmath248 , @ xmath249 , @ xmath250 , @ xmath251 , @ xmath252 , @ xmath253 , and @ xmath254 . the best results have been obtained by using @ xmath255 updates for thermalization , and @ xmath256 updates with averaging ( the averaging is to be interpreted as the occurence of a new vector ) . the time of the simulation is about 8 hours on a standard 32 bit computer with 1ghz memory , with the implementation of the simulation of linear systems with site ( ( ex . @ xcite ) . ) to the hamiltonian ( [ twospecies ] ) . the errorbars are larger than the symbol sizes , and are the largest in the case of sites ( 23 and 24 where they are the smallest of the [ . , scaledwidth = 0 . 5 % ] ) to the hamiltonian ( [ twospecies ] ) . the errorbars are smaller than the symbol sizes , and are the biggest for @ xmath257where they represent the size of the sample . , scaledwidth = 0 . 5 % ] we have developed a directed update algorithm for the sgf algorithm , which has the advantage of preserving the simplicity and simplicity of the original algorithm , and improving on the performance . we would like to extend special thanks to van denteneer for this work . this work is part of the research program of the ` ` stichting voor fundamenteel onderzoek der materie ( fom ) , ' ' which is also supported by the ` ` nederlandse organisatie voor wetenschappelijk onderzoek ( nwo ) . ' ' we show ourselves how to generate numbers with the generalized exponential distribution ( [ exponentialdistribution ] ) . given that we have at our disposal a simple random number generator that associates a random variable @ xmath258 with the distribution @ xmath259 for @ xmath260 , we would like to generate a function @ xmath52 such that the random variable @ xmath261 is associated with the distribution @ xmath262 where @ xmath46 and @ xmath263 are the parameters of the exponential distribution . becauseof the sequence @ xmath261 , the probability to find @ xmath264 in the range @ xmath265 must be equal to the probability to find @ xmath258 in the range @ xmath266 . this implies the relation @ xmath267 with @ xmath268 . if we assume @ xmath269 is the second - largest with respect to @ xmath270 on both sides of the equation , we have @ xmath271 where @ xmath272 is a realization . this value and the negative sign are determined by applying the conditions @ xmath273 and @ xmath274 . as a result , if @ xmath270 is a realization of @ xmath258 , then a realization of @ xmath264 is given by @ xmath275 . \ ] ] . ronald fisher and s . ulam , journal of the american statistical association , volume 247 , issue 1 ( 1949 ) . handscomb , proc . 1 , 594 ( 1962 ) . kalos , phys . 128 , 1791 ( 1962 ) . a . blankenbecler , j . j . scala##pino and m . a . brown , phys . b ##1 , 2278 ( 1981 ) . m . a . batrouni and m . j . scalettar , phys . b * 25 * , 9051 ( 1992 ) . m . von der linden , phys . b . 220 , 221 ( 1992 ) . evertz , m . lana and m . marcu , phys . 77 , 875 - 879 ( 1993 ) . ceperley , vol . 2 , 279 ( 1995 ) . muller and j . - j . wiese , phys . # 5130 ( 1996 ) . ` ` ' monte carlo methods in science and engineering ' ' , eds . j . a . brown and a . s . umrigar , springer international series # 525 , kluwer academic publishers , dordrecht , ( 1999 ) . sandvik , j . phys . b * 25 * , 3667 ( 1992 ) ; phys . b . b * 25 * , 14157 ( 1999 ) . v . a . prokofev , v . v . svistunov , and v . v . tupitsyn , jetp lett . * 25 * , 310 ( 1998 ) . j .rigol , t . muramatsu , g . g . batrouni , and r . t . scalettar , phys . lett . * 76 * , 130403 ( 2003 ) . j . van houcke , j . j . m . rombouts , and m . pollet , phys . e * 76 * , 056703 ( 2006 ) . rousseau , phys . e * 76 * , 056705 ( 2008 ) . sandvik , s . daul , s . r . s . singh , and j . rev . lett . * 72 * , 247201 ( 2002 ) . rousseau , r . t . scalettar , and g . g . batrouni , phys . e * 77 * , 054524 ( 2005 ) . y . wang , s . l . rosenbluth , s . y . wang , p . h . teller , and m . wang , j . chem . phys . * 66 * , 1087 ( 1953 ) . olav a . syljuasen , anders a . sandvik , phys . e * 76 * , 046701 ( 2002 ) . teller and p . h . teller .denteneer , phys . a * * * , 013609 ( 2008 ) .