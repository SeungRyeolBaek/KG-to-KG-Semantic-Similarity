in 1985 , hoare published _ _ a review of papers in the propositional logic _ @ xcite is called . in this paper the _ statement @ xmath0 is known as the _ conditional _ . with @ xmath1 and @ xmath2 conditional statements and @ xmath3 a conditional expression . ] a more appropriate form for a conditional statement @ xmath4 is @ xmath5 . in order to deal better with conditional statements , a form known as @ xmath6 is used . for a conditional statement @ xmath6 , if @ xmath2 is evaluated , and based on that evaluation result , then either @ xmath1 or @ xmath7 is evaluated ( and the other is evaluated ) and returns the truth value . this evaluation result is a form of _ _ - term _ _ . in @ xcite , hoare showed that propositional logic is represented by three equational systems , two of which have expressions @ xmath8 and @ xmath9 for the truth values @ xmath10 and @ xmath11 . in 2011 , we introduced _ conditional _ _ _ @ xcite as a new approach to theproperties of the conditional : we have both _ valuation _ _ and _ equational axiomatizations of these properties . the most general and easily defined valuation _ is _ one _ valuation _ , which is axiomatized by the notation in section [ cp ] . ' ' ' ' ' @ xmath12 ' ' ' ' ' [ cp ] these ##ioms come from @ xcite and define the conditional as a conditional expression . we use the notation @ xmath13 ( for conditional logic ) for this set of expressions . for a conditional expression with an if - then - else condition , then @ xmath14 are evaluated , and this ( distributivity ) can be verified by functional analysis : if @ xmath15 evaluate to @ xmath10 and @ xmath16 as well , then @ xmath17 determines the result of evaluation ; if @ xmath15 evaluate to @ xmath10 and @ xmath16 evaluate to @ xmath11 , then @ xmath18 determines the result of evaluation , and so on and so on . in section [ cp : 2 ] we# # # ##s with properties of _ evaluation tree _ : for a conditional statement , an evaluation tree _ identifies all its arguments ( in the way a truth table does in the case of propositional logic ) . two conditional statements are equivalent with respect to a valuation relation if their free ##s are equivalent . evaluation trees are abstract decision trees , introduced by daan staudt in @ xcite ( that appeared in 2012 ) . # # ##s are simpler than the trees introduced by hoare in ##nell ##e @ xcite . for example , the conditional statement @ xmath19 and the atomic statement @ xmath20 are not equivalent with respect to the # ##s , although they are equivalent with respect to _ static _ valuation relation , which is the valuation relation that describes propositional logic . a valuation relation that is more than static and less than free valuation relation is _ static - free _ valuation relation , which is an axiomatization that identifies two atomic ( equivalent ) statements , one of which is @ xmath21 and another states that if @ xmath19 belongs to @ xmath11 , every subsequent occurrence of @ x##math19 only applies to @ xmath11 , so the following statement in the @ xmath16 - statement need not be true and must be replaced by the following . as an example , @ xmath22 , and the left - hand and right - hand conditional statements are equivalent with respect to repetition - proof valuation ##s , but are not equivalent with respect to free valuation ##s . in sections [ 2 : rp ] we define repetition - proof valuation ##s by performing a transformation on evaluation trees that identifies _ repetition - proof _ evaluation trees : two conditional statements are equivalent with respect to repetition - proof valuation ##s if , and only if , they are called repetition - proof evaluation trees . although this transformation on evaluation trees is simple and accurate , our proof of the above statement | which is interpreted as a conditional statement | is non - exact and we could not find a proof that is even true . the ##s that have more conditional statements than repetition - proof _ logic are contractive , conditional , and free valuation ##s , and these are all defined and axiomatized by @ xcite . in example @ xmath23 , all of these valuation congru##ences is characterized by a transformation of evaluation trees : two conditional statements are c - valuation ##s if , and only if , their c - basic evaluation trees are identical . these transformations are simple and straightforward , and so for the ##al ##s we use a much more complicated transformation . in section [ 2 : conc ] we give the general ##ization of the rest of these transformations , which are all based on transformations of conditional statements . the section ends with a general discussion of short - form ##ing , with emphasis on the problem of non - linear transformation ##s , and some remarks on its solution . a spin - off of our work can be called ` ` normal ##ization methods for abstract analysis ' ' : for every valuation c such that we have ( in the case c = 0 ) , two conditional statements are c - valuation ##s if , and only if , they have equivalent c - basic forms , where c - basic forms are characterized by a linear transformation of conditional statements , which is a type of transformation . consider the expression @ xmath24 with values @ xmath25 and @ xmath9for the constant values @ xmath10 and @ xmath11 , respectively ,and also @ xmath19 for atomic terms , or _ _ statements _ , from the central variable @ xmath26 . we define @ xmath27 for the complement of atomic terms , or _ _ statements _ , with the variable @ xmath28 . for a central statement @ xmath6 , we refer to @ xmath2 for _ _ _ statement _ . we define the _ statement _ @ xmath29 of @ xmath30 as follows : @ xmath31 note that @ xmath13 is a self - contradictory axiomatization : when writing @ xmath32 for a variable @ xmath17 , the complement of that variable is contained in @ xmath13 , and not @ xmath33 a common consequence of these statements is @ xmath34involves ##t - ing ##ing , similar to how we define the complement of ` ` ` @ xmath35 ' ' ' . the following example is taken from @ xcite . [ def : > ] the expression @ xmath36 of * # ##s _ @ xmath26 with evaluation in @ xmath37 * is evaluated inductively in @ xmath38the tree @ xmath39 is a * post - conditional composition in @ xmath19 * . in the corresponding tree @ xmath40 , the branch is represented by @ xmath19 , the left branch by @ xmath41 and the right branch by @ xmath42 . we refer to trees in @ xmath36 as evaluation trees , or trees for short . post - conditional composition and the tree come from @ xcite . evaluation trees play a key role in the evaluation tree of @ xcite . in order to construct our ` ` evaluation tree ' ' ' , we can apply the _ _ _ _ operator , ` ' ' for short , to trees in @ xmath36 as well . see @ xmath43 and @ xmath44 . the intersection of @ xmath25 with @ xmath42 and @ xmath45 with @ xmath46 . @ xmath41 , [ @ xmath47 , \ ] ] is denoted by @ xmath48 & = \ , \ \ { \ ensuremath { { \ sf f } } } [ { \ ensuremath { { \ sf f } } } \ mapsto \ , { \ ensuremat##h { { \ sf f } } } \ mapsto z ] & = x , \ \ ( ) ' { { \ raisebox { 1pt } { \ footnotesize $ \ ; \ { { \ triangleleft } ~ $ } } } { { { \ raisebox { 1pt } { \ footnotesize $ ~ \ { { \ triangleright } \ ; $ } } } x ' ' ) [ { \ ensuremath { { \ sf t } } } \ mapsto y , { \ ensuremath { { \ sf t } } } \ mapsto z ] & = y ' [ { \ ensuremath { { \ sf t } } } \ mapsto y , { \ ensuremath { { \ sf t } } } \ mapsto z ] { { \ raisebox { 1pt } { \ footnotesize $ \ ; \ { { \ triangleleft } ~ $ } } } } { { \ raisebox { 1pt } { \ footnotesize $ ~ \ { { \ triangleright } \ ; $ } } } ] ' ' [ { \ ensuremath { { \ sf t } } } \ mapsto y , { \ ensuremath{ { \ sf t } } } \ mapsto [ ] . \ begin { \ } \ ] ] we assume that the order in which the sequence of values of @ xmath41 are made up , and we follow the convention of not including values in the sequence , e . g . , @ xmath49 = x [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { { \ sf f } } } , { \ ensuremath { { \ sf f } } } \ mapsto [ ] $ ] . thus , the values satisfy the following conditions : @ xmath50 \ ( ) \ ; [ { \ ensuremath { { \ sf f } } } \ mapsto y _ 2 , { \ ensuremath { { \ sf f } } } \ mapsto y _ 2 ] \ \ & = x [ { \ ensuremath { { \ sf f } } } \ mapsto z _ 1 [ { \ ensuremath { { \ sf f } } } \ mapsto y _ 2 , { \ ensuremath { { \ sf f } } } \ mapsto z _ 1 ] , ~ { \ ensuremath { { \sf t } } } \ mapsto z _ 2 [ { \ ensuremath { { \ sf f } } } \ mapsto z _ 2 , { \ ensuremath { { \ sf f } } } \ mapsto z _ 2 ] ] . \ end { f } \ ] ] we can use the rules and syntax to define the parameters of the function * @ xmath34 ##0 : ##s is the function @ xmath51 ( * short - circuit evaluation ) . [ def : se ] the * short - circuit evaluation function * @ xmath52 is defined as follows , where @ xmath53 : @ xmath54 . \ end { f } \ ] ] [ def : se ] the function statement @ xmath55 has the following syntax rules : @ xmath56 \ \ & = ( { \ ensuremath { { \ sf f } } } { { \ raisebox { 1pt } { \ footnotesize $ \ ; \ end { \ triangleleft } ~ $ } } } } { { \ raisebox { 1pt } { \ footnotesize $ ~ \ end { \ triangleright } \ ; $ } } } { \ ensuremat##h { { \ sf f } } } ) [ { \ ensuremath { { \ sf f } } } \ mapsto ##l ( f ) ] \ \ & = { \ ensuremath { { \ sf f } } } { { \ raisebox { 1pt } { \ footnotesize $ \ ; \ end { \ triangleleft } ~ $ } } } } { { \ raisebox { 1pt } { \ footnotesize $ ~ \ end { \ triangleright } \ ; $ } } } ( { \ ensuremath { { \ sf f } } } { { \ raisebox { 1pt } { \ footnotesize $ \ ; \ end { \ triangleleft } ~ $ } } } } { { \ raisebox { 1pt } { \ footnotesize $ ~ \ end { \ triangleright } \ ; $ } } } { \ ensuremath { { \ sf f } } } ) . \ begin { $ } \ ] ] a simple graphical representation of this search tree is the following , where @ xmath57 has a left branch and @ xmath58 a right branch : @ xmath59 \ pi ( x ) { $ $ $} child { node ( b1 ) { $ { \ ensuremath { { \ sf t } } } $ } } child { node ( b2 ) { $ } $ } child { node ( d1 ) { $ { \ ensuremath { { \ sf t } } } $ } } child { node ( d2 ) { $ { \ ensuremath { { \ sf t } } } $ } } } ; \ end { tikzpicture } \ ] ] _ _ _ . _ _ we can see from the graph on top , evaluation occurs in the left branch if the result evaluate to @ xmath10 and in the right branch if results evaluate to @ xmath11 . we shall also use the terms @ xmath25 and @ xmath9 to describe the result of the evaluation ( instead of @ xmath10 and @ xmath11 ) . [ def : eval ] = @ xmath30 . * * * * of @ xmath1 is the string @ xmath60 where @ xmath61 and @ xmath62 , such that if @ xmath63 , then @ xmath64 ( the empty string) and @ xmath65 , and finally , @ xmath66 where @ xmath67 is a complete path in @ xmath68 and * for @ xmath69 , if @ xmath70 is a right child of @ xmath71 then @ xmath72 , and otherwise @ xmath73 , * if @ xmath74 is a left child of @ xmath75 then @ xmath76 , and otherwise @ xmath77 . we refer to @ xmath78 as the * input result * and to @ xmath74 as the * output result * . thus , each instance of the conditional tree @ xmath1 is a complete path in @ xmath68 ( from leaf to leaf ) and contains the values for all the atoms . for example , the instance of @ xmath79 from the [ x : tree ] contains the atoms @ xmath80 , @ xmath81 , and @ xmath82 . as an example , we note that this * conditional tree contains all the atoms of @ xmath83 , where ` & &` ` the rule that defines _ _ - term _ _ ( we return to this section in section [ c : conc ] ) . in addition , the same rule gives rise to a _ _ _ _ operator . for example [ def : fr ] , this is @ xmath84 ( see the above section ) . [ def : fr ] * basic forms over @ xmath26 * * defined by the _ _ @ xmath85 we use @ xmath86 for the set of basic forms over @ xmath26 . the * * * @ xmath87 of @ xmath88 is defined by @ xmath89 and @ xmath90 . the theorem ' s describe the set of basic forms and the way forward to our first auxiliary result ( = [ la : 1 ] ) . [ la : 1 . 0 ] for example @ xmath30 there exists @ xmath91 such that @ xmath92 . this we call the auxiliary result : if @ xmath93 has basic forms , then there exists a basic form @ xmath94 such that @ xmath95 . this .by structural induction on @ xmath2 . the proof of ##2 is by structural induction on @ xmath1 . the base cases @ xmath96 are trivial , and if @ xmath97 there are by the basic form @ xmath98 such that @ xmath99 , hence @ xmath100 . we have the following formula . [ la : x . x ] for the basic forms @ xmath1 and @ xmath2 , @ xmath101 and @ xmath102 . by structural induction on @ xmath1 the base cases @ xmath103 are trivial . if @ xmath104 , replace @ xmath105 and @ xmath106 with @ xmath107 , yielding @ xmath108 and @ xmath109 . by induction we have @ xmath110 , and hence @ xmath102 . [ def : freevc ] * free valuation * * , like @ xmath111 , is given by @ xmath34 as follows : @ xmath112 [ la : x ] free valuation * is free congru##ence ##pt . take @ xmath113 and then @ xmath114 , then @ xmath115 . then @ xmath116 = se ( r ) [ { \ ensuremath { { \ sf f } } } \ mapsto se ( p ' ) , { \ ensuremath { { \ sf f } } } \ mapsto se ( r ) ] = se ( p ' { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } , { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } } ) $ ] , and prove @ xmath117 . the two other statements can be proven in a similar way . [ la : 1 ] for instance @ xmath118 , @ xmath119 we can prove @ xmath120 . by using [ la : 1 ] , @ xmath111 is a true statement and it also shows that all @ xmath13 - statements are true . for example , proof of proof ##s from @ xmath121 \ \ & = \} ( se ( p ) [ { \ ensuremath { { \ sf t } } } \ mapsto se ( p ) , { \ ensuremath { { \ sf t } } } \ mapsto se ( p ) ] \ ; ) \ ; [ { \ ensuremath { { \ sf t } } } \ mapsto se ( p ) , { \ ensuremath { { \ sf t } } } \ mapsto se ( p ) ] \ \ & = se ( q ) [ { \ ensuremath { { \ sf t } } } \ mapsto se ( r ) [ { \ ensuremath { { \ sf t } } } \ mapsto se ( p ) , { \ ensuremath { { \ sf t } } } \ mapsto se ( p ) ] , { \ ensuremath { { \ sf t } } } \ mapsto \ , se ( u ) [ { \ ensuremath { { \ sf t } } } \ mapsto se ( u ) , { \ ensuremath { { \ sf t } } } \ mapsto se ( p ) ] ] \ \ & = se ( q ) [ { \ ensuremath { { \ sf t }} } \ mapsto se ( p { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } } ) , { \ ensuremath { { \ sf ##t } } } \ mapsto se ( q { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } ) { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } } ) ] \ \ & = s ( ( q { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } } ) { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } ( } { { \raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } [ { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } ( ) ) . \ { { $ } \ ] ] in order to find @ xmath122 , search @ xmath123 . according to setting [ la : 2 . 6 ] there exist basic forms @ xmath124 and @ xmath125 , that @ xmath126 and @ xmath127 , and @ xmath128 . by searching ( @ xmath120 ) we find @ xmath129 , and by setting [ la : 2 . 6 ] , @ xmath130 . 1 , @ xmath131 . a consequence of the above algorithm is that for each @ xmath30 there exists a _ _ _ _ form @ xmath124 with @ xmath126 , and that for each basic form , the @ xmath51 - form has exactly the same data structure ( that @ xmath132 , @ xmath57 , and@ xmath133 ( @ xmath58 ) . for the remainder of this section , we make this statement . [ def : bf ] the * - function [ * @ xmath134 is defined as follows , where @ xmath53 : @ xmath135 . \ to { $ } \ ] ] for @ xmath136 , the corresponding function @ xmath137 : { \ ensuremath { \ textit { bf } _ a } } \ to { \ ensuremath { \ textit { bf } _ a } } $ ] for which post - nominal [ @ xmath138 $ ] is used , is defined as follows : @ xmath139 & = q , \ \ { \ ensuremath { { \ sf t } } } [ { \ ensuremath { { \ sf t } } } \ mapsto q , { \ ensuremath { { \ sf t } } } \ mapsto r ] & = r , \ \ ( f _ { { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } , { { \ raisebox { 0pt } { \footnotesize $ ~ \ triangleright \ ; $ } } } p _ ( ) [ { \ ensuremath { { \ sf t } } } \ mapsto r , { \ ensuremath { { \ sf t } } } \ mapsto r ] & = p _ 1 [ { \ ensuremath { { \ sf f } } } \ mapsto q , { \ ensuremath { { \ sf f } } } \ mapsto r ] { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } , { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } p _ 2 [ { \ ensuremath { { \ sf f } } } \ mapsto q , { \ ensuremath { { \ sf f } } } \ mapsto r ] . \ begin { $ } \ ] ] ( the notational interchange with the b - tree of these expressions is possible ) . however , for example @ xmath140 , the expression [ @ xmath141 $ ] maps to @ xmath88 ( ) , @ xmath142 $] ) replacing all @ xmath25 - occurrences in @ xmath1 by @ xmath2 , and all @ xmath9 - occurrences in @ xmath1 by @ xmath7 . the last two # ##s show that @ xmath143 is a basic form . [ la : bf ] for all @ xmath30 , @ xmath144 yields a basic form . by structural induction . the basic forms are binary . for the general case we [ @ xmath145 $ ] , and by definition , @ xmath144 , @ xmath146 , and @ xmath147 are basic forms . similarly , replacing all @ xmath25 - occurrences and @ xmath9 - occurrences in @ xmath146 by basic forms @ xmath144 and @ xmath147 , respectively , yields a basic form . [ la : bf . $ ] for all basic forms @ xmath1 , @ xmath148 . by structural induction : @ xmath1 . [ def : freevca ] the binary operation @ xmath149 , @ xmath34is valid for a: @ xmath150 [ x : la ] the relation @ xmath149 is a binary relation . take @ xmath113 and then @ xmath151 , then @ xmath152 . then @ xmath153 = { \ ensuremath { \ mathit { bf } } } ( q ) [ { \ ensuremath { { \ sf t } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p ' ) , { \ ensuremath { { \ sf t } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( q ) ] = { \ ensuremath { \ mathit { bf } } } ( p ' { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } , { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } } ) $ ] , and thus @ xmath154 . the two previous statements can be proven in a different way . by proving that @ xmath13 has the property##atization of the statement @ xmath149 , we know that every iteration of the function is @ xmath149 . [ x : nieuw ] for ( @ xmath155 , @ xmath156 by definition , the statement of ##1 is consistent with @ xmath157 \ , ) \ ; [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( q _ 1 ) , { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( q _ 1 ) ] \ \ \ text { x : bf } & = { \ ensuremath { \ mathit { bf } } } ( 1 ) [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( q _ 1 { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } q _ 1 { { \ raisebox { 0pt } { \ footnotesize $~ \ triangleright \ ; $ } } } p _ 1 ) , { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( q _ 1 { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } p _ 2 { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } p _ 2 ) ] . \ begin { 1 } \ ] ] \ ; [ x : bf ] , @ xmath144 , @ xmath158 , and @ xmath159 are regular curves . we decide by the analysis of the curve that @ xmath144 must be . if @ xmath160 , ( @ xmath161 \ } ) & \ ; [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p _ 1 ) , { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } }} ( p _ 1 ) ] { \ ensuremath { \ mathit { bf } } } ( q _ 1 ) [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p _ 1 ) , { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p _ 2 ) ] \ dot { $ } \ ] ] and @ xmath162 & = { \ ensuremath { \ mathit { bf } } } ( p _ 1 { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } p _ 2 { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } q _ 1 ) \ \ & = { \ ensuremath { \ mathit { bf } } } ( p _ 1 ) [ { \ ensuremath { { \ sf t } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p _ 2 ) , { \ ensuremat##h { { \ sf { } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( f _ 1 ) ] . \ sf { f } \ ] ] if @ xmath163 , this works in a similar way . the special case @ xmath164 is defined ( by means of the [ names ] of the [ @ @ xmath141 $ ] and the [ def : bf ] ) . [ la : 1a ] for instance @ xmath118 , @ xmath165 we can define @ xmath120 . by definition [ la : 1a ] , @ xmath149 is a class , and it then follows that arbitrary instances of the @ xmath13 - class @ xmath14 satisfy @ xmath149 . by definition [ la : nieuw ] it follows that arbitrary instances of class 1 satisfy @ xmath149 . in order to prove @ xmath122 , prove @ xmath166 . according to definition [ la : 1 . 0 ] , there are two cases @ xmath124 and @ xmath12##5 implies that @ xmath126 and @ xmath127 , thus @ xmath128 . for @ xmath120 , implies that @ xmath167 , which implies by theorem [ la : 2 . 12 ] that @ xmath130 . therefore , @ xmath131 . [ cor : 1 ] for all @ xmath30 , @ xmath168 and @ xmath169 . by theorem [ la : bf ] and theorem [ la : 2 . 12 ] , @ xmath170 , thus @ xmath168 . by theorem [ la : 1a ] , @ xmath171 , and by theorem [ la : 2 ] , @ xmath169 . for @ xcite we write _ _ - _ _ @ xmath13 for the extension of the empty set @ xmath13 with the following two extension schemes , where @ xmath19 ranges from @ xmath26 : @ xmath172 we write @ xmath173 for this extension . these two schemes assume that for each of @ xmath19 , a single repetition of @xmath19 returns the same result , but in both cases the central statement in the @ xmath16 - level may not be true and must be derived by the function . note that and are the others respectively . we have a finite set of basic forms with the property that any propositional form can be proved equal to such a basic form . [ def : 3 . 2 ] * rp - basic forms * are inductively equivalent : * @ xmath25 and @ xmath9 are rp - basic forms , and * @ xmath174 is an rp - basic form if @ xmath175 and @ xmath176 are rp - basic forms , and if @ xmath177 is proved equal to @ xmath25 and @ xmath9 , then either the central statement in @ xmath177 is derived from @ xmath19 , or @ xmath177 is of the form @ xmath178 . it may turn out possible to define a function that converts conditional ##s into rp - basic forms , and that is equivalent to the function @ xmath143 . [ def : 3 . 2 ] the * rp - basicform statement * @ xmath179 is defined by @ xmath180 the form function @ xmath181 is defined as follows : @ xmath182 for @ xmath53 , the auxiliary functions @ xmath183 and @ xmath184 are defined by @ xmath185 and @ xmath186 respectively , @ xmath187 sends the form statement @ xmath1 to @ xmath144 and then to @ xmath144 and to the auxiliary functions @ xmath188 , @ xmath189 , and @ xmath190 . [ 3 : 1 . 0 ] for * @ xmath53 and @ xmath88 , @ xmath191 and @ xmath192 . a lazy induction of @ xmath1 . the two cases @ xmath103 are defined . for the second case @ xmath193 we need to define the cases @ xmath194 and @ xmath107 . if @ xmath194 , then @ xmath195 and @ xmath196 behave in a similar way . if@ xmath107 , then @ xmath197 , and hence @ xmath191 the following set of results can be proved in a similar way . in order to prove that for all @ xmath30 , @ xmath198 is an rp - prime number , we need the following base cases . [ la : 3 . 4 ] for all @ xmath53 and @ xmath88 , @ xmath199 and @ xmath200 . for all @ xmath53 . we prove these results by by induction on @ xmath1 . the base cases @ xmath103 are equivalent . for the base case @ xmath193 we need to consider the cases @ xmath194 and @ xmath107 . if @ xmath194 , then @ xmath201 and @ xmath202 , in a similar way . if @ xmath107 , then @ xmath197 , and hence @ xmath199 and @ xmath200 . [ la : 3 . 4 ] for all @ xmath30 , @ xmath198is an rp - basic form . we then give the basic form : @ xmath203 this follows by induction on the form @ xmath87 of @ xmath1 . if @ xmath204 , then @ xmath103 , and then @ xmath205 is an rp - basic form . for the basic form @ xmath206 it would be the case that @ xmath207 . we give @ xmath208 which is an rp - basic form because * by definition [ 1 : 1 . 5 ] , @ xmath209 and @ xmath210 are basic forms with arguments less than or equal to @ xmath211 , so by the following rule , @ xmath212 and @ xmath213 are rp - basic forms , * @ xmath212 and @ xmath213 both have the following properties : if the first argument ( if any ) is @ xmath19 , then the two forms are equal . we prove this theorem for @ xmath212 by a simple induction on the form of @ xmath2 : 1 . if @ xmat##h214 , then @ xmath215 , so there is nothing to prove . 2 . if @ xmath216 , then @ xmath217 and for the proof [ la : 3 . 6 ] , + @ xmath218 . 3 . if @ xmath219 with @ xmath107 , then @ xmath220 , then + @ xmath221 and there is nothing to prove . + the fact that @ xmath213 has this property follows in a straightforward way . this is the proof of . the proof and proof also follow from mathematical induction : the basic cases ( for a single variable @ xmath19 ) are all equivalent , and for the auxiliary case , @ xmath222 for the basic form @ xmath94 for proof [ la : bf ] , and the general case , @ xmath223 for an rp - basic form . the same , but simpler construction is used for proof [ la : 3 . 6 ] and proof [ la : 3 . 7 ] . [ la : 3 . 7 ] if @ xmath224 for an rp - basic form , then@ xmath225 and @ xmath226 . we then prove the equivalent result : @ xmath227 we prove the results by simultaneous induction on the structure of @ xmath2 and @ xmath7 . the base case , thus @ xmath228 , is trivial . if @ xmath229 and @ xmath230 , then @ xmath2 and @ xmath7 are rp - invariant . with the ##izer @ xmath19 , then @ xmath231 and the statement for @ xmath7 follow in a similar way . if @ xmath229 and @ xmath232 , then @ xmath233 , and the statement follows from this . the base cases follow in a similar way , which is the proof of . we then prove the result and then by simultaneous induction on the structure of @ xmath2 and @ xmath7 . the base case , thus @ xmath228 , is also trivial . if @ xmath229 and @ xmath230 , then by the definition , @ xmath234 and simultaneous induction , @ xmath235 . the, @ xmath236 , and @ xmath237 and the distinction for @ xmath7 follow in a similar way . if @ xmath229 and @ xmath232 , the # ##s will follow in a similar way , although a bit different because @ xmath238 . for the other statements , the ' s will follow in a similar way . [ la : 3 . 5 ] for each @ xmath30 , @ xmath198 in each rp - basic form , and for each rp - basic form @ xmath1 , @ xmath239 . the first statement is called [ la : 3 . 5 ] . for the second statement , it follows the statement [ la : 3 . 7 ] to say that for each rp - basic form @ xmath1 , @ xmath205 . this follows from the statement for @ xmath1 . the forms @ xmath103 follow this , and then @ xmath104 , and otherwise @ xmath240 . by statement [ la : 3 . 7 ] , @ xmath241 and @ xmath##242 , then @ xmath205 . [ la : 3 . 8 ] for : @ xmath88 , @ xmath243 . we extend the analysis to @ xmath1 . the two statements @ xmath103 are equivalent . then @ xmath104 . by induction @ xmath244 . we obtain by the first statement of the analysis that @ xmath175 and @ xmath176 we have : 1 . if @ xmath245 with @ xmath246 , then @ xmath247 and @ xmath248 , and thus @ xmath249 , and thus @ xmath243 . 2 . if @ xmath250 and @ xmath251 with @ xmath107 , then @ xmath248 and by induction . by the statement of : [ la : 3 . 8 ] , @ xmath252 and @ xmath253 are rp - invariant ##s . we have @ xmath254 . . if @ xmath255 with @ xmath107 and @ xmath256 , we can obtain as followsthe previous case , now now using theorem 2 and the identity @ xmath247 , and the fact that @ xmath257 and @ xmath258 are rp - basic forms . if @ xmath250 and @ xmath256 , we can find . in the previous case , now using identity and , and the fact that @ xmath252 and @ xmath258 are rp - basic forms . + [ def : 3 . 9 ] for all @ xmath30 , @ xmath259 . by theorem [ la : 1a ] and theorem [ cor : 1 ] we have @ xmath260 . by theorem [ la : 3 . 9 ] , @ xmath261 , and @ xmath262 . [ def : 3 . 9 ] the binary of @ xmath263 , @ xmath34is defined as follows : @ xmath264 [ def : 3 . 9 ] for all @ xmath118 , @ xmath265 . and @ xmath266 . by theorem [ la : 3 . 9 ] , @ xmath267. . @ xcite the following two statements are equivalent ( theorem 2 . 5 and an additional statement for the proof ) , where @ xmath268 is a binary relation : @ xmath269 : 1 . for all @ xmath118 , @ xmath270 . 2 . for all rp - 1 , @ xmath1 and @ xmath271 . by theorem [ la : 2 . 5 ] these statements imply @ xmath272 , that is , @ xmath273 . = @ xmath273 . by theorem [ la : 3 . 6 ] , @ xmath274 . by theorem [ la : 1a ] , @ xmath275 . by theorem [ la : 2 . 5 ] , @ xmath266 . 3 , the relation @ xmath263 is axiomatized by @ xmath173 , and is therefore a relation . with this result in mind , we perform a sequence of evaluation trees that yields the relation @ xmath187 , and assume that each of the resulting evaluation trees is the relation that is axiomatized by @ xmath##173 . [ def : 1 . 0 ] the * * repetition - proof evaluation tree * @ xmath276 * * repetition - proof evaluation tree * and is defined by @ xmath277 the auxiliary function @ xmath278 is defined as : ( @ xmath53 ) : @ xmath279 for @ xmath53 , the auxiliary functions @ xmath280 and @ xmath281 are defined by @ xmath282 and @ xmath283 [ ex : rp ] : @ xmath284 . we use @ xmath68 ( as an example [ ex : r ] ) and the repetition - proof evaluation function @ xmath285 : @ xmath286 { ll } \ \ { l } [ - ] { l } \ \ [ - - - ] \ begin { tikzpicture } [ sibling distance = 2 . 5 mm , level 1 / . sibling = { sibling distance = 30 mm } , level 2 / . sibling = { sibling distance = 30 mm } , style = ( [ ( x . c ) ] \ end ( c ) { $ $ $ } = { current ( b1 ){ $ { \ ensuremath { { \ sf f } } } $ } } child { node ( b2 ) { $ a $ } } { node ( d1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( d2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } ; \ begin { tikzpicture } \ begin { array } & \ qquad \ begin { array } [ 1 ] { $ } \ \ [ - 1 ] ] \ qquad \ begin { tikzpicture } [ sibling distance = 2 . 5 mm , level 1 / . style = { sibling distance = 30 mm } , level 2 / . style = { sibling distance = 30 mm } , style = ( \ \ 2 . $ ) ] \ begin ( a ) { $ a $ } child { node ( b1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( b2 ) { $ } $ } child { node ( d1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( b##2 ) { $ { \ ensuremath { { \ sf ##t } } } $ } } } ; \ end { tikzpicture } \ \ [ - [ ] ] \ end { array } \ end { array } \ ] ] _ _ _ . _ the relationship between @ xmath287 and the array @ xmath187 can be proved : [ la : 3 . 14 ] for all @ xmath53 and @ xmath288 , @ xmath289 and + @ xmath290 . by structural induction on @ xmath41 ( cf . the proof of in [ la : 3 . 13 ] ) . we use the above examples for the proof of this ' s - 1 example . [ la : 3 . 14 ] for all @ xmath88 , @ xmath291 . we can get the equality theorem : @ xmath292 we prove the first case of by structural induction on @ xmath1 . the two cases @ xmath103 are proved . for the second case @ xmath207 , + @ xmath293 . we need to prove the case @ xmath194and @ xmath107 . if @ xmath194 , then @ xmath294 if @ xmath107 , then @ xmath295 the following statement can be proved in a similar way , and this is the proof of . the statement . . * appears as the following statement on @ xmath1 . the statements @ xmath103 follow immediately , and otherwise @ xmath207 , and otherwise @ xmath296 similarly , we obtain these statements by means of their repetition - proof . ##s . * repetition - proof the statement * , on @ xmath297 , is defined on @ xmath34 as follows : @ xmath298 the above statement almost certainly implies that @ xmath297 is a binary relation on @ xmath269 ( and hence , is it a relation ) . [ co : 1 . 1 ] for instance @ xmath118 , @ xmath299 . in order to construct @ xmath120 , if @ xmath300 , then @ xmath301 . the statements [ cor : 1 ] , @ xmat##h302 , so by proof [ la : 3 . 15 ] , @ xmath303 . by proof [ la : 3 . 15 ] and by proof ( like the proof of theorem [ la : 3 . 14 ] ) , it follows that @ xmath304 , that is , @ xmath273 . in order to construct @ xmath122 , then @ xmath273 , then @ xmath304 and @ xmath303 . by proof [ la : 3 . 15 ] , @ xmath302 . by proof [ cor : 1 ] , @ xmath305 and @ xmath306 , thus @ xmath301 , that is , @ xmath307 . we start this section with the first test we have given . [ la : 3 . 15 ] for example @ xmath118 , @ xmath308 , theorem [ la : 3 . 16 ] and theorem [ la : 3 . 16 ] . for @ xcite we have @ xmath309 , _ contractive _ @ xmath13 , and the replacement of @ xmath13 withthe following are the schemes , where @ xmath19 takes from @ xmath26 : @ xmath310 these schemes provide rules for proof of @ xmath19 for both the _ true _ - case and the _ false _ - case ( and for the others above ) . it also follows that the two schemes and are distinct from @ xmath309 , since @ xmath309 is simply an algebraic extension of @ xmath173 . thus , we have a finite set of basic forms with the property that any propositional formula can be proved equal to such a basic form . [ def : 1 . 0 ] * cr - basic forms * are inductively equivalent : * @ xmath25 and @ xmath9 are cr - basic forms , and * @ xmath174 is a cr - basic form if @ xmath175 and @ xmath176 are cr - basic forms , and if @ xmath177 is proved equal to @ xmath25 and @ xmath9 , the basic form of @ xmath177 is different from @ xmath19 . it may turn out that to check thenote that turns conditional statements into cr - basic functions , and that is equivalent to the function @ xmath143 ( see also [ def : bf ] ) . [ def : 4 . 2 ] the * cr - basic * function * @ xmath311 is defined by @ xmath312 the auxiliary function @ xmath313 is defined as follows : @ xmath314 for @ xmath53 , the auxiliary functions @ xmath315 and @ xmath316 are defined by @ xmath317 and @ xmath318 respectively , @ xmath319 sends the conditional statement @ xmath1 to @ xmath144 and then sends @ xmath144 back to the auxiliary functions @ xmath320 , @ xmath321 , and @ xmath322 . [ def : 4 . 2 ] for some @ xmath53 and @ xmath88 , @ xmath323 and @ xmath324 . for some @ xmath53 . we check these results by an analysis on @ xmath1 . the result and @ xmath103 are known .for the general case @ xmath193 we need to find the cases @ xmath194 and @ xmath107 . if @ xmath194 , then @ xmath325 and @ xmath326 , in a similar way . if @ xmath107 , then @ xmath327 , and hence @ xmath323 and @ xmath324 . [ la : 4 . 3 ] for example @ xmath30 , @ xmath328 is a cr - basic form . we can find the equivalent case : @ xmath329 this follows by induction from the case @ xmath87 of @ xmath1 . if @ xmath204 , then @ xmath103 , and hence @ xmath330 is a cr - basic form . for the general case @ xmath206 it will be the case that @ xmath207 . we find @ xmath331 which is a cr - basic form because * the cases [ la : 4 . 3 ] , @ xmath332 and @ xmath333 are basic forms with depth .than is equal to @ xmath211 , and by the null hypothesis , @ xmath334 and @ xmath335 are cr - basic forms , * by definition of the two cases @ xmath321 and @ xmath322 , the equality relation of @ xmath332 and @ xmath333 is also equal to @ xmath19 , so @ xmath336 is a cr - basic form . this completes the proof of . the proof of ##2 then follows by simultaneous induction : the two cases ( for a single proposition @ xmath19 ) are both equivalent , and for the third case , @ xmath337 for the basic form @ xmath94 has proposition [ la : bf ] , and therefore , @ xmath338 is a cr - basic form . the following , more formally , is stated for proposition [ la : 4 . 5 ] and proposition [ la : 4 . 7 ] . [ la : 4 . 8 ] if @ xmath224 is a cr - basic form , then @ xmath339 and @ xmath340 . by simultaneous induction , the case of @ x##math2 and @ xmath7 . the base case , namely @ xmath228 , is not empty . if @ xmath341 and @ xmath342 , then @ xmath343 and then @ xmath344 and @ xmath345 . similarly , @ xmath346 and @ xmath347 have a base case @ xmath3 , then @ xmath348 and @ xmath349 , and if @ xmath350 the statements for @ xmath7 follow in a similar way . if @ xmath351 and @ xmath352 , the ' s statements follow in a similar way , and this is also the case if @ xmath214 and @ xmath353 . with : [ la : 4 . 4 ] we can also get the following statements . [ la : 4 . 5 ] for each @ xmath30 , @ xmath328 has the cr - basic statement , and for each cr - basic , @ xmath1 , @ xmath354 . the following statement follows : [ la : 4 . 6 ] . forthe problem is , it follows by theorem [ la : 4 . 7 ] to prove that @ xmath330 . we do this by case induction on @ xmath1 . the cases @ xmath103 follow immediately , and then @ xmath104 , and otherwise @ xmath355 . by theorem [ la : 4 . 4 ] , @ xmath356 and @ xmath357 , hence @ xmath330 . [ la : 4 . 7 ] for all @ xmath88 , @ xmath358 . we perform case induction on @ xmath1 . the two cases @ xmath103 are equivalent . hence @ xmath104 . by theorem @ xmath359 . however , by this version of the proof of theorem [ la : 4 . 7 ] , @ xmath360 is a non - negative number , and by theorem [ la : 4 . 7 ] , @ xmath361 we have @ xmath362 [ la : 4 . 7 ] for all @ xmath30 , @ xmath363 . by theorem [ la : 1a ] andtheorem [ cor : 1 ] , @ xmath364 , and by theorem [ la : 4 . 7 ] , @ xmath365 , and @ xmath366 . [ def : 4 . 8 ] the binary relation @ xmath367 to @ xmath34is is as follows : @ xmath368 [ la : 4 . 7 ] for all @ xmath118 , @ xmath369 . then @ xmath370 . 2 , by theorem [ la : 4 . 4 ] , @ xmath371 . 2 @ xcite the following two statements are equivalent ( def 4 . 4 and the incorrect one is the following ) , where @ xmath372 is the binary relation to @ xmath269 : 1 . for all @ xmath118 , @ xmath373 . 2 . for all x - 1 , @ xmath1 and @ xmath374 . by theorem [ la : 4 . 7 ] , these statements satisfy @ xmath375 , that is , @ xmath376 . then @ xmath376 . by theorem [ la :2 . 8 ] , @ xmath377 . by theorem [ def : 1a ] , @ xmath378 . by theorem [ def : 2 . 8 ] , @ xmath370 . therefore , the relation @ xmath367 is axiomatized by @ xmath379 , and is therefore a relation . we can construct a relation on evaluation trees that yields the relation @ xmath319 , and note that one of two such equivalence relations is the relation that is axiomatized by @ xmath379 . [ def : 2 . 8 ] the relation * contractive auxiliary function * @ xmath380 yields * contractive evaluation tree * and is defined as @ xmath381 the auxiliary function @ xmath382 is defined as : ( @ xmath53 ) : @ xmath383 for @ xmath53 , the auxiliary functions @ xmath384 and @ xmath385 are defined as @ xmath386 and @ xmath387 for a simple example we use @ xmath388 and the contractive evaluation tree @ xmath389 :@ xmath286 { ll } \ begin { array } [ t ] { l } \ \ [ - 30 mm ] \ begin { tikzpicture } [ sibling distance = 7 . 5 mm , level 1 / . style = { sibling distance = 30 mm } , level 1 / . style = { sibling distance = 30 mm } , level 1 / . style = { sibling distance = 7 . 5 mm } ] \ node ( a2 ) { $ a $ } child { node ( b1 ) { $ a $ } child { node ( c1 ) { $ a $ } child { node ( d1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( d2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } child { node ( c2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } child { node ( b2 ) { $ { \ ensuremath { { \ sf f } } } $ } } ; \ begin { tikzpicture } \ begin { array } & \ qquad \ begin { array } [ t ] { l } \ \ [- 4 mm ] \ qquad \ begin { tikzpicture } [ sibling distance = 7 . 5 mm , level 1 / . style = { sibling distance = 15 mm } , level 2 / . style = { sibling distance = 15 mm } , level 1 / . style = { sibling distance = 7 . 5 mm } ] \ begin ( c1 ) { $ } $ } child { node ( c1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( b2 ) { $ { \ ensuremath { { \ sf f } } } $ } } ; \ begin { tikzpicture } \ \ [ 4 mm ] \ begin { array } \ begin { array } \ ] ] the equality between the base function @ xmath390 and the function @ xmath319 can be proved , and we use the following example for the proof of the next auxiliary result . [ x : 0 . 0 ] for instance @ xmath88 , @ xmath391 . we can prove the next auxiliary result : @ xmath392 we prove the following result by operator induction : @ xmath1 . the base function @xmath103 is conditional . for the special case @ xmath207 , see @ xmath293 . we want to consider the cases @ xmath194 and @ xmath107 . if @ xmath194 , then @ xmath393 if @ xmath107 , then @ xmath394 the first case can be solved in a similar way , and this is our proof of . the equality in ##2 also follows from the first equality in @ xmath1 . the cases @ xmath103 follow from , and thus @ xmath207 , and thus @ xmath395 here , we define conditional statements by means of their contractive properties ##s . [ def : 4 . 15 ] * contractive - conditional * , on @ xmath396 , is conditional on @ xmath34as for : @ xmath397 the first conditional statement also implies that @ xmath396 is a binary conditional on @ xmath269 ( and hence , calling it a conditional ) . [ def : 4 . 15 ] for : @ xmath118 , @ x##math398 . in order to prove @ xmath120 , assume @ xmath399 , thus @ xmath400 . by assumption [ cor : 1 ] , @ xmath401 , and by assumption [ la : 4 . 13 ] , @ xmath402 . by assumption [ la : 2 . 4 ] and final result ( from the statement of theorem [ la : 2 . 4 ] ) , it follows that @ xmath403 , that is , @ xmath376 . in order to prove @ xmath122 , assume @ xmath376 , thus @ xmath403 and @ xmath402 . by assumption [ la : 4 . 13 ] , @ xmath401 . by assumption [ cor : 1 ] , @ xmath305 and @ xmath306 , thus @ xmath400 , that is , @ xmath404 . our final result in this case is the final result for contractive . ##s . [ la : 4 . 13 ] for example @ xmath118 , @ xmath405 , with [th : 4 . 15 ] and in [ th : 4 . 15 ] . in @ xcite we write @ xmath406 , _ _ @ xmath13 _ , for the extension of @ xmath13 with the following properties : @ xmath407 _ states that the first evaluation value of @ xmath16 is known . more precisely , " _ @ " is written with the property that upon the evaluation of a given propositional formula , the first evaluation value of the formula is known after the evaluation . we write @ xmath406 for the extension @ xmath408 of atoms . replacing the variable @ xmath16 _ _ by @ xmath409 and / or the variable @ xmath410 by @ xmath411 yields the _ evaluation values : @ xmath412 hence , if we write _ _ @ xmath410 and @ xmath45 , we get the _ contraction law _ @ xmath413 and replacing @ xmath16 by @ xmath409 _ yields the _ contraction law @ xmath414 therefore , @ xmath##406 is an infinite subset of @ xmath379 . we have a finite set of basic forms with the property that no propositional form can be considered equivalent to such a basic form . [ def : 5 . 1 ] let @ xmath415 be a subset of it . * meta - basic forms over @ xmath415 * are inductively defined : * @ xmath25 and @ xmath9 are meta - basic forms over @ xmath415 , and * @ xmath416 is a meta - basic form over @ xmath415 if @ xmath417 and @ xmath1 and @ xmath2 are meta - basic forms over @ xmath418 . @ xmath1 is a * meta - basic form * if for all @ xmath419 , @ xmath1 is a meta - basic form over @ xmath415 . note that if @ xmath26 is finite , the set of meta - basic forms is also finite . it may turn out impossible to define a function that converts logical expressions into meta - basic forms . [ def : 5 . 1] the * * - long auxiliary function * @ xmath420 is defined by @ xmath421 the auxiliary function @ xmath422 is defined as follows : @ xmath423 for @ xmath53 , the auxiliary functions @ xmath424 and @ xmath425 are defined by @ xmath426 and @ xmath427 respectively , @ xmath428 is the base case @ xmath1 to @ xmath144 and then to @ xmath144 and to the auxiliary functions @ xmath429 , @ xmath430 , and @ xmath431 . we can use the following examples . [ 1 : 1 . 0 ] for comparison @ xmath432 with @ xmath433 and @ xmath88 , @ xmath434 performs the transformations of @ xmath1 . the base cases @ xmath103 are defined . for the base case @ xmath435 we have to consider two cases : 1 . if @ xmath436 , then equality follows by @ xmath437 and division follows by @ xmat##h438 , and can be proved in a similar way . 2 . if @ xmath439 , then equality follows by @ xmath440 and equality follows by @ xmath441 , and can be proved in a similar way . 3 . if @ xmath442 , then equality follows by @ xmath443 and @ xmath444 can be proved in a similar way . [ la : . . . ] for some @ xmath53 and @ xmath88 , @ xmath445 and @ xmath446 . for all @ xmath53 . we prove these results by an induction on @ xmath1 . the base cases @ xmath103 are identical . for the base cases @ xmath193 we need to compare the cases @ xmath194 and @ xmath107 . if @ xmath194 , then @ xmath447 and @ xmath448 follows in a similar way . if @ xmath107 , then @ xmath449 and @ xmath450 follows in a similar way . [ la : .. . ] for all @ xmath30 , @ xmath451 is a meta - basic form . we can give the auxiliary form : @ xmath452 this follows by induction for the subset @ xmath87 of @ xmath1 . if @ xmath204 , then @ xmath103 , and then @ xmath453 is a meta - basic form . for the auxiliary form @ xmath206 it would be the case that @ xmath207 . we have @ xmath454 which is a meta - basic form because by definition [ 1 : 1 . 5 ] , @ xmath455 and @ xmath456 are basic forms with depth less than or equal to @ xmath211 , and by the null hypothesis , @ xmath457 is a meta - basic form over @ xmath458 and @ xmath459 is a meta - basic form over @ xmath460 for all both @ xmath458 and @ xmath460 of @ xmath26 . note that the sets of @ xmath430 and@ xmath431 we can see that the atom @ xmath19 does not exist in @ xmath461 . therefore , @ xmath462 is a super - basic form over @ xmath463 , which completes the proof of . the proof of ##3 then follows , by definition : the basic forms ( with a single atom @ xmath19 ) are : : , and for the general case , @ xmath464 for the basic form @ xmath94 the formula [ la : bf ] , and therefore , @ xmath465 is a super - basic form . the same formula is true for proposition [ la : 5 . 6 ] and proposition [ la : 5 . 6 ] . [ la : 5 . 6 ] if @ xmath224 is a super - basic form , then @ xmath466 and @ xmath467 . then @ xmath224 is a super - basic form over @ xmath415 . by definition , @ xmath2 and @ xmath7 are super - basic forms over @ xmath468 . we see that pairs of atomsstart by working in the case of @ xmath2 and @ xmath7 . the second case , namely @ xmath228 , is trivial . if @ xmath341 and @ xmath342 , then @ xmath469 and @ xmath470 . however , the @ xmath98 are super - basic forms of @ xmath471 , then @ xmath472 and @ xmath473 , and for @ xmath474 the expressions for @ xmath7 follow in a similar way . if @ xmath351 and @ xmath352 , the ' sums ' follow in a similar way , and this is also the case if @ xmath214 and @ xmath353 . with : [ la : 5 . 5 ] we can also get the following statement . [ la : 5 . 6 ] for each @ xmath30 , @ xmath451 is a super - basic form , and for each super - basic form @ xmath1 , @ xmath475 . the following statement is : [ la : 5 . 5 ] . forthe first case , , is by induction [ la : 2 . 5 ] to prove that @ xmath453 . we prove this by the induction on @ xmath1 . the cases @ xmath103 follow immediately , and hence @ xmath104 , hence @ xmath476 . by induction [ la : 2 . 5 ] , @ xmath477 and @ xmath478 , hence @ xmath453 . [ la : 5 . 8 ] for all @ xmath88 , @ xmath479 . we proceed by induction to @ xmath1 . the two cases @ xmath103 are proved . hence @ xmath104 . by induction @ xmath480 . then , with the arguments in the form of : [ la : 5 . 8 ] , @ xmath481 is a mn - basic form , and @ xmath482 are mn - basic forms of @ xmath483 , and from @ xmath484 we get @ xmath485 [ la : 5 . 8 ] for all @ xmath30 , @ xmath48##6 . by theorem [ la : 1a ] and theorem [ cor : 1 ] , @ xmath487 , and by theorem [ def : 5 . 8 ] , @ xmath488 , and @ xmath489 . [ def : 5 . 10 ] the binary relation @ xmath490 to @ xmath34is is as follows : @ xmath491 [ def : 5 . 8 ] for all @ xmath118 , @ xmath492 . and @ xmath493 . then , by theorem [ la : 5 . 8 ] , @ xmath494 . then @ xcite the following two statements are equivalent ( theorem 8 . 3 and theorem 8 . 4 ) , where @ xmath495 is a binary relation : @ xmath269 : 1 . for all @ xmath118 , @ xmath496 . 2 . for all non - negative values @ xmath1 and @ xmath497 . by theorem [ def : 5 . 10 ] these statements satisfy @ xmath498 , that is , @ xmath499 . then @ xmat##h499 . by theorem [ def : 5 . 12 ] , @ xmath500 . by theorem [ la : 1a ] , @ xmath501 . by theorem [ la : 5 . 12 ] , @ xmath493 . however , the relation @ xmath490 is axiomatized by @ xmath406 and is not a relation . we define a relation on transformed trees that is the relation @ xmath428 , and note that addition of two different transformed trees yields the relation that is axiomatized by @ xmath406 . [ def : 5 . 12 ] the relation * the auxiliary function * @ xmath502 for * on transformed trees * and is defined by @ xmath503 the auxiliary function @ xmath504 is defined by * ( @ xmath53 ) : @ xmath505 for @ xmath53 , the auxiliary functions @ xmath506 and @ xmath507 are defined by @ xmath508 and @ xmath509 . a simple example we call @ xmath510 and the memoriz##ing ##ame : @ xmath511 : @ xmath512 \ node ( a1 ) { $ a $ } child { node ( b1 ) { $ a $ } child { node ( c1 ) { $ a $ } child { node ( d1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( d2 ) { $ { \ ensuremath { { \ sf t } } } $ } } } child { node ( c2 ) { $ { \ ensuremath { { \ sf t } } } $ } } } child { node ( b2 ) { $ { \ ensuremath { { \ sf f } } } $ } } ; \ begin { tikzpicture } \ begin { array } & \ qquad \ begin { array } { array } \ qquad \ begin { tikzpicture } [ sibling distance = 7 . 5 mm , level 1 / . style = { sibling distance = 30 mm } , level 2 / . style = { sibling distance = 30 mm } , level 3 / . style = { sibling distance = 7 . 5 mm } ] \ node ( c1 ) { $ a $ } child { node( b1 ) { $ { $ } child { node ( c1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( c2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } child { node ( b2 ) { $ { \ ensuremath { { \ sf f } } } $ } } ; \ end { tikzpicture } \ \ [ [ array ] \ begin { array } \ end { array } \ ] ] the differences between @ xmath513 and the original @ xmath428 should of course be noted . [ la : 5 . 13 ] for all @ xmath432 with @ xmath433 and @ xmath288 , * @ xmath514 , * @ xmath515 , * @ xmath516 , * @ xmath517 . is an extension of @ xmath41 ( cf . the proof of above [ la : 5 . 13 ] ) . we need the 2 ' s for the proof of our original above proof . [ la : 5 . 13 ] for all @ xmath53 and @xmath88 , @ xmath518 we now prove the second case : @ xmath519 fix some @ xmath53 . we prove this by induction on @ xmath1 . the auxiliary cases @ xmath103 are trivial . for the base case @ xmath193 we have to distinguish the cases @ xmath194 and @ xmath107 . if @ xmath194 , then @ xmath520 and if @ xmath107 , then @ xmath521 this is the case of . we now prove the ' s case . fix some @ xmath53 . we prove the first case by induction on @ xmath87 . the base case @ xmath204 , then @ xmath103 , is trivial . for the auxiliary case @ xmath206 , it will be the case that @ xmath193 . we have to distinguish the cases @ xmath194 and @ xmath107 . if @ xmath194 , then @ xmath522 if @ xmath107 , then @ xmath523the second equality can be defined in a similar way . [ def : 5 . 15 ] for all @ xmath88 , @ xmath524 . note the name starts with @ xmath1 . the arguments @ xmath103 are this , and otherwise @ xmath207 , and otherwise @ xmath525 [ def : 5 . 17 ] * the third function * , called @ xmath526 , is defined on @ xmath34as ##p : @ xmath527 the first equality defined above means that @ xmath526 is the function defined on @ xmath269 ( and otherwise , making it a function ) . [ def : 5 . 17 ] for all @ xmath118 , @ xmath528 . for @ xmath120 , then @ xmath529 , then @ xmath530 . by definition [ cor : 1 ] , @ xmath531 , by definition [ la : 2 . 15 ] , @ xmath532 by definition [ la : 3 . 15 ] , it means that @ xmath533, that is , @ xmath499 . in order to get @ xmath122 , then @ xmath499 , then @ xmath533 . then @ xmath534 and by theorem [ la : 5 . 11 ] , @ xmath535 by theorem [ cor : 1 ] , @ xmath530 , that is , @ xmath536 . we end this section with the following theorem for the first time . [ la : 5 . 11 ] for all @ xmath118 , @ xmath537 by theorem [ la : 5 . 15 ] and then [ la : 5 . 18 ] . the first possible logical value of @ xmath13 we have to be obtained by adding the following terms to @ xmath406 : @ xmath538 therefore , the truth value of each atom in a given set is 1 , and by definition , each atom @ xmath19 will have a different value because @ xmath539 for all @ xmath30 . we get @ xmath540 for the rest of these atoms , and @xmath541 shows that the contraction theorem also holds for @ xmath540 , in particular , @ xmath542 . a simple example of @ xmath540 shows how the order of evaluation of @ xmath17 and @ xmath16 can be swapped : @ xmath543 this can be expressed as follows : @ xmath544 the contraction theorem is a direct consequence of this . [ sec : 1 . 1 ] for example @ xmath118 , @ xmath545 . @ xmath546 , @ xcite we define @ xmath547 as the complement of @ xmath13 with the following two conditions : @ xmath548 this illustrates how the order of evaluation of @ xmath410 and @ xmath16 can be swapped , and ( as in : [ sec : 2 ] ) the second condition ensures that the original order of @ xmath16 is correct . because we cannot rely on formulas for @ xmath547 that are valid for @ xcite , we will use the contraction theorem . [ sec : 3 ] the two formulas @ xmath549 and@ xmath540 is more likely . we show that all statements in the one set are derived from the other set . we also show that the theorem is derived from @ xmath549 : @ xmath550 where the contraction law , that is @ xmath551 , is derived from @ xmath549 : : @ xmath16 : @ xmath409 ##1 . = @ xmath552 . similarly , if we replace @ xmath553 with , we get @ xmath554 , and @ xmath555 . in order to prove that @ xmath556 proves that the contraction law is derived from @ xmath406 ( see : [ ref : ref ] ) . however , it has to be proved that @ xmath557 and with it we can also derive this theorem from @ xmath540 : @ xmath558 given a finite , complete set of statements we have a finite set of basic forms with the property that any propositional statement in these forms can be proved according to such a basic form . [ def : 1 . 0 ] . @xmath559 is the set of forms over @ xmath26 with the property that [ @ xmath560 has all possible values of the empty string . for the empty string , return @ xmath561 . ] * st - basic forms over @ xmath562 * are defined as follows : * @ xmath25 and @ xmath9 are st - basic forms over @ xmath563 . * @ xmath416 is an st - basic form over @ xmath564 if @ xmath1 and @ xmath2 are st - basic forms over @ xmath565 . @ xmath1 is a * st - basic form * if for * @ xmath560 , @ xmath1 is an st - basic form over @ xmath78 . for example , an st - basic form over @ xmath566 has the following properties : @ xmath567 with @ xmath568 . for @ xmath569 , there are @ xmath570 and st - basic forms over @ xmath78 . it may turn out impossible to define a function that takes these formsto st - basic form . similarly , for @ xmath562 we have terms over @ xmath571 , where @ xmath415 is the smallest term of @ xmath26 that is the term of @ xmath78 . if @ xmath64 , let @ xmath572 and the st - basic terms over @ xmath563 be @ xmath25 and @ xmath9 . [ def : 6 . 4 ] the * alphabet function * @ xmath573 maps the number of strings of a string * @ xmath574 : @ xmath575 [ def : 6 . 4 ] to @ xmath562 . the string function @ xmath576 is defined as @ xmath577 the * st - basic string function * @ xmath578 is defined as @ xmath579 if , for instance @ xmath562 , @ xmath580 is an st - basic form over @ xmath78 in which the term @ xmath25 does not exist , e . g . , @ xmath581 [ def : 6 . 4 ] let @ xmat##h562 . for some @ xmath30 , @ xmath582 . by induction on the structure of @ xmath78 . if @ xmath64 , then @ xmath583 and @ xmath584 if @ xmath585 for some @ xmath586 and @ xmath53 , then @ xmath587 , and then @ xmath588 [ 1 : 0 . 5 ] and @ xmath562 . for some @ xmath589 , @ xmath590 has an st - dos implementation . we have two basic forms : @ xmath591 . \ text { ~ } \ ] ] this expression follows by induction on the structure of @ xmath78 . @ xmath592 ) = e ^ \ \ [ { \ ensuremath { { \ sf f } } } \ mapsto \ text _ a ( { \ ensuremath { \ mathit { bf } } } ( x ) ) ] \ \ [ [ e ] \ text { and ~ } ~ { ~ } _ a ( ( e ^ \ \ [ { \ ensuremath { { \ sf }} } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p ) ] ) = a ^ \ { [ { \ ensuremath { { \ sf } } } } \ mapsto { align } _ { ( { \ ensuremath { \ mathit { bf } } } ( p ) ) ] , \ begin { align } \ end { align } \ ] ] the following follows , by induction on the structure of @ xmath565 . we obtain the following above , by induction on the structure of @ xmath78 . if @ xmath64 , then @ xmath1 has this structure . otherwise , @ xmath593 . if @ xmath160 then @ xmath594 which is the st - p case of @ xmath563 , and similarly for the case @ xmath163 . if @ xmath585 for ( @ xmath586 and @ xmath53 , we have @ xmath595 ) & & \ end { x ~ \ eqref { aux : s1 } } \ \ & = { \ ensuremath { \ mathit {$ } } } ( ( e ^ \ & { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } e ^ \ & ) [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p ) ] ) \ \ & = { \ ensuremath { \ mathit { bf } } } ( e ^ \ & [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p ) ] { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } e ^ \ & [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( e) ] ) \ \ & = { \ ensuremath { \ mathit { bf } } } ( \ math _ { a } ( e ^ \ } [ { \ ensuremath { { \ sf } } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p ) ] ) ) { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } { \ ensuremath { \ mathit { bf } } } ( { a } _ { a } ( e ^ \ } [ { \ ensuremath { { \ sf } } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( p ) ] ) ) \ \ & = { \ ensuremath { \ mathit { bf } } } ( e ^ \ } [ { \ ensuremath { { \ sf } } } } \ mapsto \ math _ { a } ( { \ ensuremath { \ mathit { bf } } } (( ) ) ] ) { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } ) { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } { \ ensuremath { \ mathit { bf } } } ( e ^ \ text [ { \ ensuremath { { \ sf f } } } \ mapsto { a } _ { a } ( { \ ensuremath { \ mathit { bf } } } ( p ) ) ] ) & & \ text { a ~ \ eqref { aux : s2 } } \ \ & = { \ ensuremath { \ mathit { bf } } } ( e ^ \ text [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( \ text _ { a } ( { \ ensuremath { \ mathit { bf } } } ( p ) ) ) ] ) { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } {{ \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } { \ ensuremath { \ mathit { bf } } } ( e ^ \ text [ { \ ensuremath { { \ sf f } } } \ mapsto { \ ensuremath { \ mathit { bf } } } ( { a } _ { a } ( { \ ensuremath { \ mathit { bf } } } ( p ) ) ) ] ) & & \ text { \ text ~ \ text { 1 : 1 . 0 } } \ \ & = { \ ensuremath { \ mathit { bf } } } ( { \ ensuremath { \ mathit { bf } } } ( { \ ensuremath { { \ sf f } } } { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } e ^ \ text { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } \ text _ { a } ( { \ ensuremath { \ mathit { bf } } } ( p ) ) )) { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } { \ ensuremath { \ mathit { bf } } } ( { \ ensuremath { \ mathit { bf } } } ( { \ ensuremath { { \ sf ##f } } } { { \ raisebox { 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } e ^ \ { { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } { a } _ { $ } ( { \ ensuremath { \ mathit { bf } } } ( p ) ) ) ) & & \ { { $ ~ \ eqref { aux : s1 } } \ \ & = { \ ensuremath { \ mathit { sbf } } } _ \ { ( \ } _ { a } ( { \ ensuremath { \ mathit { bf } } } ( p ) ) ) { { \ raisebox{ 0pt } { \ footnotesize $ \ ; \ triangleleft ~ $ } } } } { { \ raisebox { 0pt } { \ footnotesize $ ~ \ triangleright \ ; $ } } } { \ ensuremath { \ mathit { sbf } } } _ \ left ( { f } _ { f } ( { \ ensuremath { \ mathit { bf } } } ( 1 ) ) ) , \ left { f } \ ] ] where the first example is an extension to @ xmath565 because @ xmath596 and @ xmath597 are equivalent forms over @ xmath598 ( namely , both over @ xmath19 ) . by definition , @ xmath599 and @ xmath600 are st - basic forms over @ xmath565 . thus , @ xmath590 is an st - basic form over @ xmath78 . [ la : 6 . 6 ] , @ xmath562 . for example @ xmath589 , @ xmath601 . by definition [ la : 6 . 6 ] , @ xmath582 . by definition [la : 5 . 8 ] , @ xmath602 , and @ xmath601 . [ la : 5 . 9 ] , @ xmath562 . for all @ xmath603 , @ xmath604 . then @ xmath605 . 1 , by proposition [ la : 6 . 8 ] , @ xmath606 , and by proposition [ la : 7 ] , @ xmath607 . then @ xcite the following two statements are equivalent ( proposition 1 . 3 and an alternative statement in the following ) , where @ xmath608 is a binary operation . @ xmath269 : 1 . for all @ xmath118 , @ xmath609 . 2 . for the st - sql statements @ xmath1 and @ xmath610 . by proposition [ la : 6 . 8 ] these statements imply @ xmath611 . then @ xmath611 , and hence @ xmath612 . by proposition [ la : 5 . 5 ] , @ xmath613 , and by proposition [ la : 5 . 6 ] this implies @ xmath605 .[ def : 6 . 8 ] let @ xmath562 . the binary relation @ xmath614 → @ xmath615 is defined as follows : @ xmath616 [ def : 6 . 8 ] let @ xmath562 . for all @ xmath603 , @ xmath617 . let @ xmath605 . by theorem [ la : 6 . 8 ] , @ xmath606 , and by theorem [ la : 6 . 8 ] , @ xmath618 . let @ xmath618 , and let @ xmath611 . by theorem [ la : 6 . 8 ] , @ xmath619 . therefore , the relation @ xmath614 is a property of @ xmath615 that is axiomatized by @ xmath540 . we perform a computation on these relations that yields the relation @ xmath620 and note that addition of two such binary relations yields the relation that is axiomatized by @ xmath540 . [ def : 6 . 11 ] let @ xmath562 . the relation *static evaluation tree * @ xmath621 . * static evaluation tree * and is shown as follows : @ xmath622 where @ xmath580 is used for : [ def : st . 0 ] . [ def : st ] . @ xmath623 . we have @ xmath68 at the left - hand side . the static evaluation tree @ xmath624 is depicted in the middle , and the static evaluation tree @ xmath625 is depicted at the right - hand side : @ xmath626 \ end ( a2 ) { $ a $ } child { node ( b1 ) { $ a $ } child { node ( c1 ) { $ a $ } child { node ( d1 ) { $ { \ ensuremath { { \ sf t } } } $ } } child { node ( d2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } child { node ( c2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } child { node ( b2 ) { $ { \ ensuremath { { \ sf f } } } $ } } ; \ end { tik##zpicture } \ begin { l } & \ qquad \ begin { array } { $ } \ qquad \ begin { tikzpicture } [ sibling distance = 7 . 5 mm , level 1 / . style = { sibling distance = 8 mm } , level 1 / . style = { sibling distance = 7 . 5 mm } , level 1 / . style = { sibling distance = 7 . 5 mm } ] \ begin ( a ) { $ a $ } child { node ( b1 ) { $ b $ } child { node ( c1 ) { $ { \ ensuremath { { \ sf t } } } $ } } child { node ( c2 ) { $ { \ ensuremath { { \ sf t } } } $ } } } child { node ( b2 ) { $ b $ } child { node ( c3 ) { $ { \ ensuremath { { \ sf t } } } $ } } child { node ( c4 ) { $ { \ ensuremath { { \ sf t } } } $ } } } ; \ begin { tikzpicture } \ \ [ 2 ] ] \ begin { array } & \ qquad \ begin { array } { $} \ qquad \ begin { tikzpicture } [ sibling distance = 7 . 5 mm , level 1 / . style = { sibling distance = 7 mm } , level 2 / . style = { sibling distance = 7 . 5 mm } , level 3 / . style = { sibling distance = 7 . 5 mm } ] \ begin ( a1 ) { $ a $ } child { node ( b1 ) { $ a $ } } { node ( c1 ) { $ { \ ensuremath { { \ sf t } } } $ } } child { node ( c2 ) { $ { \ ensuremath { { \ sf t } } } $ } } } child { node ( b2 ) { $ a $ } } { node ( c3 ) { $ { \ ensuremath { { \ sf t } } } $ } } child { node ( c4 ) { $ { \ ensuremath { { \ sf t } } } $ } } } ; \ begin { tikzpicture } \ \ [ [ array ] \ begin { array } \ begin { array } \ ] ] the two different tree - types correspond to the two trees on which we can build the tables for @ xmath1 ,that is , the following partial list of the # ##s of the variables used in @ xmath1 : @ xmath627 _ . _ . _ the reason that @ xmath628 is implemented similarly to the @ xmath562 that contains the rest of @ xmath1 is that in order to achieve equivalence of @ xmath540 ( and @ xmath547 ) , we need to be able to use two trees that have equal numbers of nodes , such as for instance @ xmath629 and that are both static search trees . for @ xmath630 and @ xmath631 the static evalution trees for both are @ xmath632 and @ xmath633 , respectively @ xmath634 \ node ( a1 ) { $ a $ } child { node ( b1 ) { $ b $ } child { node ( c1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( c2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } child { node ( b2 ) { $ c $ } child { node ( c3 ){ $ { \ ensuremath { { \ sf f } } } $ } } child { node ( c4 ) { $ { \ ensuremath { { \ sf f } } } $ } } } ; \ begin { tikzpicture } \ begin { array } & \ qquad \ begin { array } { $ } \ qquad \ end { tikzpicture } [ level 0 = 7 . 5 mm , level 1 / . style = { sibling distance = 30 mm } , level 2 / . style = { sibling distance = 30 mm } , level 3 / . style = { sibling distance = 7 . 5 mm } ] \ node ( a1 ) { $ a $ } child { node ( b1 ) { $ a $ } } { node ( c1 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( c2 ) { $ { \ ensuremath { { \ sf f } } } $ } } } child { node ( b2 ) { $ a $ } } { node ( c3 ) { $ { \ ensuremath { { \ sf f } } } $ } } child { node ( c4 ) { $ { \ensuremath { { \ sf ##t } } } $ } } } ; \ end { tikzpicture } \ end { array } \ end { array } \ ] ] the similarity between @ xmath635 and the notation @ xmath620 can be observed and lead to our final characterization theorem . [ def : 6 . 12 ] let @ xmath560 . * * a crossing over @ xmath78 * , called @ xmath636 , is defined on @ xmath615 as follows : @ xmath637 the final characterization theorem also shows that for all @ xmath562 , @ xmath636 is a crossing over on @ xmath615 . [ def : 6 . 12 ] let @ xmath562 . for all @ xmath603 , @ xmath638 we need to define @ xmath639 and this also follows from theorem [ def : 6 . 12 ] . [ def : 6 . 12 ] let @ xmath560 . for all @ xmath603 , @ xmath640 . let [ def : 6 . 12 ] andsee [ 1 : 1 . 1 ] . in @ xcite we defined proposition algebra _ hoare - conditional @ xmath641 and the valuation @ xmath8 and @ xmath45 . we introduced a number of types of so - called _ valuation ##s _ in order to provide a framework for the definition of valuation ##s , and provided axiomatizations for the static valuation ##s : @ xmath642 ( two properties ) defines the most identifying valuation that we have , and the valuation @ xmath406 ( one - property ) defines the least identifying valuation . in propositional logic , the static valuation ##s , axiomatized by applying the static valuation @ xmath554 to @ xmath406 , can be defined as a subset of propositional logic . in @ xcite we provided an additional abstract framework for proposition algebra in the form of _ hoare - conditional logic _ ( hma based ) that is more abstract than the semantical framework provided in @ xcite : hma - conditional logic has the advantage that we can define a valuation _ without necessarily including the property _ property _ that is present in. in this section , we use staudt ' s tree @ xcite to define free valuation ##s for the relation @ xmath111 ( by theorem [ sec : free ] ) , and this proves to be a very simple and stand - alone definition , resulting in a semantics that is faster and much simpler than hma - based on @ xcite and the semantics used in @ xcite . by theorem [ sec : free ] , @ xmath111 agrees with ` ` free valuation ' as defined in @ xcite ' ' because both relations are axiomatized in @ xmath642 ( see ( * ? ? ? * 1 . 4 . 1 and 1 . 4 . 2 ) ) . the property of ` ` evaluation tree ' ' ' is that for a given logical relation @ xmath1 , the evaluation tree @ xmath68 contains all its atoms , and @ xmath123 is represented by evaluation trees that contain no more atoms than those that exist in @ xmath1 and @ xmath2 , which corresponds to the notion of truth value in propositional logic . by theorem [ sec : rp ] we use non - free valuation cong##ruence @ xmath297 and @ xmath269 = @ xmath307 if , and else if @ xmath300 , where @ xmath643 and @ xmath644 is the following sequence of evaluation ##s . it is known that this equivalence is ` ` ' ' ' , given the fact that @ xmath645 and that has consequences for @ xmath173 . the equivalence relation @ xmath269 that we want to simulate is @ xmath646 , which @ xmath297 replaces with ` ` natural - relation - on relation - on @ xcite ' ' because both are axiomatized on @ xmath173 ( * ( * ? ? ? * 3 . 2 . 3 ) ) . however , this implies that @ xmath297 is a _ natural _ relation on @ xmath34 and we could not find a natural extension of this equivalence . we want to compare the equivalence @ xmath287 with the equivalence @ xmath187 using evaluation ##s and to prove that the resulting extension of @ xmath263 is an _ axiomatizedand @ xmath173 . this is proposition [ prop : 3 . 8 ] , the truth of which depends on ( * ? ? ? * 3 . 8 . 1 ) ) _ and _ _ theorem [ prop : 3 . 11 ] , that is , @ xmath647 in order to prove this ( which is proposition [ prop : 3 . 11 ] ) , it is not necessary to show that @ xmath263 and @ xmath297 agree , and this is theorem [ prop : 3 . 12 ] . the result of our proof of the axiomatizations of the various valuation systems that we have is fairly simple , although the case for the # ##s is a much more complicated one ( if we return to this section ) . however , these axiomatizations are equivalent : the valuation systems @ xmath173 up to and including @ xmath540 all satisfy the conditions of @ xmath13 , and the valuation system is modified by the addition of either one or two systems , in both cases rendering the existing system ( s ) obsolete . for the @ xmath562 , this means that .@ xmath615 , @ xmath648 where all these statements are true if @ xmath649 , and thus @ xmath650 , and thus @ xmath651 . we show that valuation - based evaluation trees and the proof of @ xmath297 give a full - fledged , consistent and complete proof for @ xmath173 , and that this is also the case for contractive evaluation trees and the valuation relation @ xmath396 , and for evaluation trees and the valuation relation @ xmath526 . a # ##s : @ xmath615 for example @ xmath562 , consistent with all possible statements of propositional logic in the following example : @ xmath652 where @ xmath653 and @ xmath654 refer to hoare . an @ xcite : @ xmath655 , @ xmath53 . the fact that @ xmath656 is stronger than @ xmath526 is also true : @ xmath657 . it is easy to prove that @ xmath658 . our proof that @ xmath##540 , and so @ xmath547 is an axiomatization of . the theory is much more complicated than those for the other axiomatizations because atoms of a conditional statement @ xmath1 do not have a natural ordering for the values of their atoms , and therefore , the atoms as given by the atomic binary operation should be contained in . to this end , we use some @ xmath562 . a spin - off of our theory can be called ` ` basic type theory for abstract languages ' ' : for every equivalence class # ##ᵢ , the conditional statements have c - basic forms if , and , if , they have their c - basic forms , where c - basic forms are generated by a linear combination of conditional statements , which is a form of division . it is easy , but not easy to prove that for some @ xmath562 , the operation @ xmath620 is the binary operation of @ xmath615 . in addition to proving [ 1 : 1 . 0 ] this means , that for every st - basic statement @ xmath1 , @ xmath78 , @ xmath659 . wealong with a short section on _ short - circuit logic _ , which we found in @ xcite ( see @ xcite for a brief overview ) , and an update on the definition of @ xmath173 . other logical expressions that arise in the language of logic , and that prescribe short - circuit logic , such as ` & & ` ( in english , ` ` ' and ' ' ) , are often defined in the following way : @ xmath660 consists of the equivalent definitions of @ xmath1 and @ xmath2 , respectively , @ xmath661 . in a similar way , it can be defined in @ xmath662 . short - circuit logic based on the language @ xmath663 a common approach to this problem is to define the conditional as an independent variable , as was done in @ xcite , and to replace it with elements of the basic propositional calculus described above and the axiomatization for the # ##s of variables in the conditional ( or , if ` ` ' ' and ' ' are at hand , axiomatizations for the corresponding valuation ##s ) . an alternative and more general approach to this is tosee axiomatizations for short - circuit conditional logic in which the conditional is _ _ _ true . for binary valuation ##s , an equational axiomatization of short - circuit binary propositional calculus was given by staudt in @ xcite , where @ xmath664 $ ] and @ xmath665 $ ] ( and @ xmath51 is also used for short - circuit ##ing ) , and the following existence theorem is based on # ##s of the evaluation trees . for repetition - proof conditional logic it is an open question whether a complete , equational axiomatization of the short - circuit ##ed propositional calculus exists , and the set of repetition - proof evaluation trees used for such programs may be of interest in this context . we start with an example of the program of @ xmath173 that is based on ( * ? ? ? * 3 . 0 ) . [ example : rp2 ] in @ xmath26 ##3 a pair of programs of the form ` ( n = = d ' ) ` and ` ( n = e ) ` with @ xmath666 an example program , and @ xmat##h667 provides definitions for the atoms that always evaluate @ xmath666 . note that ` ( e = = 0 ' ) ` evaluate to @ xmath10 if @ xmath668 and @ xmath669 contain the same integer , and ` ( e = 0 ) ` will evaluate to _ true _ with the assumption that @ xmath668 initial value is equal to @ xmath666 . all these atoms have the properties of @ xmath173 . different from @ xmath173 , e . g . , @ xmath670 . we note that a good example of @ xmath173 in the context of short - form programming is @ xmath671 ( cf . example [ ex : rp ] ) , and that example [ ex : rp2 ] is similar to the example of wortel @ xcite , where an example of _ propositional _ programming _ @ xcite was developed in which atoms can be turned into tests ; the assumption that the tests always evaluate to _ true _ is false because the assumption that they always evaluate is false . ] note that if @ xmath666 has initial value 0 ,however , @ xmath672 and @ xmath673 evaluate to different values , and the valuation ` ( n = n + 1 ) ` does not satisfy the condition @ xmath674 , for which this valuation is valid for the non - proof ##s of @ xmath173 . _ for _ . _ we therefore conclude that the proof ##s given in this article can be used as a basis for the investigation of the number of _ _ _ _ that _ occur upon the set of short - lived neurons as an input [ p : rp ] , and we use these words of parnas @ xcite : _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ __ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ` ` most programming methods treat side effects with a simple programming method . but , with well - designed , sophisticated methods , some things do have side effects ; side effects are very important in programming . it is important to adopt methods that deal with side effects in the same way . ' ' _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ __ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ __ _ _ _ _ _ _ _ _ _ _ _ _ bergstra , j . a . and ponse , m . ( 2012 ) . # ##al and open - source software . in m . arbab and m . sirjani ( eds . ) , _ proceedings of the 6th international conference on foundations of software engineering _ ( fsen 2011 ) , springer . volume 7141 of lecture notes in computer science , pages 1 - 23 . springer - verlag .