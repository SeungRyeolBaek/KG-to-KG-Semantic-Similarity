connectivity and network design problems play an important role in network design and analysis both for their theoretical basis and their many real - world applications . an important and popular class of problems is of the following type : given a set @ xmath5 with edge - vertex connectivity , find a minimum - cost subgraph @ xmath6 of @ xmath2 that satisfy certain boundary conditions . for example , given an set @ xmath7 , one can search for the minimum - cost connected subgraph that is @ xmath8 - edge and @ xmath8 - vertex connected . if @ xmath9 , this is the generalized minimum spanning tree ( - ) problem . for @ xmath10 the problem is np - hard and is apx - hard to solve . more general types of connectivity problems are solved if one finds a subgraph in which a subset of the sets @ xmath11 _ to _ _ x _ contains @ xmath8 - edge . the best - known spanning tree problem is to find a minimum - cost subgraph that ( @ xmath12 - ) contains a connected set @ xmath13 . many of these problems are special cases of the survivable network design problem( sndp ) . in sndp , each pair of nodes @ xmath14 has a minimum cost @ xmath15 and the goal is to find a minimum - cost subgraph that provides @ xmath15 shortest paths for each node @ xmath16 . given the complexity of these connectivity problems , there has been a considerable amount of work on these problems . a number of simple and efficient algorithms and algorithms have been published over the years ( see @ xcite ) . in particular , the self - consistent rounding @ xcite and parallel ##ization @ xcite have led to several important results including the @ xmath1 - algorithm for simply - connected sndp @ xcite . another important class of problems , similar to those of the connectivity problems described above , are solved by requiring that nodes @ xmath0 of the input graph be connected . these problems are often motivated by situations in which one wishes to achieve connectivity with a lower bound ( k ) on the cost . for example , a common solution in the connectivity problems is to find a path that limits the number of nodes and , subject to the constraint @ xmath17 , the cost of the path . in the graph connectivity problem , thethe margin problem is equivalent to the problem of finding the width / length of a graph subject to the assumption that at least @ xmath0 vertices are available . of course the two problems may not be exactly equivalent , however , because one is less general and difficult to solve the other . the most well - known of these problems is the @ xmath0 - spanning tree ; the problem here is to find a minimum - cost subgraph of the given graph @ xmath2 that contains at least @ xmath0 vertices ( or more ) . this problem has received much attention in the graph theory community and its solution has led to many new mathematical problems and to @ xcite . we note that the spanning tree problem can be very easily generalized in an approximation ##al way to the @ xmath0 - spanning problem . more recently , lau _ et al . _ @ xcite proposed the following extension of @ xmath0 - spanning to graph theory . in particular they considered the @ xmath18 - subgraph problem to be the following : find a minimum - cost subgraph of the given graph @ xmath2 that contains at least @ xmath0 vertices and the @ xmath##8 - this problem . we use the term @ xmath0 - @ xmath8ec to refer to this problem . in @ xcite an @ xmath19 approximation is obtained for the @ xmath0 - @ xmath1ec problem . however , the proof and proof in @ xcite are incomplete . more recently , and after further work from ours , the authors of @ xcite found a better approximation for @ xmath0 - @ xmath1ec that yields an @ xmath20 approximation . we give here a more detailed comparison of their work and ours . it is also stated in @ xcite that a better approximation for @ xmath0 - @ xmath8ec when @ xmath8 is constant would yield an improved algorithm for the @ xmath0 - vertex subgraph problem @ xcite ; for this problem one finds an @ xmath0 - vertex subgraph of a given constant @ xmath2 that has the largest number of edges . the @ xmath0 - vertex subgraph problem yields an @ xmath21 approximation for a given constant @ xmath22 @ xcite , but has several attempts at an improved algorithm for this problemof course , . in this section we consider the vertex - connected version of the @ xmath0 - pc problem . we consider the @ xmath0 - @ xmath8vc problem as follows : given an integer @ xmath0 and a graph @ xmath2 with edge cost , consider the edge - connected @ xmath8 - vertex - connected subgraph of @ xmath2 that has at most @ xmath0 edges . we also consider the _ uniform _ version of the problem where the subgraph has to add @ xmath0 edges from a given integer to @ xmath3 . it can be easily shown that the @ xmath0 - @ xmath8ec problem reduces to the @ xmath0 - @ xmath8vc problem for integers @ xmath23 . we also show that the @ xmath0 - @ xmath8ec problem with integers can be easily reduced , as follows , to the integer version where each vertex is a terminal : for any integer @ xmath24 , put @ xmath25 vertices in @ xmath26 and add @ xmath27 to @ xmath28 with @ xmat##h8 - graphs of finite cost . we use @ xmath29 as the original graph . we can avoid removing these edges by finding a graph in @ xmath26 with zero - cost edges and reducing @ xmath8 of these edges to @ xmath28 . note , however , that this reduction only works for zero - cost . we are also aware of a reduction that reduces the @ xmath0 - @ xmath8vc problem with a finite number of terminals to the @ xmath0 - @ xmath8vc problem , even when @ xmath30 . in this case we solve the @ xmath0 - @ xmath1vc problem ; our technical result is the following . [ cr : ke ] there is an @ xmath31 approximation for the @ xmath0 - @ xmath1vc problem where @ xmath32 is the number of terminals . [ cor : ke ] there is an @ xmath31 approximation for the @ xmath0 - @ xmath1ec problem where @ xmath32 is the number of terminals . one of the technical results that we note is the following , which may be of general nature .given a graph @ xmath2 with edge costs and terminals and and @ xmath3 , we define @ xmath33 for each subgraph @ xmath6 to be the ratio of the number of terminals in @ xmath6 to the total number of terminals in @ xmath6 . [ cr : cycle ] let @ xmath2 be an @ xmath1 - simply - connected graph with edge costs and let @ xmath34 be a cycle of length . then , there is a complete graph @ xmath35 with at most @ xmath1 terminals ( a non - trivial cycle ) such that the density of @ xmath35 is at most the density of @ xmath2 . therefore , such a cycle can be found in polynomial time . using the above formula and the above theorem we obtain the following . [ cor : cycle ] given a graph @ xmath5 with edge costs and @ xmath32 and @ xmath36 , there is an @ xmath37 cycle for the problem of finding a high - density non - trivial cycle . note that both [ cr : cycle ] and also [ cor : cycle ] are of interest becausewe find a cycle with at most _ n _ 1 . a minimum - density cycle with only one terminal can be found by solving the well - known minimum - density cycle problem for the graphs @ xcite . we note , however , that although we know that the problem of finding a minimum - density two - terminal cycle is np - complete , we still do not have a solution . theorem [ 1 : 1 ] shows that the problem is equivalent to the non - @ xmath1vc problem , discussed in the previous section . * note : * the reader may ask whether @ xmath0 - @ xmath1ec and @ xmath0 - @ xmath1vc have a certain lp solution , since the @ xmath0 - @ solution admits lp . we note that the only computational property which makes @ xmath38 ##0 for @ xmath0 - @ and @ xcite is a certain property that holds for the lp solution of the np - winning steiner tree problem @ xcite which is the lagrangian version of the steiner tree problem . such a property is not known to hold for solutions of @ xmath0 - @ . @ xmath0 - @xmath1ec and @ xmath0 - @ xmath1vc and the @ xmath0 - steiner problem and @ xcite . however , one is forced to rely on algorithms and domain - specific methods . we consider the rooted version of @ xmath0 - @ xmath1vc : the problem is to reduce the vertex - connected subgraph that @ xmath1 - contains at most @ xmath0 - to the rooted version of @ xmath39 . it is not easy to reduce @ xmath0 - @ xmath1vc to the rooted version ( see section [ 1 : k2vc ] for details . ) we draw inspiration from the techniques that lead to poly - based algorithms for the @ xmath0 - steiner problem . to approximate our solution to the rooted @ xmath0 - @ xmath1vc problem , we consider a closely related problem . for a subgraph @ xmath6 that contains @ xmath39 , let @ xmath40 be the number of vertices that are @ xmath1 - connected to @ xmath39 by @ xmath6 . then the _ root _ of @xmath6 is simply the ratio of the size of @ xmath6 to @ xmath40 . the lp - @ xmath1vc problem is to find a vertex - connected subgraph of given size . the @ xmath37 problem for the lp - @ xmath1vc problem ( where @ xmath32 is the number of vertices ) can be solved in a simple what if manner by performing a bucket and scaling trick and a dynamic time algorithm for the problem . we compare the efficient performance of @ xmath1 and the efficient performance of the algorithm used for the sndp problem with optimal solution ##s ##nd @ xmath41 @ xcite . the bucket and scaling trick has had many applications in the past and has now been used for many applications @ xcite . our algorithm for @ xmath0 - @ xmath1vc uses the greedy algorithm at the highest level . we start with an empty subgraph @ xmath42 and apply the greedy algorithm for lp - @ xmath1vc in an efficient way to repeatedly add terminals to @ xmath42 until at most @ xmath43 terminals are reached @ xmath42 . thisthis would give the @ xmath44 solution if @ xmath45 . however , the last iteration of the non - @ xmath1vc algorithm will produce many more terminals than expected with the result that @ xmath46 . in this case we can only estimate the size of the results produced by the algorithm . to solve this problem , we can try to _ remove _ the subgraph @ xmath6 resulting from the last iteration to finally get the desired number of terminals . for the @ xmath0 - ms ##t , @ xmath6 is a problem and it is not solved . we find that this is a very good @ xmath20 solution for @ xmath0 - ms and could have been solved once more by more detailed methods as in @ xcite . one of our main goals is to provide the first solution for the @ xmath0 - @ xmath1vc problem . to do this , we use two different methods . the solution is found by the cycle finding algorithm of algorithm [ 1 : 2 ] . first , we use this cycle finding algorithm to repeatedly remove subgraphs until we have the desired number of cycles plus one .##graph . this general approach requires optimization . the cycle merging algorithm is motivated by a similar idea from the work of lau _ et al . _ @ xcite on the @ xmath0 - @ xmath1ec problem and _ @ xcite on the cycle orienteering problem . these algorithms yield an @ xmath47 approximation . we use a slightly simpler cycle - merging algorithm with a more complicated and non - linear algorithm to produce the @ @ xmath31 approximation . these results are in order to compare our algorithm to that of @ xcite on the @ xmath0 - @ xmath1ec problem . the merge algorithm in @ xcite is based on finding a k - rank cycle in a directed graph with a k - rank . the algorithm in @ xcite to find such a cycle is unknown . instead , the cycles are embedded in the graph which leads the algorithm to the @ xmath0 - @ xmath1ec problem ( finding a cycle in @ xmath1 - edge - connected graph to create the cycle structure in @ xmath1 - edge - connected ) . in our algorithm we do not create cycles and instead create new cycles with which to reduce the number of cycles in the already existingtheorem . this allows us to directly solve the minimum - cost non - linear # ##x , which we proved via theorem [ ar : cycle ] and theorem [ cor : cycle ] . in this work , lau _ et al . _ @ xcite found a simple and efficient @ xmath48 - flow for @ xmath0 - @ xmath1ec . they also use the same algorithm that we used when solving the problem for finding the subgraphs formed by the first cycle . however , in the next work they use a slightly different approach ; they use the same idea of finding - where for @ xmath49 - @ @ xcite . although the complexity of this algorithm is limited , the algorithm is better for the @ xmath0 - @ xmath1ec problem , where our algorithm is more efficient and equivalent to the algorithm for the more complicated @ xmath0 - @ xmath1vc problem . we start with graphs in which the costs are known as _ cost _ . for a graph @ xmath2 with minimum edges and minimum vertices , we set the _ cost _ of the subgraph @ xmath6 to the sum of the number of edges in @ xmat##h6 denote as the sum of the number of vertices in @ xmath6 . here , we take @ xmath1 - connected graph to get the @ xmath1 - 2 - connected graph . the goal of the @ xmath0 - @ xmath1vc problem is to find a min - cost 2 - connected subgraph on at least @ xmath0 terminals . . for purposes of simplicity , however , we refer to the more general problem . ] note that for the original @ xmath0 - @ xmath1vc problem , the goal is to find a min - cost subgraph on at least @ xmath0 terminals in which each vertex is 2 - connected to the new vertex @ xmath39 . the ( unrooted ) @ xmath0 - @ xmath1vc problem can be converted to the rooted version with _ _ _ _ and @ xmath16 that is not the optimal solution , finding a new root at @ xmath39 , and replacing it with 2 - connected edges to @ xmath50 and @ xmath28 . it is not hard to see that the solution to the root problem in the rooted version can be converted to thesolution to the unrooted problem involves adding two minimum - density vertex - connected paths to @ xmath50 and @ xmath28 . ( since @ xmath50 and @ xmath28 result in the same solution , the density of these two paths need not be less than @ xmath51 . ) we get more details from this above proof . for the min - @ xmath1vc problem , the goal is to find a subgraph @ xmath6 of minimum density in which all vertices of @ xmath6 are vertex - connected to the other . the above algorithm is described in the [ subsec : algorithm ] below . it relies on the @ xmath1 - algorithm , via k - coloring , for the min - @ @ xmath1 - ##vc problem due to fleischer , brown and williamson @ xcite , and other similar algorithms . [ see : densv ] there is an @ xmath37 - connectivity algorithm for the min - @ xmath1vc problem , where @ xmath32 is the number of vertices in the given graph . let @ xmath51 be the degree of the optimal solution to the @xmath0 - @ xmath1vc problem . we need support of @ xmath51 ; this can be dealt with by other methods . we pre - construct the graph by moving the terminal that does not have any edge - free edges to the root @ xmath39 of the terminal at root @ xmath51 . the high - level description of the algorithm for the graph @ xmath0 - @ xmath1vc problem is given below . @ xmath52 , @ xmath53 is the original graph . + if ( @ xmath54 ) : + is the corresponding algorithm for x - @ xmath1vc to find the subgraph @ xmath6 , @ xmath2 . + if ( @ xmath55 ) : + @ xmath56 , @ xmath57 + treat the vertices in @ xmath6 as non - empty . + else : + _ _ _ @ xmath6 to find @ xmath58 that contains @ xmath59 vertices . + @ xmath60 , @ xmath61 + + @ xmath42 at the end of each .of the previous two , the third is a solution to the non - @ xmath1vc problem of density at most @ xmath62 . however , the graph @ xmath6 ##2 earlier had density at most @ xmath63 . if @ xmath55 , we add @ xmath6 to @ xmath42 and then @ xmath59 ; we refer to this as the _ _ _ step . thus , we get a graph @ xmath6 of equal density , but with too few terminals . in this case , we use @ xmath6 to produce the graph with the right number of terminals ; this is the _ _ algorithm _ . a simple greedy - based greedy algorithm gives the following result : [ source : 1 ] if , for the greedy step , we get a graph of density at most @ xmath64 ( where @ xmath59 is the number of new terminals that can be added ) , the total number of all the greedy steps is at most @ xmath65 . therefore , we will only need to compute the density of the graph @ xmath58 used for the greedy step; we prove the main theorem by section [ sec : greedy ] . [ sec : avekv ] let @ xmath66 be an instance of the rooted @ xmath0 - @ xmath1vc problem with vertices @ xmath39 , such that each vertex of @ xmath2 has @ xmath1 ##vc - 1 edges to @ xmath39 of total cost at most @ xmath67 , and such that @ xmath68 . there is a polynomial - time algorithm to find a solution to this problem of cost at most @ xmath69 . we can also prove our main theorem for the @ xmath0 - @ xmath1vc problem , by [ sec : greedy ] . section [ sec : greedy ] let @ xmath51 be the cost of the optimal solution to the ( rooted ) @ xmath0 - @ xmath1vc problem . by section [ sec : greedy ] , the total cost of the first step of our greedy algorithm is @ xmath70 . to calculate the cost of the additional steps , let @ xmath59 be the cost of the firstthat will be stated immediately prior to this section . the solution for the max - @ xmath1vc problem is a graph @ xmath6 with @ xmath71 terminals , and density at most @ xmath72 . as a result of our pre - computation ##s , each vertex sends two simply - connected edges to @ xmath39 of total density at most @ xmath51 . therefore , we use theorem [ min : avekv ] to compute @ xmath6 and return a graph @ xmath58 with @ xmath59 terminals and density at most @ xmath73 . thus , the total cost of our algorithm is @ xmath74 . it is necessary to prove theorem [ min : densv ] , that there exists an @ xmath75 - solution for the max - @ xmath1vc problem , and theorem [ min : avekv ] , for the cost of the next solution . we prove the former in section [ subsec : cycles ] below . if the latter is proved in section [ sec : cycles ] , we prove the former in section [ sec : cycles] ; ] among these solutions is : [ 1 : 2 ] . suppose that the s - @ xmath1vc algorithm is formulated as follows : given a graph @ xmath5 with vertex - connectivity , and an @ xmath76 of terminals , and a terminal @ xmath77 , and a subgraph @ xmath6 of bounded length , in which each terminal of @ xmath6 is edge - connected to @ xmath39 . ( here , the density of @ xmath6 is defined as the size of @ xmath6 multiplied by the number of terminals it contains , not by @ xmath39 . ) we define an algorithm for s - @ xmath1vc that produces an @ xmath37 - solution , and give a proof . we describe an approximation of algorithm and a coloring and coloring algorithm ( see @ xcite for details of this algorithm ) , and a 1 - degree reduction of the maximum degree of the algorithm for sndp with edge - connectivity , called @ xmath41 @ xcite . we define * lp - algorithm * as the optimal approximation algorithm of s - @ xmath1vc . for each .@ xmath78 , the variable @ xmath79 indicates whether or not @ xmath28 is used by the solution . ( by setting @ xmath80 to 0 , and taking the sum of the squares , we get the cost . ) @ xmath81 is the sum of all the edges between @ xmath78 and the edge @ xmath39 ; for each @ xmath82 , @ xmath83 indicates how the ` message ' was sent from @ xmath28 to @ xmath39 and @ xmath35 . ( note that the set of 2 - 3 cycles is a cycle ; the density of a cycle is optimal if we can re - link @ xmath78 to @ xmath39 through the flow of the cycle . ) the variable @ xmath84 indicates whether the edge @ xmath85 is used by the solution . @ xmath86 @ xmath87 it is not hard to see that an optimal solution to * * - * * has density at least the size of an optimal solution to * - @ xmath1vc . we also know how tofind an optimal solution of cost at most @ xmath88 , where @ xmath89 is the cost of the optimal solution to * lp - den * . the following is * lp - den * has an infinite number of terminals and a finite number of non - linear equations ; it can , therefore , be solved in polynomial time . find an optimal solution to * lp - den * of each @ xmath89 , and for each @ xmath90 ( for simplicity of computation , where @ xmath91 is an index ) , let @ xmath92 be the number of terminals @ xmath78 such that @ xmath93 . since @ xmath94 , there is an index @ xmath95 such that @ xmath96 . since the index @ xmath97 contains @ xmath98 , the number of terminals of @ xmath92 is at most @ xmath99 . we know that there is a subgraph @ xmath6 of @ xmath2 with cost at most @ xmath100 , in which each terminal of @ xmath92 is simply - connected tothe theorem . if this is true , the cost of @ xmath6 is at most @ xmath101 , and so we have the @ xmath37 - solution for the non - @ xmath1vc problem . to prove our conjecture about the cost of the subgraph @ xmath6 in which each terminal of @ xmath92 is 2 - connected to @ xmath39 , consider setting up the ` scaled solution of * lp - ps * by each terminal of @ xmath102 . for each terminal @ xmath103 , the cost from @ xmath78 to @ xmath39 [ this scaled solution ] is at most 2 , and the cost of the scaled solution is @ xmath104 . in @ xcite , the authors use a linear program @ xmath105 to find a low - cost subgraph in which a given set of terminals is 2 - connected to the input , and show that this linear program has an approximation factor of 2 . the program @ xmath84 and the ` scaled solution ' to * lp - ps * correspond to the scaled solutions of @ xmath105 with @ xmat##h92 is the set of terminals ; the essential property of this implies that there is a subgraph @ xmath6 in which every terminal of @ xmath92 is 2 - connected to the other , with cost at most @ xmath106 . thus , the algorithm for lp - @ xmath1vc is : 1 . find an optimal _ solution to * - - @ * . 2 . find a set of terminals @ xmath92 such that @ xmath107 . 3 . find a minimum - cost subgraph @ xmath6 in which every terminal of @ xmath92 is 2 - connected to @ xmath39 by the choice of @ xcite . @ xmath6 has cost at most @ xmath37 . the optimal solution to lp - @ xmath1vc . a cycle @ xmath108 is _ non - trivial _ if it contains at least 2 terminals . we have the following - - non - trivial _ algorithm : for every cycle @ xmath5 , with @ xmath3 defined as minimum , maximum , and maximum minimum , find a minimum - cost cycle that contains at least 2 terminals . .that if we remove the requirement that the cycle be non - trivial ( that is , it has at least two edges ) , the problem reduces to the minimum - mean cycle problem in simple terms , and can be solved exactly in polynomial time ( see @ xcite ) . algorithms for the minimum - mean non - trivial cycle problem are a useful tool for solving the @ xmath0 - @ xmath1vc and @ xmath0 - @ xmath1ec problems . in this section , we give the @ xmath75 - @ algorithm for the minimum - mean non - trivial cycle problem . first , we prove , [ graph : strong ] , that every simply - connected graph with edge weights and vertex weights is a minimum non - trivial cycle , with density no less than the maximum size of the graph . we give two algorithms to find such a cycle ; the first , described in section [ subsec : nonpoly ] , is fast , but the running time is a polynomial . a more general proof that reduces to a faster polynomial - time algorithm is given in section [ subsec : strong ] ; we let this algorithm be moved to a later page . to find a non - trivial cycle of density at least that of theproof - as applied to @ xmath2 , we can start with an initial non - trivial cycle , and then find cycles of lower density until we find a cycle with density at least @ xmath109 . the following theorem states that if the cycle @ xmath35 has an ear with density less than @ xmath110 , we can use this method to find a cycle of finite density . [ source : goodear ] let @ xmath35 be a non - trivial cycle , and @ xmath6 an ear corresponding to @ xmath35 between @ xmath50 and @ xmath28 , such that @ xmath111 . let @ xmath112 and @ xmath113 be the two maximal simple cycles between @ xmath50 and @ xmath28 at @ xmath35 . then @ xmath114 and @ xmath115 are two trivial cycles and one of these is non - trivial and has density less than @ xmath110 . @ xmath35 has at least 2 terminals , so it has finite density ; @ xmath6 will also have at least 1 terminal . then @ x##math116 , @ xmath117 and @ xmath118 are , respectively , the sum of the costs of the terminals in @ xmath112 , @ xmath113 and @ xmath6 , and let @ xmath119 , @ xmath120 and @ xmath121 be the sum of the costs of the terminals in @ xmath112 , @ xmath113 and @ xmath122 . [ i . a . d . s . that @ xmath112 has density at least that of @ xmath113 . ( that is , @ xmath123 . ) and @ xmath113 has density 1 and weight 2 . in this case , let @ xmath112 be the terminal with non - trivial density . ] @ xmath112 must contain at least one terminal , and therefore @ xmath114 is a simple non - trivial cycle . the cycle @ xmath124 is equivalent to @ xmath125 . @ xmath126 therefore , @ xmath114 is a simple cycle with at least two terminals of density less than @ x##math110 . [ example : 2conncomp ] for a cycle @ xmath35 in an @ xmath1 - connected component @ xmath2 , let @ xmath42 be the cycle formed from @ xmath2 by joining @ xmath35 to a single vertex @ xmath28 . if @ xmath6 is a connected component of @ xmath127 , @ xmath128 is @ xmath1 - connected in @ xmath42 . let @ xmath6 be an entirely connected component of @ xmath127 , and then @ xmath129 . to prove that @ xmath58 is 2 - connected , we first assume that @ xmath28 is 2 - connected to the cycle @ xmath130 . ( the vertex that separates @ xmath131 from @ xmath28 in @ xmath58 is @ xmath131 from the cycle @ xmath35 in @ xmath2 . ) it then follows that for all cycles @ xmath132 , @ xmath131 and @ xmath133 are 2 - connected in @ xmath##58 . 5 removes the vertices @ xmath50 and @ xmath131 from @ xmath133 . the vertex @ xmath50 need not be @ xmath28 , since @ xmath6 is the same component of @ xmath127 . but if @ xmath134 , @ xmath28 and @ xmath131 are in the same component of @ xmath135 , since @ xmath28 is 2 - connected to @ xmath131 and @ xmath58 . therefore , @ xmath28 and @ xmath133 are in the same component of @ xmath135 , and therefore , @ xmath50 does not separate @ xmath131 from @ xmath133 . we now know that for any 2 - connected graph @ xmath2 , we can find a non - trivial graph of degree no less than that of @ xmath2 . [ see : cycleexists ] let @ xmath2 be an @ xmath1 - connected graph with at most @ xmath1 vertices . @ xmath2 is a complete non - trivialfind @ xmath136 such that @ xmath137 . let @ xmath35 be an empty non - trivial connected cycle ; such a cycle always exists since @ xmath2 is @ xmath1 - connected and has at most 2 vertices . if @ xmath138 , we have an algorithm that finds a empty non - trivial cycle @ xmath139 such that @ xmath140 . using this algorithm , we find cycles of progressively lower density until finally finding a non - trivial cycle @ xmath136 of weight at most @ xmath109 . let @ xmath42 be the cycle formed by contracting the empty cycle @ xmath35 to a single component @ xmath28 . unlike @ xmath42 , @ xmath28 is not a cycle , and therefore has weight 1 . consider the 2 - dimensional graph of @ xmath42 ( from the [ 1 : 2conncomp ] , each connected cycle is formed by contracting @ xmath28 to a single component of @ xmath127 ) , and choose the component of highest weight . if @ xmath6 is this component , @ xmath14##1 provides an additional example . @ xmath6 has at most 1 terminal . if it contains 2 or more terminals , recursively find a non - trivial cycle @ xmath139 and @ xmath6 such that @ xmath142 . if @ xmath139 exists in the original graph @ xmath2 , it has the following properties , and we are satisfied . first , @ xmath139 contains @ xmath28 , and the vertices of @ xmath139 form a cycle of @ xmath35 in the original graph @ xmath2 . the density of this cycle is less than the density of @ xmath35 , so we can go to [ 1 : goodear ] to find a non - trivial cycle in @ xmath2 that has density less than @ xmath110 . second , if @ xmath6 has exactly one terminal @ xmath50 , find all possible vertex - connected paths connecting edges of @ xmath6 from @ xmath50 to the vertices of the graph @ xmath35 . ( since @ xmath2 is vertex - connected , there must be such paths . )the density of these paths is at most @ xmath143 , and taking these two paths leads to an edge of @ xmath35 in @ xmath2 . the density of this cycle is less than @ xmath110 ; therefore , we use theorem [ m : goodear ] to find a cycle in @ xmath2 with the same density . we note here that the proof of theorem [ m : cycleexists ] does not converge to a polynomial - time algorithm , even if the path length and edge density are polynomially bounded . using theorem [ subsec : equivalence ] , we find a similar polynomial - time algorithm that , given a cycle @ xmath2 , produces a non - trivial cycle of density at most that of @ xmath2 . note that neither of these algorithms will actually produce a complete solution to the n - 1 non - trivial cycle problem , because the resulting non - trivial cycle will have density much less than that of @ xmath2 . however , we can use theorem [ m : cycleexists ] to prove the following theorem : [ m : cycles ] there exists an @ xmath144 - solution to the ( unrooted) max - @ xmath1vc problem if and only if there exists an @ xmath144 - solution to the problem of finding a minimum - density non - trivial cycle . suppose we have an @ xmath145 - solution for the max - @ xmath1vc problem ; we use it to find a minimum - density non - trivial cycle . consider the max - @ xmath1vc problem for the given graph ; since the given graph is a simply - connected graph , our solution @ xmath6 to the max - @ xmath1vc problem has density at most @ xmath145 times the density of this graph . find a non - trivial cycle in @ xmath6 of density at most that of @ xmath6 ; it has density at most @ xmath145 times that of the optimal non - trivial cycle . assume that every solution of the ( unrooted ) max - @ xmath1vc problem has an optimal solution that is a non - trivial cycle . ( find the optimal solution @ xmath6 of in @ xmath146 ; by definition [ x : x ] , @ xmath6 is anon - trivial cycles of length at satisfy @ xmath146 . this problem is a partial solution to the min - @ xmath1vc problem . ) similarly , an @ xmath147 - approximation for the min - density non - trivial cycle problem implies an @ xmath147 - approximation for the min - @ xmath1vc problem . theorem [ le : equivalence ] and theorem [ le : densv ] imply an @ xmath37 - approximation for the min - density non - trivial cycle problem ; this gives theorem [ cor : equivalence ] . we say that a graph @ xmath5 is not 2 - connected on its terminals if for every graph @ xmath148 , every pair of cycles is not 2 - connected on the graph @ xmath149 . theorem [ subsec : cycle ] states that for every graph which is not 2 - connected on its terminals , every cycle is non - trivial . however , the problem of finding a min - density non - trivial cycle in such graphs is like that of finding a maximum - density cycle , which can be solved exactly in polynomial time . however , as we see at the end of thehowever , this does not always lead to an efficient algorithm for connected graphs . in this section , we describe a simple polynomial - time algorithm which , for a simply - connected graph @ xmath5 with edge weights and n vertices , produces a non - connected graph of degree at least that of @ xmath2 . we start with two steps : let @ xmath35 be a path in the graph @ xmath2 , and @ xmath42 be the graph obtained by removing @ xmath35 from @ xmath2 . let @ xmath150 be the connected component of @ xmath42 ; we refer to these as _ arms _ of @ xmath35 . if is a path , this would be an arm of @ xmath35 , but @ xmath151 would be more complex . ] for each @ xmath151 , let the vertices of @ xmath35 corresponding to it be _ _ _ arms _ . from the definition of an arm , for each pair of arms of @ xmath151 , there is a cycle between them whose two vertices are both in @ xmath151 . we say that any pair of @ x##math35 is an _ anchor _ if it is the anchor of an anchor . ( an anchor may be a clasp of multiple rings . ) a _ vertex _ @ xmath13 of @ xmath35 is a segment contained in @ xmath35 , note that the vertices of @ xmath13 are the anchors , and every other vertex of @ xmath13 is an anchor . ( note that the anchors of @ xmath13 may be part of the same ring , or of multiple rings . ) it is easy to see that the anchors are the vertex ##es of @ xmath35 . by removing a segment , we get to remove both external and internal segments . note that if @ xmath13 is removed from @ xmath2 , the only vertices of @ xmath152 that retain their anchor are the vertices of @ xmath13 . a segment is _ anchor _ if the segment @ xmath153 is simply - connected . now choose the segment @ xmath154 of @ xmath35 as the _ anchor _ , and then rotate the vertices of @ xmath35 clockwise from the origin of @xmath155 . the first clasp of an arc @ xmath6 is its lowest numbered clasp , and the last clasp is its highest numbered clasp . ( if the clasp is not part of @ xmath6 , it is considered the first clasp , not the last . ) the _ arc _ of an arc is the subgraph of @ xmath35 formed by moving it from its first clasp @ xmath156 to its last clasp @ xmath157 ; the length of this arc is @ xmath158 . ( that is , the length of the arc equals the number of vertices it contains . ) note that if the arc contains the origin , it must contain the third vertex of the triangle . the [ arc : length ] contains each of these arcs . ( 0 , 0 ) ; ( 0 cm ) ; at ( 0 , 0 ) @ xmath35 ; ( 30 : 2 cm ) ( 30 : 2 cm ) ; ( 3 , 0 ) ( 3 , 0 ) ; ( - 45 : 3 cm ) ( - 45 : 3 cm ) ; at ( 38 : 0 . 5 cm ) @ xmath159 ; at ( 38 . 5 , 38 . 5 ) @xmath160 ; at ( - 45 : 2 . 8 cm ) @ xmath161 ; at ( 0 , 0 . 0 ) @ xmath162 ; ( 15 : 2 . 8 cm ) arc ( 30 : - 55 : 2 . 8 cm ) ; ( 15 : 2 . 2 cm ) ; ( 30 : - 330 : 3 . 5 cm ) ; ( 15 : 3 . 2 cm ) arc ( - 55 : - 330 : 3 . 8 cm ) ; ( - 45 : 3 . 8 cm ) arc ( 30 : 315 : 0 . 8 cm ) ; at ( 15 : 2 . 2 cm ) @ xmath6 ; ( 15 : 2 cm ) circle ( 1 mm ) ; ( - 30 : 2 cm ) circle ( 1 mm ) ; ( 0 , 0 ) circle ( 1 mm ) ; ( 0 , 0 ) circle ( 1 mm ) ; ( 30 : 1 . 5 cm ) arc ( 30 : - 330 : 1 . 5 cm ) ; ( 0 , 0 ) circle ( 1 mm ) ; at ( 0 , 0 ) @ xmath35 ; ( 0 , 0 ) ( 0 , 0 . 0 ) ; ( 30 : - 45 : 3 . 2 cm ) ( 0 ,- 0 ) ; at ( 0 , 1 . 6 ) @ xmath163 ; at ( 0 , - 1 . 6 ) @ xmath164 ; at ( 0 , 1 . 6 ) [ = = ] @ xmath165 ; ( 0 : 1 cm ) ( 0 : 2 cm ) ; ( 30 : - 30 : 2 cm ) ( - 25 : 2 cm ) ; at ( 0 : 2 . 2 cm ) @ xmath156 ; at ( - 30 : 2 . 2 cm ) @ xmath157 ; ( 30 : 2 . 2 cm ) arc ( 30 : 330 : 2 . 2 cm ) ; ( 0 : 2 . 2 cm ) ( 0 : 2 . 2 cm ) ; ( 30 : - 30 : 2 . 2 cm ) ( - 25 : 2 . 2 cm ) ; ( 0 : 2 cm ) circle ( 1 mm ) ; ( - 30 : 2 cm ) circle ( 1 mm ) ; ( 0 , 0 ) circle ( 1 mm ) ; ( 0 , - 2 ) circle ( 1 mm ) ; ( 0 : 2 mm ) circle ( 1 mm ) ; arc ( 30 : 2 . 2 cm ) @ xmath162 ; ( 0 , 0 )at ( 0 cm ) ; at ( 0 , 0 ) @ xmath35 ; ( 0 , 0 ) ( 0 , 3 . 9 ) ; ( 25 : - 30 : 3 . 6 cm ) ( 0 , - 1 ) ; at ( 0 , 3 . 6 ) @ xmath163 ; at ( 0 , - 1 . 6 ) @ xmath164 ; at ( 0 , 3 . 9 ) [ font = ] @ xmath166 ; arc ( 30 : 3 . 6 cm ) @ xmath156 ; arc ( - 85 : 2 . 6 cm ) @ xmath157 ; ( 25 : 2 cm ) ( 85 : 2 . 6 cm ) ; ( 85 : 2 cm ) ( 85 : 2 cm ) arc ( 85 : - 85 : 2 cm ) ( - 85 : 2 cm ) ; arc ( 25 : 2 . 4 cm ) [ font = ] @ xmath167 ; ( - 85 : 2 cm ) ( - 85 : 2 cm ) ; ( 25 : 2 . 4 cm ) ( 85 : 2 . 2 cm ) ; ( 85 : - 85 : 2 . 4 cm ) ( - 85 : 2 . 4 cm ) ; ( - 85 : - 85: 2 . 2 cm ) ; ( - 25 : 2 . 8 cm ) ( - 25 : 2 . 2 cm ) ; ( - 25 : 2 : 2 . 2 cm ) ( 25 : 2 . 2 cm ) ; ( 80 : 25 : 2 . 2 cm ) ; ( 25 : 2 cm ) circle ( 1 mm ) ; ( - 25 : 2 cm ) circle ( 1 mm ) ; ( 0 , 2 ) circle ( 1 mm ) ; ( 0 , - 0 ) circle ( 1 mm ) ; ( 0 : 1 cm ) circle ( 1 mm ) ; at ( 0 : 0 . 6 cm ) @ xmath162 ; ( 0 , 2 ) circle ( 1 mm ) ; at ( 0 , 0 ) @ xmath35 ; ( 0 , 0 ) ( 0 , 1 . 6 ) ; ( 0 : - 0 : 3 . 2 cm ) ( 0 , - 0 ) ; at ( 0 , 1 . 6 ) @ xmath163 ; at ( 0 , - 1 . 6 ) @ xmath164 ; at ( 0 , 1 . 6 ) [ = = ] @ xmath165 ; at ( 0 : 1 . 6 cm ) @ xmath156 ; at ( -30 : 3 . 1 cm ) @ xmath157 ; ( 30 : 3 cm ) ( 35 : 3 . 1 cm ) arc ( 38 : - 135 : 2 . 5 cm ) ( - 143 : 2 cm ) ; at ( 35 : 3 . 5 cm ) [ font = ] @ xmath166 ; ( - 35 : 2 cm ) ( - 135 : 2 . 5 cm ) arc ( - 135 : - 135 : 2 . 5 cm ) ( - 143 : 2 cm ) ; at ( - 143 : 2 . 5 cm ) [ font = ] @ xmath167 ; ( 35 : 2 . 15 cm ) arc ( 35 : 2 : 2 . 15 cm ) ( 35 : 2 . 5 cm ) arc ( 85 : - 35 : 2 . 15 cm ) ( - 100 : 2 . 15 cm ) arc ( - 100 : - 25 : 2 . 15 cm ) ; ( 25 : 2 . 95 cm ) ( 25 : 2 . 15 cm ) arc ( 85 : - 35 : 2 . 15 cm ) ( - 100 : 2 . 15 cm ) arc ( - 130 : - 25 : 2 . 15 cm ) ( - 130 : 2 . 15 cm ) arc ( - 100 : - 25 : 2. 5 cm ) ( - 30 : 2 . 5 cm ) ; ( 0 : 2 cm ) circle ( 1 mm ) ; ( - 30 : 2 cm ) circle ( 1 mm ) ; ( 0 , 0 ) circle ( 1 mm ) ; ( 0 , - 0 ) circle ( 1 mm ) ; ( 0 : 0 cm ) circle ( 1 mm ) ; at ( 30 : 2 . 6 cm ) @ xmath162 ; ( 0 , 0 ) circle ( 1 mm ) ; at ( 0 , 0 ) @ xmath35 ; ( 0 , 0 ) ( 0 , 3 . 6 ) ; ( 0 : - 30 : 2 . 6 cm ) ( 0 , - 0 ) ; at ( 0 , 3 . 6 ) @ xmath163 ; at ( 0 , - 3 . 6 ) @ xmath164 ; at ( 0 , 3 . 6 ) [ = = ] @ xmath168 ; at ( 30 : 2 . 6 cm ) @ xmath156 ; at ( - 30 : 2 . 6 cm ) @ xmath157 ; ( 30 : 2 cm ) ( 0 : 2 . 6 cm ) ; ( - 30 : 2 cm ) ( - 30 : 2 cm )at ( - 125 : - 120 : 2 cm ) ( - 120 : 2 cm ) ; at ( - 120 : 2 cm ) [ = = ] @ xmath167 ; ( - 125 : 2 . 8 cm ) arc ( - 35 : - 85 : 2 . 8 cm ) ( - 85 : 2 . 8 cm ) arc ( - 35 : 25 : 2 . 8 cm ) ( 85 : 2 . 2 cm ) ; ( - 85 : 2 . 2 cm ) ( - 85 : 2 . 8 cm ) arc ( - 35 : - 85 : 2 . 8 cm ) ( - 85 : 2 . 8 cm ) arc ( - 35 : - 330 : 2 . 8 cm ) ; ( 30 : 2 cm ) circle ( 1 mm ) ; ( - 30 : 2 cm ) circle ( 1 mm ) ; ( 0 , 0 ) circle ( 1 mm ) ; ( 0 , - 0 ) circle ( 1 mm ) ; ( 0 : 1 cm ) circle ( 1 mm ) ; at ( 0 : 0 . 5 cm ) @ xmath162 ; ( 0 , 0 ) circle ( 1 mm ) ; at ( 0 , 0 ) @ xmath35 ; ( 0 , 0 ) ( 0 , 0 . 0 ) ;( 30 : - 30 : 1 . 6 cm ) ( 0 , - 1 ) ; at ( 0 , 1 . 0 ) @ xmath163 ; at ( 0 , - 2 . 0 ) @ xmath164 ; at ( 0 , 1 . 0 ) [ font = ] @ xmath168 ; at ( 30 : 1 . 6 cm ) @ xmath156 ; arc ( - 30 : 2 . 4 cm ) @ xmath157 ; ( - 30 : 2 cm ) ( - 30 : 1 . 6 cm ) ; ( 90 : 2 cm ) ( 90 : 2 cm ) ; ( 120 : - 120 : 2 cm ) ( - 30 : 2 cm ) ; arc ( - 30 : 2 cm ) [ font = ] @ xmath167 ; ( - 85 : 2 . 4 cm ) ( - 85 : 2 . 4 cm ) arc ( - 25 : 35 : 2 . 4 cm ) ( 85 : 2 . 4 cm ) ; ( 85 : 35 : 2 . 2 cm ) ; ( - 85 : 2 . 4 cm ) arc ( - 35 : - 35 : 2 . 2 cm ) ( - 35 : 2 . 2 cm ) arc ( - 35 : 2 : 2. 5 cm ) ( 0 : 1 . 5 cm ) ; ( 30 : 1 cm ) circle ( 1 mm ) ; ( - 3 : 1 cm ) circle ( 1 mm ) ; ( 0 , 0 ) circle ( 1 mm ) ; ( 0 , - 2 ) circle ( 1 mm ) ; ( 0 : 1 cm ) circle ( 1 mm ) ; ; ( 1 : 1 . 5 cm ) @ xmath162 ; [ note : earringproof ] let @ xmath6 have an arc of minimum minimum length . any pair of within the arc of @ xmath6 is locked . let @ xmath169 be the set of pairs with lengths equal to that of @ xmath6 . since they have the same length , we refer to this as the arc of @ xmath169 , or the _ _ arc _ . let the first clasp of each pair in @ xmath169 be @ xmath163 , and the second clasp of each earrings in @ xmath169 be @ xmath164 . because the pairs in @ xmath169 have arcs of minimum length , the pair @ xmath170 has a lock @ x##math171 that is contained in the critical arc . ( that is , @ xmath172 = @ xmath173 . ) we also show that the segment contained in the critical arc is safe ; and that the segment @ xmath13 is safe if the segment @ xmath153 is 2 - connected . for each isolated segment @ xmath13 in the critical arc , let @ xmath156 and @ xmath157 ( @ xmath174 ) be the segments that are the same . we show that there are two non - 2 - connected paths between @ xmath156 and @ xmath157 in @ xmath152 ; this fails to prove 2 - connected . we consider two cases , based on the links that connect @ xmath156 and @ xmath157 . the [ example : earringproof ] illustrates these cases . if @ xmath156 and @ xmath157 are contained in the same segment @ xmath58 , it is possible to find two 2 - connected paths between them in @ xmath153 . the first example is taken from @xmath175 to @ xmath176 in the cycle @ xmath35 . the shortest path is always found in the cycle @ xmath58 ( the cycle is unique to @ xmath177 , so we can always find such a path . ) thus , @ xmath156 and @ xmath157 are clasp of two earrings . we have three choices : either @ xmath156 and @ xmath157 are clasp of earrings in @ xmath169 , neither is ( but not necessarily ) , or neither is . 3 . we now know that both @ xmath156 and @ xmath157 are clasp of earrings in @ xmath169 . let @ xmath156 be a clasp of @ xmath166 , and @ xmath157 a clasp of @ xmath167 . the first path is from @ xmath157 to @ xmath163 in @ xmath167 , and then continues along the same path from @ xmath163 to @ xmath156 . the second path is from @ xmath157 to @ x##math164 clockwise along the critical path , and from @ xmath164 to @ xmath156 through @ xmath166 . it is easy to see that these paths are not self - intersecting . . . now , that neither @ xmath156 nor @ xmath157 have the clasp of the vertices of @ xmath169 . let @ xmath156 be a clasp of @ xmath166 , and @ xmath157 be a clasp of @ xmath167 . the critical path we have is the critical path : from @ xmath157 to @ xmath164 ( the first vertex of the critical path ) , from @ xmath164 to @ xmath163 through @ xmath165 , and then clockwise along the critical path from @ xmath163 to @ xmath156 . the vertices of this path are either in @ xmath6 or on the critical arc . let @ xmath178 be a clasp of @ xmath166 or on the critical arc , and @ xmath179 be the second clasp of @ xmath##167 is in the critical arc . the second cycle is from @ xmath156 to @ xmath178 through @ xmath166 , from @ xmath180 to @ xmath181 on the edge @ xmath35 in the critical arc , and from @ xmath179 to @ xmath157 through @ xmath167 . the vertices of this cycle are in @ xmath182 , and in @ xmath35 , but not outside of the critical arc ( since both of @ xmath178 and @ xmath179 are outside the critical arc ) . thus , we have two edge - free paths from @ xmath156 to @ xmath157 . first , we consider the case that : one of @ xmath183 is a clasp of the vertices of @ xmath169 . then @ xmath156 is a clasp of @ xmath168 , and @ xmath157 is a clasp of @ xmath184 ; the third cycle ( where @ xmath185 and @ xmath186 are removed , and removed , and( [ right : earringproof ] shows the graph . ) let @ xmath181 be the index of the vertex of @ xmath167 in the critical arc . the first path is from @ xmath157 to @ xmath164 in the critical arc , and continues from @ xmath164 to @ xmath156 through @ xmath166 . the second path is from @ xmath157 to @ xmath179 through @ xmath167 , and from @ xmath179 to @ xmath156 through from @ xmath35 . note that the first edge of this path enters the critical arc at @ xmath163 , and continues along the arc until @ xmath156 . internal vertices of the first path that belong to @ xmath35 are on the critical arc , and have index greater than @ xmath175 . internal vertices of the second path that belong to @ xmath35 are either not on the critical arc , or have index between @ xmath163 and @ xmath156 . therefore , the two paths are not edge - independent . we can alsoour algorithm to find a non - trivial cycle of maximum density , _ theorem [ th : cycle ] : _ let @ xmath2 be an @ xmath1 - free graph with good - weights and maximum density , and at most @ xmath1 terminals . there is a polynomial - time algorithm to find a non - trivial cycle @ xmath136 in @ xmath2 such that @ xmath137 . _ theorem [ th : cycle ] let @ xmath2 be a cycle with @ xmath32 terminals and density @ xmath146 ; we have a polynomial - time algorithm that either finds a cycle in @ xmath2 of density less than @ xmath146 , or a maximal subgraph @ xmath42 of @ xmath2 that contains all @ xmath32 terminals . in the latter case , we can recurse to @ xmath42 until we can find a cycle of density at most @ xmath146 . we can find , in @ xmath187 * , a good - weights cycle @ xmath35 in @ xmath2 . after proving [ th : cycleexists ] , @ xmat##h35 has contained at least @ xmath146 , because the maximum - power _ of - zero _ number has at most this density . if @ xmath35 contains at least 2 terminals , we are correct . however , @ xmath35 contains only one terminal @ xmath28 . since @ xmath2 contains at least 2 terminals , there must be at least one terminal of @ xmath35 . let @ xmath28 be the origin of this cycle @ xmath35 , and @ xmath6 an arc of this same density . by example [ 1 : earringproof ] , any segment in the middle of @ xmath6 is optimal . let @ xmath13 be such a segment ; since @ xmath28 is chosen as the origin , @ xmath28 is also an internal terminal of @ xmath13 . since @ xmath28 is the internal terminal of @ xmath35 , @ xmath13 contains 2 terminals , and therefore , the cycle @ xmath188 is 2 - terminal , and contains the @ xmath32 terminals of @ xmath2 . the proof above also shows that if @ xmath##2 _ is 2 - connected on its terminals ( that is , @ xmath2 has a 2 - connected directed subgraph containing all its terminals ) , the cycle of @ xmath2 is non - trivial . ( if a graph has 0 or 2 terminals , it has a safe segment containing all terminals , which can be deleted ; this is a cycle . ) however , for a graph that _ is _ _ 2 - connected on its terminals , finding a minimum - density non - trivial cycle is equivalent to finding a minimum - density cycle , and it can be done exactly in polynomial time . this gives a simple solution for the problem : pick a graph that is _ _ 2 - connected on its terminals , remove edges and vertices until the graph is _ 2 - connected on the terminals , and then find a minimum - density cycle . as mentioned above , this is a cycle of length no less than that of the input graph , and this need not be the minimum - density cycle of the input graph . for example , there are cases where the minimum - density cycle contains part of the safe segment @ xmath13 that can be deleted by this algorithm . in this case , we have : [ x : avekv ] . wethen given the graph @ xmath2 and @ xmath3 , a set of at least @ xmath0 terminals . similarly , each terminal in @ xmath2 has two 2 - connected neighbors to the root @ xmath39 of equal cost at least @ xmath67 . let @ xmath32 be the number of terminals in @ xmath2 , and @ xmath189 the total cost ; @ xmath190 is the size of @ xmath2 . we have an algorithm that finds a subgraph @ xmath6 of @ xmath2 that has at least @ xmath0 terminals , each of which is 2 - connected to the root , and of equal total cost @ xmath191 . we can take @ xmath192 , and the general problem of finding the entire graph @ xmath2 is . the main part of our algorithm is in finding a set of 2 - connected subgraphs that we call _ cluster _ , and in finding high - size clusters that come together of equal size to the root clusters . ( the size of a cluster @ xmath136 , given by @ xmath19##3 , ( ( 1 ) the number of nodes it contains . ) nodes are sorted into _ large _ _ tier ; then @ xmath95 contains nodes with density at least @ xmath194 and less than @ xmath102 . therefore , each terminal contains a small node in tier 3 . we say a cycle is _ large _ if it has density at least @ xmath0 , and _ small _ if . the algorithm terminates when all nodes are in full weight . we will call the following mergeclusters ( see this section ) . to understand this , let @ xmath144 be the tier @ xmath195 . we say that a cycle is _ large _ if it has density at least @ xmath144 ; that is , it will have density at least @ xmath196 , the size of the entire cluster . : + for ( * @ xmath95 in @ xmath197 ) : : + if ( @ xmath198 ) : + each node has density 0 + else : + for all nodes are non - empty + for ( each ) single - node in @ xmath136 in ( @ xmath9##5 ) else : + add a ( dummy ) cycle @ xmath199 to @ xmath2 of weight @ xmath193 + add ( dummy ) cycles of weight * from @ xmath199 to all ( dummy ) other nodes of @ xmath136 + if ( @ xmath2 has a non - terminal terminal @ xmath35 of weight at vertex @ xmath144 + @ xmath2 ) : + let @ xmath200 be the smallest clusters that contain a terminal * and an element * of @ xmath35 . + ( assume that the terminals in @ xmath35 belong to the cluster of @ xmath201 . ) + create a larger cluster @ xmath202 ( of a higher weight ) by adding the nodes @ xmath203 + @ xmath204 + if ( @ xmath198 ) : + mark all nodes in @ xmath202 as non - terminal + else : + mark all ( dummy ) terminals in @ xmath202 and the other ( dummy ) nodes . we will comment on the important details of this algorithm and our implementation , describing the details of the2 . 1 . in iteration @ xmath95 , the edges correspond to tier @ xmath95 clusters . these are 2 - connectivity subgraphs of @ xmath2 , and by using edges to connect them , we get 3 - connectivity as the clusters get larger . 2 . when a cycle @ xmath35 is used to merge clusters , all existing clusters that intersect an edge of @ xmath35 ( outside of their edges ) are merged to form the new cluster . therefore , at any stage of the merge , all the existing clusters are self - merging . large clusters , on the other hand , are _ _ _ ; even if they intersect a single cycle @ xmath35 , they are not merged with other nodes on @ xmath35 . therefore , at any stage , an edge may intersect between two large clusters and belong to one smaller cluster . 3 . in iteration @ xmath95 of mergeclusters , the size of a cycle @ xmath35 is directly determined by the edges and the number of nodes on @ xmath35 belonging to tier @ xmath95 clusters . thus , clusters of different ( lower or upper ) sizes may be merged into @xmath35 , we must _ _ _ increase their number to search for the value of @ xmath35 . } . the @ xmath95th algorithm terminates when all good terminals can be placed in the same cycle @ xmath95 ##th . at this point , there will be no terminals left that belong to cycles which are then used to create cycles of high density . therefore , our estimate of @ xmath144 ( which is the size of the cycle ) is such that we can bound the number of terminals that are ` ` left out ' ' in this cycle . thus , when the algorithm terminates , all cycles remain in the clusters . by limiting the number of possible cycles , we can find a solution to the problem @ xmath0 - @ xmath1vc ##s of low density . because we can use cycles of high density to create clusters , an analysis similar to that of @ xcite and @ xcite shows that every large cluster has density at most @ xmath205 . we can solve this problem , but it does not work to ensure that [ ref : avekv ] . a more detailed analysis shows that there is at least one large cluster of density at most @xmath206 ; this allows us to prove the last theorem . we then first show that mergeclusters have the following properties . next , we give a series of examples which , together , show that when the algorithm starts , all terminals are in all clusters , and all clusters are 2 - connected . [ re : node ] in the algorithm , the graph @ xmath2 is always 2 - connected . the weight of a cluster is at most the number of nodes it contains . the only significant changes to @ xmath2 occur when new terminals are added to nodes ; they are connected with edges to the neighboring clusters of @ xmath2 . this implies 2 - connectivity , even if replacing these nodes with the new ones . to see that the last theorem is true , note that if a terminal belongs only to a cluster , it is always in that cluster . each terminal may be in many clusters , and each contributes to the weight of only one cluster . we give the following structural formula in terms of 2 - connectivity ; the proof is short , and often difficult . [ re : shareedge ] let @ xmath207 and @ xmath208 be @ xmath1 - connected subgraphs of the graph@ xmath5 implies that @ xmath209 . [ the cluster @ xmath210 is @ xmath1 - connected . [ node : clusters2conn ] the clusters formed by mergeclusters are all @ xmath1 - connected . let @ xmath202 be the cluster formed by breaking the cycle @ xmath35 to create each @ xmath200 . the vertices of the cycle @ xmath35 form a 2 - connected subgraph of @ xmath2 , and we assume that each @ xmath211 is 2 - connected by induction . thus , @ xmath35 contains at most 2 vertices of . @ xmath211 can be a single cluster ( for example , if we are in cluster 2 ) , but such a cluster does not be 2 - connected . ] , or we can use induction and the [ node : shareedge ] construction : we assume @ xmath212 is 2 - connected by induction , and @ xmath35 contains 2 vertices of @ xmath213 , so @ xmath214 is 2 - connected . suppose that we have that @ xmath215 is 2 - connected , and@ xmath35 ( and not @ xmath202 ) will have 2 nodes and the corresponding dummy edges . however , each individual node with the corresponding dummy edges is a member of @ xmath202 ; merging them makes @ xmath202 > - 1 . [ var : fewleftbehind ] the total cost of the clusters in tier @ xmath95 that are not connected to larger clusters of equal density is at most @ xmath216 . if this is not true ; this means that mergeclusters could create many smaller clusters of size at most @ xmath144 from the same smallest tier @ xmath95 cluster . so the total cost of merging the clusters is at most @ xmath189 , and the sum of the costs is at most @ xmath216 ; this means that the size of the cluster ( including the dummy edges ) is at most @ xmath217 . so by using [ var : cycleexists ] , the cluster must only have a single non - empty node , and otherwise the merge process would not be possible . [ cor : weightlargeclusters ] when the first mergecl##usters ##et , the total weight of large clusters is at most @ xmath218 . each terminal not in a large cluster contributes to the weight of the cluster that is then combined with others to form a cluster of a larger size . the next example says that the total weight of all terminals in a cluster is at most @ xmath219 ; since there are @ xmath220 terminals , the total weight of terminals not in such clusters is less than @ xmath221 . so far , we have shown that such terminals form large clusters , some of which are multi - dimensional , and we have not asked about the size of these clusters . the next example says that if we can find a large cluster of good size , we can find a solution to the @ xmath0 - @ xmath1vc problem of good density . [ 1 : 1 ] let @ xmath202 be a large cluster generated by mergeclusters . if @ xmath202 has weights at most @ xmath222 , we can find a cluster @ xmath223 with at most @ xmath0 terminals , each of which is @ xmath1 - close to @ x##math39 , of equal weight at most @ xmath224 . let @ xmath200 be the cluster merged to each @ xmath202 in addition to the cycle @ xmath35 that connects them ; then @ xmath211 is a new cluster , of weight at most @ xmath0 . a simple mathematical proof shows that there is a single segment of @ xmath211s with equal weight between @ xmath0 and @ xmath225 , and that the cost of the segment of @ xmath35 connecting these clusters , together with the cost of the clusters themselves , is at most @ xmath226 . let @ xmath227 be the ` ` first ' ' vertex of this segment , and @ xmath228 the ` ` second ' ' . let @ xmath28 and @ xmath229 be two copies of @ xmath227 and @ xmath228 respectively . connect segments of @ xmath28 and @ xmath229 to the cycle @ xmath39 using two edge - based paths ; the cost of this path is at most @ xmath230 . (we show that this terminal could be 2 - connected to @ xmath39 via the edges of cost at most @ xmath67 . ) the terminal @ xmath223 we construct has at most @ xmath0 ##2 , and with cost at most @ xmath231 . we show that the terminal @ xmath232 of @ xmath223 is 2 - connected to @ xmath39 ; this is our proof . let @ xmath232 be the empty vertex of @ xmath223 ; then there is a 2 - connected @ xmath131 which , when removed , removes @ xmath232 from @ xmath39 . then @ xmath28 and @ xmath229 are 2 - connected to @ xmath39 , and therefore it is in the same graph as @ xmath232 and @ xmath233 . now , we construct the 2 - connected paths @ xmath234 and @ xmath235 and @ xmath223 from @ xmath232 to @ xmath28 and @ xmath229 respectively ; and @xmath131 does not generate @ xmath232 from vertices @ xmath28 and @ xmath229 , which is a contradiction . the cycles @ xmath234 and @ xmath235 are easy to find ; let @ xmath211 be the cycle of @ xmath232 . the cycle @ xmath35 has a path from vertex @ xmath236 to @ xmath237 , and a ( vertex - independent ) path from @ xmath238 to @ xmath239 . replacing these paths with paths from @ xmath240 to @ xmath28 in @ xmath227 and @ xmath241 to @ xmath229 in @ xmath228 yields two vertex - independent paths @ xmath242 from @ xmath243 to @ xmath28 and @ xmath244 from @ xmath245 to @ xmath229 . since @ xmath211 is vertex - connected , we can find vertex - independent paths from @ xmath232 to @ xmat##h243 and @ xmath245 , which give us the two graphs @ xmath234 and @ xmath235 . can also be in the case @ xmath211 . in this case , @ xmath234 is formed by removing edges of @ xmath35 from @ xmath232 to @ xmath237 , and then a vertex from @ xmath240 to @ xmath28 ; @ xmath235 is formed . . ] we now consider the two types of graphs compared to one . the main difference between the weaker and stronger analyses is in the way we calculate the costs . in the former , each small cluster pays for its edges separately , using the fact that the edges must have length at most @ xmath246 . in the latter , we must use the fact that all clusters which have edges are merged . strictly speaking , because small clusters are edge - independent , the average density of small clusters must be equal to the size of the resulting graph @ xmath2 . if an edge is in a small cluster , we can no longer use the self - disjointness property . we must pay for these edges ., and we can prove this better . finally , the following theorem allows us to prove that a merge cluster has cost at most @ xmath205 . [ see : tiercost ] for the cluster @ xmath202 created by mergeclusters during creation @ xmath95 , the total cost of edges in @ xmath202 is at most @ xmath247 . we prove this theorem by focusing on the cost of edges in this cluster . let @ xmath248 be the set of clusters starting with a vertex @ xmath35 to create @ xmath202 . let @ xmath249 be the set of edges in @ xmath248 of size @ xmath95 , and @ xmath250 in @ xmath251 . ( @ xmath250 are pairs of clusters equal or greater than @ xmath95 that share an edge of @ xmath35 . ) the cost of edges in @ xmath202 is at most the sum of : the cost of @ xmath35 , the cost of @ xmath249 , and the cost of @ xmath25##0 . since all clusters in @ xmath250 have been formed during iteration @ xmath95 or before , and are smaller than @ xmath202 , we can use induction to prove that the cost of edges in @ xmath250 is at most @ xmath252 . all clusters in @ xmath249 are of size @ xmath95 , and they all have been formed during iteration @ xmath95 ( the cluster formed during iteration @ xmath95 is of a slightly smaller size ) , so we use induction to compute the cost of edges in @ xmath249 and @ xmath253 . then , because @ xmath35 is a finite - sized cluster , and all vertices of tier @ xmath95 contribute to compute the cost of @ xmath35 , the cost of @ xmath35 is at most @ xmath254 . therefore , the total cost of edges in @ xmath202 is at most @ xmath255 . let @ xmath202 be an infinite sized cluster ; since we have no @ xmath220 vertices , the following example shows that thedensity of @ xmath202 is at most @ xmath256 . that is , the density of @ xmath202 is at most @ xmath205 , and we can use this theorem together with theorem [ v : v ] to find a solution to the forest @ xmath0 - @ xmath1vc problem of density at most @ xmath257 . this is the ` correct ' proof , since this does not need to prove theorem [ v : avekv ] ; to prove the theorem , we would have to find a rooted cluster @ xmath202 of nodes @ xmath206 , instead of @ xmath205 . for the sake of the most accurate proof , we build a forest @ xmath258 from the forest formed by mergeclusters . first , the root set of @ xmath258 is called @ xmath13 , the set of nodes , and @ xmath258 has no nodes . every time a forest @ xmath202 is formed by nodes @ xmath200 , we add the rooted cluster @ xmath202 to the forest @ xmath25##8 , and add vertices from @ xmath202 to vertices of @ xmath203 ; @ xmath202 is the root of @ xmath259 . we then add a vertex with each vertex of @ xmath258 ; the cost of the vertex @ xmath202 is the cost of the vertex needed to create @ xmath202 from @ xmath203 . we then create the trees as the algorithm proceeds ; the root of the tree corresponds to a node that has not yet become part of a larger tree . the leaves of the trees correspond to nodes of @ xmath2 ; they all have size 1 . finally , the large cluster @ xmath202 formed during the algorithm is at the root of the tree ; we refer to this cluster as @ xmath260 . for a large cluster @ xmath202 of mergeclusters , , so that @ xmath202 is of size @ xmath95 if @ xmath202 is formed during creation @ xmath95 of mergeclusters . we then find the _ and - the _ root of @ xmath202 : they are the roots ofduring iteration @ xmath95 that becomes part of @ xmath202 . ( we include @ xmath202 itself in the list of final - stage clusters ; ) if @ xmath202 was included in iteration @ xmath95 of mergeclusters , it may contain multiple final - stage clusters . for example , during iteration @ xmath95 , we could merge multiple tier @ xmath95 clusters to form a cycle @ xmath136 of tier @ xmath261 . similarly , if we merge a similarly - sized tier @ xmath35 that contains one edge of @ xmath136 , @ xmath136 will merge with the other edge of @ xmath35 . ) the _ final _ clusters of @ xmath202 are those clusters that merge shortly after the end of iteration @ xmath95 and become a part of @ xmath202 . equivalently , the penultimate clusters are those clusters in tier @ xmath95 that are the nearest neighbors of @ xmath260 of final - stage clusters . figure 1 shows the relationships of final - stage and penultimate clusters . ( a cycle could be aif , in iteration @ xmath262 , both clusters of this tier merged to form @ xmath263 , a cluster of tier @ xmath264 . if , in iteration @ xmath95 , both @ xmath6 and @ xmath265 merged to form @ xmath266 . we will find a good cycle containing @ xmath267 and @ xmath2 ; @ xmath266 shares an edge of this tier , and these two clusters are merged to form @ xmath17 . note that the weight of this cycle is used for the calculating the weight of @ xmath267 and @ xmath2 together ; @ xmath266 is a tier @ xmath264 cluster , and therefore its weight is not used in the above calculation . therefore , we find a good cycle solution for containing @ xmath268 and @ xmath35 ; since @ xmath17 and @ xmath263 share edge with this cycle , they will merge to form the new cluster @ xmath202 . = [ circle , circle , inner sep = 0pt , outer sep = # ##pt ] ; = [ circle ,} , where size = 0pt , outer : = [ size ] ; = [ size = ] ; \ ( f ) at ( 3 , 4 . 5 ) [ high ] @ xmath202 ; \ ( a ) at ( 1 . 5 , 4 ) [ high ] @ xmath95 ; ( b ) at ( 3 . 5 , 4 ) [ high ] @ xmath269 ; ( c ) at ( 3 . 5 , 4 ) [ high ] @ xmath95 ; ( d ) at ( 1 . 5 , 4 ) [ high ] @ xmath264 ; ( e ) ( f ) ( y ) ; ( c ) ( f ) ( d ) ; at ( 3 . 7 , 4 ) @ xmath268 ; at ( 3 . 7 , 4 ) @ xmath17 ; at ( 3 . 5 , 4 ) @ xmath35 ; at ( 3 . 7 , 4 ) @ xmath263 ; \ ( e ) at ( 4 , 2 . 5 ) [ high ] @ xmath95 ; ( f ) at ( 1 . 5 , 2 . 5 ) [ high ] @ xmath264 ; ( g ) at (3 , 2 . 5 ) [ vertex ] @ xmath95 ; ( a ) ( g ) ( g ) ; ( b ) ( h ) ; at ( 4 . 3 , 2 . 5 ) @ xmath267 ; at ( 3 . 3 , 2 . 5 ) @ xmath266 ; at ( 4 . 3 , 1 . 3 ) @ xmath2 ; \ ( g ) at ( 3 . 8 , 1 ) [ vertex ] @ xmath95 ; ( g ) at ( 3 . 8 , 1 ) [ vertex ] @ xmath95 ; ( g ) ( i ) ( h ) ; at ( 4 . 5 , 1 . 3 ) @ xmath6 ; at ( 4 . 3 , 1 . 3 ) @ xmath265 ; at ( a ) [ vertex ] ; at ( b ) [ vertex ] ; at ( c ) [ vertex ] ; an edge of a directed graph @ xmath202 is said to be called _ final edge _ if it is located in a graph @ xmath35 that is a two - vertex graph of @ xmath202 . all other edges of @ xmath202 are called _ final edge_ ; note that the final vertex is in the final cluster of @ xmath202 . we define the _ final cost _ of @ xmath202 to be the sum of the costs of its final cluster , and the _ final cost _ to be the sum of the costs of its final vertices ; therefore , the cost of @ xmath202 is the sum of its final and penultimate costs . we define the final cost and penultimate cost as . note that an edge is the final vertex of the final cluster @ xmath202 if it is used by mergeclusters to form a cycle @ xmath35 , the last iteration during which @ xmath202 was used . the way we can define the cost of final cycles means that the weight of any such cycle is at most @ xmath144 , the number of vertices involved in the cycle , and each vertex does not contribute to the cost of more than one vertex during an iteration . ( this is also the definition of the [ le : tiercost ] . ) we use this definition in the following way . [ le : cost ] the final weight of a final cycle @ xmath202 is at most @ xmat##h270 , where @ xmath271 is the weight of @ xmath202 . let @ xmath202 be an initial vertex of . in the construction of the graph @ xmath260 , we associate with each vertex of @ xmath260 the weight of the algorithm used to create the new vertex . to calculate the total computational cost of @ xmath202 , we must compute the sum of the costs of vertices of @ xmath260 associated with final - stage clusters . the cost of @ xmath202 , @ xmath271 is at least the sum of the costs of the first tier @ xmath95 clusters that are a part of @ xmath202 . then , it follows to show that the sum of the costs of vertices of @ xmath260 associated with final - stage clusters is at least @ xmath144 , the sum of the costs of @ xmath202 sub - tier @ xmath95 clusters . ( note that the new @ xmath95 cluster must have been created prior to creating @ xmath95 , and that it need not itself be a final - stage( . ) a tree is used to create a final - stage cluster @ xmath136 , if the cost is at most @ xmath144 times the sum of weights of the penultimate tier @ xmath95 cluster that becomes a part of @ xmath136 . ( other clusters may become a part of @ xmath136 , if they do not add up to the weight required . ) similarly , if @ xmath136 becomes a part of @ xmath260 corresponding to a final - stage cluster , the cost of @ xmath136 is at most @ xmath144 times the sum of the costs of the parent @ xmath95 and that of @ xmath260 . but @ xmath260 is a tree , and therefore each vertex corresponding to a penultimate tier @ xmath95 cluster has more than one weight . that is , the parent of a tree node accounts for only one final - stage cluster . therefore , the sum of the weights of vertices associated with final - stage clusters is at most @ xmath144 times the sum of the weights of @ xmath202 multi - layer @ xmath95 cluster, and that the average size of @ xmath202 is at most @ xmath270 . [ 1 : 1 ] if @ xmath272 and @ xmath273 are two small clusters of the same size , the edge is a penultimate edge of both @ xmath272 and @ xmath273 . note , by way of illustration , that the edge @ xmath85 is a penultimate edge of both @ xmath272 and @ xmath273 , which are small clusters of starting @ xmath95 . let @ xmath274 ( or @ xmath275 ) be the penultimate edge of @ xmath272 ( resp . @ xmath273 ) and @ xmath85 . in small clusters , both @ xmath274 and @ xmath275 were formed by starting @ xmath95 . up until iteration @ xmath95 , each is part of a larger cluster , and two small clusters can not form an edge without being separated . therefore , @ xmath274 and @ xmath275 must have been formed , and they need not belong to two larger clusters, yielding the following result . [ source : goodlargecluster ] when mergeclusters merge , at most one large cluster has cost at most @ xmath206 . we define the _ penultimate cost _ of a large cluster to be the ratio of its penultimate cost to its weight . consider the _ penultimate cost of all large clusters : for type @ xmath95 , each edge @ xmath276 can be a penultimate edge of at most one large cluster of type @ xmath95 . this means that each edge can be a penultimate edge of at most @ xmath220 . . therefore , the ratio of penultimate costs of all large clusters is at most @ xmath277 . therefore , the penultimate weight of all large clusters is at most @ xmath278 . therefore , the ( _ ) _ penultimate cost of large clusters is at most @ xmath279 , and therefore there is a large cluster @ xmath202 of highest cost at most @ xmath280 . the penultimate cost of @ xmath202 is , therefore , at most @ xmath281 , and from the [ 1 : 1 ] , the penultimate cost of@ xmath202 cost at most @ xmath270 . therefore , the cost of @ xmath202 cost at most @ xmath282 . theorem [ cm : goodlargecluster ] and theorem [ cm : algorithm ] both show that we can find a solution to the rooted @ xmath0 - @ xmath1vc problem of cost at most @ xmath191 . this is our proof of theorem [ cm : avekv ] . we have the following optimization problems : * can the approximation ratio for the @ xmath0 - @ xmath1vc problem be improved from the rooted @ xmath44 to @ xmath283 or better ? * the use of @ xmath32 to solve the @ xmath284 could be improved . if so , can we improve the approximation ratio for the rooted @ xmath0 - @ xmath1ec problem ? * can we find efficient solutions for the @ xmath0 - @ xmath8vc - @ xmath0 - @ xmath8ec problem for @ xmath285 ? in general , good solutions are known for problems where the- connectivity is required to be greater than 1 , but there has been some success with the non - connectivity algorithm . * for a two - dimensional graph of size @ xmath146 with all vertices marked as vertices , we assume that it has a non - trivial cycle with length at most @ xmath146 , and find an algorithm to find such a cycle . we have also found the @ xmath37 - algorithm for the problem of finding a minimum - density non - trivial cycle . is there a two - dimensional approximation for this problem ? can it be solved _ _ _ in polynomial time ? s . awerbuch , s . azar , s . blum and s . vempala . _ approximation guarantees for minimum density @ xmath0 - machines and garbage - collection _ . , 10 ( 4 ) : 254262 , 1999 . online . _ _ proc . of acm stoc _ , 1995 . j . j . goemans and m . j . williamson . the self - balancing algorithm for approximation guarantees and their application to circuit theory _ . in j . a . hochbaum , ed , _ approximation guarantees for np - complete problems _ . pws publishing company , 1996 .